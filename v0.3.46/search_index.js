var documenterSearchIndex = {"docs":
[{"location":"differentiable_programming/#Differentiable-programming","page":"Differentiable programming","title":"Differentiable programming","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Julia and its ecosystem provide some tools for differentiable programming. Trixi.jl is designed to be flexible, extendable, and composable with Julia's growing ecosystem for scientific computing and machine learning. Thus, the ultimate goal is to have fast implementations that allow automatic differentiation (AD) without too much hassle for users. If some parts do not meet these requirements, please feel free to open an issue or propose a fix in a PR.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"In the following, we will walk through some examples demonstrating how to differentiate through Trixi.jl.","category":"page"},{"location":"differentiable_programming/#Forward-mode-automatic-differentiation","page":"Differentiable programming","title":"Forward mode automatic differentiation","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Trixi integrates well with ForwardDiff.jl for forward mode AD.","category":"page"},{"location":"differentiable_programming/#Computing-the-Jacobian","page":"Differentiable programming","title":"Computing the Jacobian","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The high-level interface to compute the Jacobian this way is jacobian_ad_forward.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> using Trixi, LinearAlgebra, Plots\n\njulia> equations = CompressibleEulerEquations2D(1.4);\n\njulia> solver = DGSEM(3, flux_central);\n\njulia> mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\njulia> J = jacobian_ad_forward(semi);\n\njulia> size(J)\n(1024, 1024)\n\njulia> λ = eigvals(J);\n\njulia> scatter(real.(λ), imag.(λ));\n\njulia> 3.0e-10 < maximum(real, λ) / maximum(abs, λ) < 8.0e-10\ntrue\n\njulia> 1.0e-7 < maximum(real, λ) < 5.0e-7\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Interestingly, if we add dissipation by switching to the flux_lax_friedrichs at the interfaces, the maximal real part of the eigenvalues increases.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> solver = DGSEM(3, flux_lax_friedrichs);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\njulia> J = jacobian_ad_forward(semi);\n\njulia> λ = eigvals(J);\n\njulia> scatter!(real.(λ), imag.(λ));\n\njulia> λ = eigvals(J); round(maximum(real, λ) / maximum(abs, λ), sigdigits=2)\n2.1e-5\n\njulia> round(maximum(real, λ), sigdigits=2)\n0.0057","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"However, we should be careful when using this analysis, since the eigenvectors are not necessarily well-conditioned.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> λ, V = eigen(J);\n\njulia> round(cond(V), sigdigits=2)\n1.8e6","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"In one space dimension, the situation is a bit different.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> equations = CompressibleEulerEquations1D(1.4);\n\njulia> solver = DGSEM(3, flux_central);\n\njulia> mesh = TreeMesh((-1.0,), (1.0,), initial_refinement_level=6, n_cells_max=10^5);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\njulia> J = jacobian_ad_forward(semi);\n\njulia> λ = eigvals(J);\n\njulia> scatter(real.(λ), imag.(λ));\n\njulia> 1.0e-16 < maximum(real, λ) / maximum(abs, λ) < 6.0e-16\ntrue\n\njulia> 1.0e-12 < maximum(real, λ) < 6.0e-12\ntrue\n\njulia> λ, V = eigen(J);\n\njulia> 200 < cond(V) < 300\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"If we add dissipation, the maximal real part is still approximately zero.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> solver = DGSEM(3, flux_lax_friedrichs);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\njulia> J = jacobian_ad_forward(semi);\n\njulia> λ = eigvals(J);\n\njulia> scatter!(real.(λ), imag.(λ));\n\njulia> λ = eigvals(J);\n\njulia> -1.0e-16 < maximum(real, λ) / maximum(abs, λ) < 1.0e-16\ntrue\n\njulia> -5.0e-13 < maximum(real, λ) < 5.0e-13\ntrue\n\njulia> λ, V = eigen(J);\n\njulia> 80_000 < cond(V) < 110_000\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that the condition number of the eigenvector matrix increases but is still smaller than for the example in 2D.","category":"page"},{"location":"differentiable_programming/#Computing-other-derivatives","page":"Differentiable programming","title":"Computing other derivatives","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"It is also possible to compute derivatives of other dependencies using AD in Trixi. For example, you can compute the gradient of an entropy-dissipative semidiscretization with respect to the ideal gas constant of the compressible Euler equations as described in the following. This example is also available as the elixir examples/special_elixirs/elixir_euler_ad.jl","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> using Trixi, LinearAlgebra, ForwardDiff\n\njulia> equations = CompressibleEulerEquations2D(1.4);\n\njulia> mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\njulia> solver = DGSEM(3, flux_lax_friedrichs, VolumeIntegralFluxDifferencing(flux_ranocha));\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_isentropic_vortex, solver);\n\njulia> u0_ode = compute_coefficients(0.0, semi); size(u0_ode)\n(1024,)\n\njulia> J = ForwardDiff.jacobian((du_ode, γ) -> begin\n           equations_inner = CompressibleEulerEquations2D(first(γ))\n           semi_inner = Trixi.remake(semi, equations=equations_inner, uEltype=eltype(γ));\n           Trixi.rhs!(du_ode, u0_ode, semi_inner, 0.0)\n       end, similar(u0_ode), [1.4]); # γ needs to be an `AbstractArray`\n\njulia> round.(extrema(J), sigdigits=2)\n(-5.6, 5.6)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that we create a semidiscretization semi at first to determine the state u0_ode around which we want to perform the linearization. Next, we wrap the RHS evaluation inside a closure and pass that to ForwardDiff.jacobian. There, we need to make sure that the internal caches are able to store dual numbers from ForwardDiff.jl by setting uEltype appropriately. A similar approach is used by jacobian_ad_forward.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that the ideal gas constant does not influence the semidiscrete rate of change of the density, as demonstrated by","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> norm(J[1:4:end])\n0.0","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Here, we used some knowledge about the internal memory layout of Trixi, an array of structs with the conserved variables as fastest-varying index in memory.","category":"page"},{"location":"differentiable_programming/#Differentiating-through-a-complete-simulation","page":"Differentiable programming","title":"Differentiating through a complete simulation","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"It is also possible to differentiate through a complete simulation. As an example, let's differentiate the total energy of a simulation using the linear scalar advection equation with respect to the wave number (frequency) of the initial data.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> using Trixi, OrdinaryDiffEq, ForwardDiff, Plots\n\njulia> function energy_at_final_time(k) # k is the wave number of the initial condition\n           equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n           mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n           solver = DGSEM(3, flux_lax_friedrichs)\n           initial_condition = (x, t, equation) -> begin\n               x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n               return SVector(sinpi(k * sum(x_trans)))\n           end\n           semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n           ode = semidiscretize(semi, (0.0, 1.0))\n           sol = solve(ode, BS3(), save_everystep=false)\n           Trixi.integrate(energy_total, sol.u[end], semi)\n       end\nenergy_at_final_time (generic function with 1 method)\n\njulia> k_values = range(0.9, 1.1, length=101)\n0.9:0.002:1.1\n\njulia> plot(k_values, energy_at_final_time.(k_values), label=\"Energy\");","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"You should see a plot of a curve that resembles a parabola with local maximum around k = 1.0. Why's that? Well, the domain is fixed but the wave number changes. Thus, if the wave number is not chosen as an integer, the initial condition will not be a smooth periodic function in the given domain. Hence, the dissipative surface flux (flux_lax_friedrichs in this example) will introduce more dissipation. In particular, it will introduce more dissipation for \"less smooth\" initial data, corresponding to wave numbers k further away from integers.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"We can compute the discrete derivative of the energy at the final time with respect to the wave number k as follows.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> round(ForwardDiff.derivative(energy_at_final_time, 1.0), sigdigits=2)\n1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"This is rather small and we can treat it as zero in comparison to the value of this derivative at other wave numbers k.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> dk_values = ForwardDiff.derivative.((energy_at_final_time,), k_values);\n\njulia> plot(k_values, dk_values, label=\"Derivative\");","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"If you remember basic calculus, a sufficient condition for a local maximum is that the first derivative vanishes and the second derivative is negative. We can also check this discretely.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> round(ForwardDiff.derivative(\n           k -> Trixi.ForwardDiff.derivative(energy_at_final_time, k),\n       1.0), sigdigits=2)\n-0.9","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Having seen this application, let's break down what happens step by step.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> function energy_at_final_time(k) # k is the wave number of the initial condition\n           equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n           mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n           solver = DGSEM(3, flux_lax_friedrichs)\n           initial_condition = (x, t, equation) -> begin\n               x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n               return SVector(sinpi(k * sum(x_trans)))\n           end\n           semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n           ode = semidiscretize(semi, (0.0, 1.0))\n           sol = solve(ode, BS3(), save_everystep=false)\n           Trixi.integrate(energy_total, sol.u[end], semi)\n       end\n\njulia> round(ForwardDiff.derivative(energy_at_final_time, 1.0), sigdigits=2)\n1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"When calling ForwardDiff.derivative(energy_at_final_time, 1.0), ForwardDiff.jl will basically use the chain rule and known derivatives of existing basic functions to calculate the derivative of the energy at the final time with respect to the wave number k at k0 = 1.0. To do this, ForwardDiff.jl uses dual numbers, which basically store the result and its derivative w.r.t. a specified parameter at the same time. Thus, we need to make sure that we can treat these ForwardDiff.Dual numbers everywhere during the computation. Fortunately, generic Julia code usually supports these operations. The most basic problem for a developer is to ensure that all types are generic enough, in particular the ones of internal caches.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The first step in this example creates some basic ingredients of our simulation.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\nsolver = DGSEM(3, flux_lax_friedrichs)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"These do not have internal caches storing intermediate values of the numerical solution, so we do not need to adapt them. In fact, we could also define them outside of energy_at_final_time (but would need to take care of globals or wrap everything in another function).","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Next, we define the initial condition","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"initial_condition = (x, t, equation) -> begin\n    x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n    return SVector(sinpi(k * sum(x_trans)))\nend","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"as a closure capturing the wave number k passed to energy_at_final_time. If you call energy_at_final_time(1.0), k will be a Float64. Thus, the return values of initial_condition will be SVectors of Float64s. When calculating the ForwardDiff.derivative, k will be a ForwardDiff.Dual number. Hence, the initial_condition will return SVectors of ForwardDiff.Dual numbers.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The semidiscretization semi uses some internal caches to avoid repeated allocations and speed up the computations, e.g. for numerical fluxes at interfaces. Thus, we need to tell Trixi to allow ForwardDiff.Dual numbers in these caches. That's what the keyword argument uEltype=typeof(k) in","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    uEltype=typeof(k))","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"does. This is basically the only part where you need to modify your standard Trixi code to enable automatic differentiation. From there on, the remaining steps","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"ode = semidiscretize(semi, (0.0, 1.0))\nsol = solve(ode, BS3(), save_everystep=false)\nTrixi.integrate(energy_total, sol.u[end], semi)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"do not need any modifications since they are sufficiently generic (and enough effort has been spend to allow general types inside these calls).","category":"page"},{"location":"differentiable_programming/#Propagating-errors-using-Measurements.jl","page":"Differentiable programming","title":"Propagating errors using Measurements.jl","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: Error bars by Randall Munroe)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Similar to AD, Trixi also allows propagating uncertainties using linear error propagation theory via Measurements.jl. As an example, let's create a system representing the linear advection equation in 1D with an uncertain velocity. Then, we create a semidiscretization using a sine wave as initial condition, solve the ODE, and plot the resulting uncertainties in the primitive variables.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, OrdinaryDiffEq, Measurements, Plots, LaTeXStrings\n\nequations = LinearScalarAdvectionEquation1D(1.0 ± 0.1);\n\nmesh = TreeMesh((-1.0,), (1.0,), n_cells_max=10^5, initial_refinement_level=5);\n\nsolver = DGSEM(3);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test,\n                                    solver, uEltype=Measurement{Float64});\n\node = semidiscretize(semi, (0.0, 1.5));\n\nsol = solve(ode, BS3(), save_everystep=false);\n\nplot(sol)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"You should see a plot like the following, where small error bars are shown around the extrema and larger error bars are shown in the remaining parts. This result is in accordance with expectations. Indeed, the uncertain propagation speed will affect the extrema less since the local variation of the solution is relatively small there. In contrast, the local variation of the solution is large around the turning points of the sine wave, so the uncertainties will be relatively large there.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"All this is possible due to allowing generic types and having good abstractions in Julia that allow packages to work together seamlessly.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: tutorial_measurements1)","category":"page"},{"location":"differentiable_programming/#Finite-difference-approximations","page":"Differentiable programming","title":"Finite difference approximations","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Trixi provides the convenience function jacobian_fd to approximate the Jacobian via central finite differences.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> using Trixi, LinearAlgebra\n\njulia> equations = CompressibleEulerEquations2D(1.4);\n\njulia> solver = DGSEM(3, flux_central);\n\njulia> mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\njulia> J_fd = jacobian_fd(semi);\n\njulia> J_ad = jacobian_ad_forward(semi);\n\njulia> norm(J_fd - J_ad) / size(J_fd, 1) < 7.0e-7\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"This discrepancy is of the expected order of magnitude for central finite difference approximations.","category":"page"},{"location":"differentiable_programming/#Linear-systems","page":"Differentiable programming","title":"Linear systems","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"When a linear PDE is discretized using a linear scheme such as a standard DG method, the resulting semidiscretization yields an affine ODE of the form","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"partial_t u(t) = A u(t) + b","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"where A is a linear operator (\"matrix\") and b is a vector. Trixi allows you to obtain this linear structure in a matrix-free way by using linear_structure. The resulting operator A can be used in multiplication, e.g. mul! from LinearAlgebra, converted to a sparse matrix using sparse from SparseArrays, or converted to a dense matrix using Matrix for detailed eigenvalue analyses. For example,","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"julia> using Trixi, LinearAlgebra, Plots\n\njulia> equations = LinearScalarAdvectionEquation2D(1.0, -0.3);\n\njulia> solver = DGSEM(3, flux_lax_friedrichs);\n\njulia> mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\njulia> semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test, solver);\n\njulia> A, b = linear_structure(semi);\n\njulia> size(A), size(b)\n((256, 256), (256,))\n\njulia> λ = eigvals(Matrix(A));\n\njulia> scatter(real.(λ), imag.(λ));\n\njulia> λ = eigvals(Matrix(A)); maximum(real, λ) / maximum(abs, λ) < 1.0e-15\ntrue","category":"page"},{"location":"meshes/tree_mesh/#Tree-mesh","page":"Tree mesh","title":"Tree mesh","text":"","category":"section"},{"location":"meshes/tree_mesh/","page":"Tree mesh","title":"Tree mesh","text":"The TreeMesh is a Cartesian, h-non-conforming mesh type used in many parts of Trixi. Often, the support for this mesh type is developed best since it was the first mesh type in Trixi, and it is available in one, two, and three space dimensions.","category":"page"},{"location":"meshes/tree_mesh/","page":"Tree mesh","title":"Tree mesh","text":"It is limited to hypercube domains but supports AMR via the AMRCallback. Due to its Cartesian nature, (numerical) fluxes need to implement methods dispatching on the orientation::Integer as described in the conventions.","category":"page"},{"location":"meshes/unstructured_quad_mesh/#Unstructured-quadrilateral-mesh","page":"Unstructured mesh","title":"Unstructured quadrilateral mesh","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The UnstructuredMesh2D is an unstructured, curvilinear, conforming mesh type in two space dimensions.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Next, we describe the conventions taken in the implementation for two-dimensional unstructured quadrilateral meshes. Principally, this relates to how a file with the extension .mesh encodes information about the numbering and orientation of elements in an unstructured quadrilateral mesh with possibly curved boundaries.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"We use the following unstructured mesh with three elements for this discussion:","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"(Image: example-mesh)","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Further, a simulation using Trixi on this example unstructured mesh is provided in examples/2d/elixir_euler_unstructured_quad_basic.jl.","category":"page"},{"location":"meshes/unstructured_quad_mesh/#Mesh-file-header","page":"Unstructured mesh","title":"Mesh file header","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The first two lines of the mesh file lists the mesh file type as well as the total number of corners, surfaces, elements, and the polynomial degree that the mesh will use to represent any curved sides. For the example mesh these quantities are","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"ISM-V2\n    7    9    3    8","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"corresponding to seven corners, nine surfaces, and three elements. The mesh polynomial degree of eight is taken only for illustrative purposes. In practice, this mesh polynomial degree depends on the particular application for which the curved, unstructured mesh is required.","category":"page"},{"location":"meshes/unstructured_quad_mesh/#List-of-corner-nodes","page":"Unstructured mesh","title":"List of corner nodes","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"After these global counts that prescribe information about the mesh skeleton, the mesh file give a list of the physical (x,y) coordinates of all the corners. The corner nodes are listed in the order prescribed by mesh generator. Thus, for the example mesh this node list would be","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":" 1.0    -1.0\n 3.0    0.0\n 1.0    1.0\n 2.0    0.0\n 0.0    0.0\n 3.0    1.0\n 3.0    -1.0","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The corner nodes are internally referenced by their position in the list above. For example, here the node at (1.0, -1.0) would have node id 1, node id 2 would be at (3.0, 0.0) etc.","category":"page"},{"location":"meshes/unstructured_quad_mesh/#List-of-neighbor-connectivity","page":"Unstructured mesh","title":"List of neighbor connectivity","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"After the corner list comes the neighbor connectivity along each surface in the mesh. This includes local indexing and orientation information necessary to compute the coupling between elements in the mesh. In 2D each surface is defined by connecting two nodes indexed as with the numbering above. We adopt the convention that node id 1 < node id 2.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Each surface will have two neighbors where the element on the left locally as one \"walks\" from node id 1 to node id 2 is taken to be the primary element and the element locally on the right is taken to be the secondary element. If, however, there is no secondary element index, then the surface lies along a physical boundary. In this case the only available element index is considered to be primary and the secondary index is set to zero.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The final two index numbers within the neighbor information list are used to identify the local surface within each element. The first local surface index (on the primary element) will always be positive whereas the second local surface index (on the primary element) can be positive or negative. If the second local surface index is positive, then the local coordinate systems in the primary element and secondary element match, i.e., the indexing on either side runs from 1:polydeg+1. However, if the local surface index of the secondary element is negative in the mesh file, then the coordinate system in the secondary element is flipped with respect to the primary element. Therefore, care must be taken in the implementation to ensure that the primary element indexing runs from 1:polydeg+1 whereas the secondary element indexing must run in reverse from polydeg+1:-1:1. Finally, if the secondary element index is zero, then so will be the local surface index because the surface is on a physical boundary. Also, there is no flipping of coordinate indexing required at the physical boundary because only the primary element's coordinate system exists.","category":"page"},{"location":"meshes/unstructured_quad_mesh/#Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces.","page":"Unstructured mesh","title":"Three examples: One along a physical boundary and two along interior surfaces.","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {8} we connect node (2) to node (7) and are along a physical boundary in element 3 with the local surface index 1 and the neighbor information:","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    7    3    0    1    0","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {1} we connect node (2) to node (4) such that the primary element is 3 with local surface index 2 and the secondary element is 2 with local surface index 1. Furthermore, we see that coordinate system in the secondary element 2 is flipped with respect to the primary element's coordinate system such that the sign of the local surface index in the secondary element flips. This gives the following neighbor information:","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    4    3    2    2    -1","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {4} we connect node (1) to node (4) such that the primary element is 1 with local surface index 2 and the secondary element is 3 with local surface index 3. The coordinate systems in both elements match and no sign change is required on the local surface index in the secondary element:","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    1    4    1    3    2    3","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"We collect the complete neighbor information for the example mesh above:","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    4    3    2    2    -1\n    3    5    1    0    4    0\n    1    5    1    0    1    0\n    1    4    1    3    2    3\n    2    6    2    0    2    0\n    1    7    3    0    4    0\n    3    6    2    0    3    0\n    2    7    3    0    1    0\n    3    4    2    1    4    -3","category":"page"},{"location":"meshes/unstructured_quad_mesh/#List-of-elements","page":"Unstructured mesh","title":"List of elements","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Each quadrilateral element in the unstructured mesh is dictated by four corner points with indexing taken from the numbering given by the corner list above. We connect a set of four corner points (starting from the bottom left) in an anti-clockwise fashion thus making the element right-handed indicated using the circular arrow in the figure above. In turn, this right-handedness defines the local surface indexing (i.e. the four local sides) and the local (xi eta) coordinate system. For example, the four corners for element 1 would be listed as","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The mesh file also encodes information for curved surfaces either interior to the domain (as surface {9} above) or along the physical boundaries. A set of check digits are included directly below the four corner indexes to indicate whether the local surface index (1, 2, 3, or 4) within the element is straight sided, 0, or is curved, 1. If the local surface is straight sided no additional information is necessary during the mesh file read in. But for any curved surfaces the mesh file provides (x,y) coordinate values in order to construct an interpolant of this surface with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes. This list of (x,y) data will be given in the direction of the local coordinate system.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"The last piece of information provided by the mesh file are labels for the different surfaces of an element. These labels are useful to set boundary conditions along physical surfaces. The labels can be short descriptive words. The label --- indicates an internal surface where no boundary condition is required.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"As an example, the complete information for element 1 in the example mesh would be","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3\n    0    0    1    1\n 1.000000000000000   1.000000000000000\n 1.024948365654583   0.934461926834452\n 1.116583018200151   0.777350964621867\n 1.295753434047077   0.606254343587194\n 1.537500000000000   0.462500000000000\n 1.768263070247418   0.329729152118310\n 1.920916981799849   0.185149035378133\n 1.986035130050921   0.054554577460044\n 2.000000000000000                 0.0\n               0.0                 0.0\n 0.035513826946206   0.105291711848750\n 0.148591270347399   0.317731556850611\n 0.340010713990041   0.452219430075470\n 0.575000000000000   0.462500000000000\n 0.788022294598950   0.483764065630034\n 0.926408729652601   0.644768443149389\n 0.986453164464803   0.883724792445746\n 1.000000000000000   1.000000000000000\n Slant --- --- Bezier","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"where the curved boundary information is encoded \"back to back\". That is, the first nine (x,y) nodes in the list above correspond to the interior boundary curve along local side 3 in element 1 and the next nine (x,y) nodes denote the curved physical boundary named Bezier along local side 4.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"We collect the complete set of element information for the example mesh","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3\n    0    0    1    1\n 1.000000000000000   1.000000000000000\n 1.024948365654583   0.934461926834452\n 1.116583018200151   0.777350964621867\n 1.295753434047077   0.606254343587194\n 1.537500000000000   0.462500000000000\n 1.768263070247418   0.329729152118310\n 1.920916981799849   0.185149035378133\n 1.986035130050921   0.054554577460044\n 2.000000000000000                 0.0\n               0.0                 0.0\n 0.035513826946206   0.105291711848750\n 0.148591270347399   0.317731556850611\n 0.340010713990041   0.452219430075470\n 0.575000000000000   0.462500000000000\n 0.788022294598950   0.483764065630034\n 0.926408729652601   0.644768443149389\n 0.986453164464803   0.883724792445746\n 1.000000000000000   1.000000000000000\n Slant --- --- Bezier\n    4    2    6    3\n    0    0    0    1\n 2.000000000000000                 0.0\n 1.986035130050921   0.054554577460044\n 1.920916981799849   0.185149035378133\n 1.768263070247418   0.329729152118310\n 1.537500000000000   0.462500000000000\n 1.295753434047077   0.606254343587194\n 1.116583018200151   0.777350964621867\n 1.024948365654583   0.934461926834452\n 1.000000000000000   1.000000000000000\n --- Right Top ---\n    7    2    4    1\n    0    0    0    0\n Right --- --- Bottom","category":"page"},{"location":"meshes/unstructured_quad_mesh/#Trixi.jl-on-an-unstructured-quadrilateral-mesh","page":"Unstructured mesh","title":"Trixi.jl on an unstructured quadrilateral mesh","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"We provide an example simulation on an unstructured quadrilateral mesh by executing","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"julia> trixi_include(default_example_unstructured())","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"Note this may download a copy of the mesh file described above for the three element unstructured mesh. This elixir provides the solution for the compressible Euler equations in two spatial dimensions for a smooth propagating wave solution. Below we provide the time evolution of the pressure wave for this example created with the Trixi2Vtk tool and visualized using ParaView.","category":"page"},{"location":"meshes/unstructured_quad_mesh/","page":"Unstructured mesh","title":"Unstructured mesh","text":"  <!--\n  Video creation details\n  * Set up terminal size and position appropriately\n  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)\n  * Upload to YouTube\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/lS8GjuctXAY' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Trixi is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as merge requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Trixi and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/#Interactive-use-of-Julia","page":"Development","title":"Interactive use of Julia","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"When a Julia program is executed, Julia first loads and parses all code. Then, the just-in-time compiler has to compile all functions at their first use, which incurs an overhead each time a program is run. For proper packages and commands executed in the REPL (= \"return-eval-print loop\", which is what the Julia community calls the interactive command-line prompt that opens when executing julia without any files as arguments), however, the previously compiled functions are cached. Therefore, Trixi should generally always be used interactively from the REPL without closing Julia during development, as it allows much faster turnaround times.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"If you naively run Trixi from the REPL, you will not be able to change your Trixi source files and then run the changed code without restarting the REPL, which destroys any potential benefits from caching. However, restarting Julia can be avoided by using the Revise.jl package, which tracks changed files and re-loads them automatically. Therefore, it is highly recommended to first install Revise with the following command in Julia: To enter the package REPL mode, press ] in the standard Julia REPL mode. Then, execute","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"(@v1.6) pkg> add Revise","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Now you are able to run Trixi from the REPL, change Trixi code between runs, and enjoy the advantages of the compilation cache! Before you start using Revise regularly, please be aware of some of the Pitfalls when using Revise.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Another recommended package for working from the REPL is OhMyREPL.jl. It can be installed by running","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"(@v1.6) pkg> add OhMyREPL","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"and adds syntax highlighting, bracket highlighting, and other helpful improvements for using Julia interactively. To automatically use OhMyREPL when starting the REPL, follow the instructions given in the official documentation.","category":"page"},{"location":"development/#Running-Trixi-interactively-in-the-global-environment","page":"Development","title":"Running Trixi interactively in the global environment","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you've installed Trixi and Revise in your default environment, begin by executing:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"This will start the Julia REPL. Then, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia> using Revise; using Trixi","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"You can run a simulation by executing","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia> trixi_include(default_example())","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Together, all of these commands can take some time, roughly half a minute on a modern workstation. Most of the time is spent on compilation of Julia code etc. If you execute the last command again in the same REPL, it will finish within a few milliseconds (maybe ~45 on a modern workstation).  This demonstrates the second reason for using the REPL: the compilation cache.  That is, those parts of the code that do not change between two Trixi runs do not need to be recompiled and thus execute much faster after the first run.","category":"page"},{"location":"development/#Manually-starting-Trixi-in-the-local-environment","page":"Development","title":"Manually starting Trixi in the local environment","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you followed the installation instructions for developers, execute Julia with the project directory set to the package directory of the program/tool you want to use. For example, to run Trixi this way, you need to start the REPL with","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=path/to/Trixi.jl/","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"and execute","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia> using Revise; using Trixi","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"to load Revise and Trixi. You can then proceed with the usual commands and run Trixi as in the example above. The --project flag is required such that Julia can properly load Trixi and all dependencies if Trixi is not installed in the global environment. The same procedure also applies should you opt to install the postprocessing tools Trixi2Vtk and Trixi2Img manually such that you can modify their implementations.","category":"page"},{"location":"development/#Pitfalls-when-using-Revise","page":"Development","title":"Pitfalls when using Revise","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"While Revise is a great help for developing Julia code, there are a few situations to watch out for when using Revise. The following list of potential issues is based on personal experiences of the Trixi developers and probably incomplete.  Further information on limitations and possible issues with Revise can be found in the official documentation.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"tip: If in doubt, restart the REPL\nOftentimes, it is possible to recover from issues with Revise by fixing the offending code. Sometimes, however, this is not possible or you might have troubles finding out what exactly caused the problems. Therefore, in these cases, or if in doubt, restart the REPL to get a fresh start.","category":"page"},{"location":"development/#Syntax-errors-are-easy-to-miss","page":"Development","title":"Syntax errors are easy to miss","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Revise does not stop on syntax errors, e.g., when you accidentally write a[i) instead of a[i].  In this case, Revise reports an error but continues to use the old version of your files! This is especially dangerous for syntax errors, as they are detected while Revise reloads changed code, which happens in the beginning of a new execution. Thus, the syntax error message quickly disappears from the terminal once Trixi starts writing output to the screen and you might not even have noticed that an error occurred at all.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Therefore, when you are deep in a coding/debugging session and wonder why your code modifications do not seem to have any effect, scroll up in your terminal to check if you missed earlier syntax errors, or - if in doubt - restart your REPL.","category":"page"},{"location":"development/#Files-are-not-tracked-after-changing-branches","page":"Development","title":"Files are not tracked after changing branches","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Sometimes, Revise stops tracking files when changing the Git branch. That is, modifications to Trixi's source files will not be reloaded by Revise and thus have no effect of a currently running REPL session. This issue is particularly annoying for a developer, since it does not come with any warning!  Therefore, it is good practice to always restart the REPL after changing branches.","category":"page"},{"location":"development/#Changes-to-type-definitions-are-not-allowed","page":"Development","title":"Changes to type definitions are not allowed","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Revise cannot handle changes to type definitions, e.g., when modifying the fields in a struct. In this case, Revise reports an error and refuses to run your code unless you undo the modifications. Once you undo the changes, Revise will usually continue to work as expected again. However, if you want to keep your type modifications, you need to restart the REPL.","category":"page"},{"location":"development/#Using-the-Julia-REPL-effectively","page":"Development","title":"Using the Julia REPL effectively","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"The Julia manual is an excellent resource to learn Julia. Here, we list some helpful commands than can increase your productivity in the Julia REPL.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Use the REPL help mode entered by typing ?.\njulia> using Trixi\n\nhelp?> trixi_include\nsearch: trixi_include\n\n  trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)\n\n  include the file elixir and evaluate its content in the global scope of module mod. You can override specific\n  assignments in elixir by supplying keyword arguments. It's basic purpose is to make it easier to modify some\n  parameters while running Trixi from the REPL. Additionally, this is used in tests to reduce the computational\n  burden for CI while still providing examples with sensible default values for users.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> trixi_include(@__MODULE__, default_example(), tspan=(0.0, 0.1))\n  [...]\n\n  julia> sol.t[end]\n  0.1\nYou can copy and paste REPL history including julia> prompts into the REPL.\nUse tab completion in the REPL, both for names of functions/types/variables and for function arguments.\njulia> flux_ranocha( # and TAB\nflux_ranocha(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D) in Trixi at ~/.julia/dev/Trixi/src/equations/1d/compressible_euler.jl:416\nflux_ranocha(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D) in Trixi at ~/.julia/dev/Trixi/src/equations/2d/compressible_euler.jl:865\nflux_ranocha(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D) in Trixi at ~/.julia/dev/Trixi/src/equations/3d/compressible_euler.jl:710\nUse methodswith to discover methods associated to a given type etc.\njulia> methodswith(CompressibleEulerEquations2D)\n[1] initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D) in Trixi at ~/.julia/dev/Trixi/src/equations/2d/compressible_euler.jl:38\n[...]\nUse @which (or @edit) for method calls.\njulia> @which trixi_include(default_example())\ntrixi_include(elixir::AbstractString; kwargs...) in Trixi at ~/.julia/dev/Trixi/src/run.jl:72\nUse apropos to search through the documentation and docstrings.\njulia> apropos(\"MHD\")\nTrixi.initial_condition_constant\nTrixi.initial_condition_rotor\nTrixi.IdealGlmMhdEquations2D\nTrixi.initial_condition_jeans_instability\nTrixi.IdealGlmMhdEquations3D\nTrixi.flux_derigs_etal\nTrixi.initial_condition_weak_blast_wave\nTrixi.initial_condition_blast_wave\nTrixi.initial_condition_convergence_test\nTrixi.noncons_interface_flux\nTrixi.initial_condition_orszag_tang\nTrixi.calc_fast_wavespeed_roe\nTrixi.flux_hll","category":"page"},{"location":"development/#Text-editors","page":"Development","title":"Text editors","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"When writing code, the choice of text editor can have a significant impact on productivity and developer satisfaction. While using the default text editor of the operating system has its own benefits (specifically the lack of an explicit installation procure), usually it makes sense to switch to a more programming-friendly tool. In the following, a few of the many options are listed and discussed:","category":"page"},{"location":"development/#VS-Code","page":"Development","title":"VS Code","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Visual Studio Code is a modern open source editor with good support for Julia. While Juno had some better support in the past, the developers of Juno and the Julia VS Code plugin are joining forces and concentrating on VS Code since support of Atom has been suspended. Basically, all comments on Juno below also apply to VS Code.","category":"page"},{"location":"development/#Juno","page":"Development","title":"Juno","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you are new to programming or do not have a preference for a text editor yet, Juno is a good choice for developing Julia code. It is based on Atom, a sophisticated and widely used editor for software developers, and is enhanced with several Julia-specific features. Furthermore and especially helpful for novice programmers, it has a MATLAB-like appearance with easy and interactive access to the current variables, the help system, and a debugger.","category":"page"},{"location":"development/#Vim-or-Emacs","page":"Development","title":"Vim or Emacs","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Vim and Emacs are both very popular editors that work great with Julia. One of their advantages is that they are text editors without a GUI and as such are available for almost any operating system. They also are preinstalled on virtually all Unix-like systems.  However, Vim and Emacs come with their own, steep learning curve if they have never been used before. Therefore, if in doubt, it is probably easier to get started with a classic GUI-based text editor (like Juno). If you decide to use Vim or Emacs, make sure that you install the corresponding Vim plugin julia-vim or Emacs major mode julia-emacs.","category":"page"},{"location":"development/#Releasing-a-new-version-of-Trixi,-Trixi2Vtk,-Trixi2Img","page":"Development","title":"Releasing a new version of Trixi, Trixi2Vtk, Trixi2Img","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Check whether everything is okay, tests pass etc.\nSet the new version number in Project.toml according to the Julian version of semver. Commit and push.\nComment @JuliaRegistrator register on the commit setting the version number.\nJuliaRegistrator will create a PR with the new version in the General registry. Wait for it to be merged.\nIncrement the version number in Project.toml again with suffix -pre. For example, if you have released version v0.2.0, use v0.2.1-pre as new version number.\nSet the correct version number in the badge \"GitHub commits since tagged version\" in README.md. The badge will only show up correctly if TagBot has released a new version. This will be done automatically.\nWhen a new version of Trixi was released, check whether the [compat] entries in test/Project.toml in Trixi2Vtk/Trixi2Img should be updated. When a new version of Trixi2Vtk/Trixi2Img was released, check whether the [compat] entries in docs/Project.toml in Trixi should be updated.\nThese entries will also be checked regularly by CompatHelper (once a day). Hence, if everything was released correctly, you should only need to do these checks manually if new minor versions with changes in the docs of Trixi2Vtk/Trixi2Img were released but no new version of Trixi was released afterwards.","category":"page"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"You can build the documentation of Trixi.jl locally by running","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.instantiate(); include(\"docs/make.jl\")'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"from the Trixi.jl main directory. Then, you can look at the html files generated in docs/build. For PRs triggered from branches inside the Trixi.jl main repository previews of the new documentation are generated at https://trixi-framework.github.io/Trixi.jl/previews/PRXXX, where XXX is the number of the PR. This does not work for PRs from forks for security reasons (since anyone could otherwise push arbitrary stuff to the Trixi website, including malicious code).","category":"page"},{"location":"development/#trixi2vtk-dev","page":"Development","title":"Developing Trixi2Vtk","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Trixi2Vtk has Trixi as dependency and uses Trixi's implementation to, e.g., load mesh files. When developing Trixi2Vtk, one may want to change functions in Trixi to allow them to be reused in Trixi2Vtk. To use a locally modified Trixi clone instead of a Trixi release, one can tell Pkg to use the local source code of Trixi instead of a registered version by running","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"(@v1.6) pkg> develop path/to/Trixi.jl","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/#Adding-a-new-equation:-scalar-conservation-laws","page":"Scalar conservation law","title":"Adding a new equation: scalar conservation laws","text":"","category":"section"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"If you want to use Trixi for your own research, you might be interested in a new physics model that's not already included in Trixi.jl. In this tutorial, we will implement the cubic conservation law","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"partial_t u(tx) + partial_x u(tx)^3 = 0","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"in a periodic domain in one space dimension. In Trixi.jl, such a mathematical model is encoded as a subtype of Trixi.AbstractEquations.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/#Basic-setup","page":"Scalar conservation law","title":"Basic setup","text":"","category":"section"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"Let's start by creating a module (in the REPL, in a file, in a Jupyter notebook, ...). That ensures that we can re-create structs defined therein without having to restart Julia.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"module CubicConservationLaw\n\nusing Trixi\n\nstruct CubicEquation <: Trixi.AbstractEquations{1 #= number of spatial dimensions =#,\n                                                1 #= number of primary variables, i.e. scalar =#}\nend\n\nend # module","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"We create CubicEquation as an empty struct since we do not use any parameters for this equation. Other models could bundle arbitrary parameters, e.g., the ideal gas constant for the compressible Euler equations.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"From here on, the following code snippets should be written inside the module. The complete code can be found at the end. Next, we define the physical flux f(u) = u^3 using the calling structure used in Trixi.jl.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"Trixi.flux(u, orientation, equation::CubicEquation) = u.^3","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"In Trixi.jl, the conserved variables u are usually passed as SVectors of variables at a single physical location. Hence, we must use u.^3 instead of the scalar operation u^3.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"That's already enough to run a simple simulation with a standard DGSEM discretization using the non-dissipative central flux at interfaces. This code is written outside of our new module.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"# Create a simulation setup\nimport .CubicConservationLaw\nusing Trixi\nusing OrdinaryDiffEq\n\nequation = CubicConservationLaw.CubicEquation()\n\ninitial_condition_sine(x, t, equation::CubicConservationLaw.CubicEquation) = SVector(sinpi(x[1]))\n\nmesh = mesh = TreeMesh(-1.0, 1.0, # min/max coordinates\n                       initial_refinement_level=4,\n                       n_cells_max=10^4)\n\nsolver = DGSEM(3 #= polynomial degree =#, flux_central)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create ODE problem with given time span\ntspan = (0.0, 0.09)\node = semidiscretize(semi, tspan)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"We wrap the return value of the initial_condition_sine inside an SVector since that's the approach used in Trixi.jl also for systems of equations. We need to index the spatial coordinate x[1], since it is an SVector with one component. In multiple space dimensions, all spatial coordinates are passed together.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"The ode is an ODEProblem from the SciML/DifferentialEquations ecosystem. Thus, we can solve this ODE numerically using any time integration method, e.g., SSPRK43 from OrdinaryDiffEq.jl. Before, we set up a callback to summarize the simulation setup.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"summary_callback = SummaryCallback()\ncallbacks = CallbackSet(summary_callback)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes the passed callbacks\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\n\n# Print the timer summary\nsummary_callback()","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"That's it, you ran your first simulation using your new equation with Trixi! Now, we can plot the solution at the final time using Plots.jl.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"plot(sol)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"(Image: tutorial_adding_new_equations_plot1)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"You can already see that discontinuities will develop and oscillations start to occur around steep parts of the wave. That's expected from our central discretization. To avoid these issues, we need to use dissipative numerical fluxes (approximate Riemann solvers) at interfaces.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/#Advanced-setup","page":"Scalar conservation law","title":"Advanced setup","text":"","category":"section"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"Thus, we add a Godunov's flux for our cubic equation. That is easy for this equation since the wave speed f'(u) = 3u^2 is always non-negative.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"@inline Trixi.flux_godunov(u_ll, u_rr, orientation, equation::CubicEquation) = flux(u_ll, orientation, equation)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"Let's run the example again but with a dissipative numerical flux at interfaces. remake will recreate the semidiscretization we used before and only change selected parameters, in this case the solver.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"# A new setup with dissipation\nsemi = remake(semi, solver=DGSEM(3, flux_godunov))\node = semidiscretize(semi, tspan)\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nsummary_callback()\nplot!(sol)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"(Image: tutorial_adding_new_equations_plot2)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"You can see that there are fewer oscillations, in particular around steep edges. Now let's increase the final time (and also the spatial resolution).","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"# A larger final time: Nonclassical shocks develop (you can even increase the refinement to 12)\nsemi = remake(semi, mesh=TreeMesh(-1.0, 1.0, initial_refinement_level=8, n_cells_max=10^5))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nplot(sol)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"(Image: tutorial_adding_new_equations_plot3)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"You can observe that nonclassical shocks develop and are stable under grid refinement, e.g. for initial_refinement_level=12. In this case, these nonclassical shocks can be avoided by using an entropy-dissipative semidiscretization. Thus, we need to define an entropy-conservative numerical flux","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"@inline function Trixi.flux_ec(u_ll, u_rr, orientation, equation::CubicEquation)\n  return SVector(0.25 * (u_ll[1]^3 + u_ll[1]^2 * u_rr[1] + u_ll[1] * u_rr[1]^2 + u_rr[1]^3))\nend","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"and use a VolumeIntegralFluxDifferencing instead of the standard VolumeIntegralWeakForm in the DGSEM.","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"# Let's use a provably entropy-dissipative semidiscretization\nsemi = remake(semi, solver=DGSEM(3, flux_godunov, VolumeIntegralFluxDifferencing(flux_ec)))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nplot(sol)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"(Image: tutorial_adding_new_equations_plot4)","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"Possible next steps could be","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"to define Trixi.max_abs_speeds(u, equations::CubicEquation) = 3 * u[1]^2 to use CFL_based time step control via a [StepsizeCallback][@ref]\nto define quantities of interest like Trixi.entropy(u, equations::CubicEquation) = u[1]^2 and integrate them in a simulation using the AnalysisCallback\nto experiment with shock-capturing volume integrals VolumeIntegralShockCapturingHG and adaptive mesh refinement AMRCallback","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/#Summary-of-the-code","page":"Scalar conservation law","title":"Summary of the code","text":"","category":"section"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"To sum up, here is the complete code that we used (without the SummaryCallback since that creates a lot of unnecessary output in the doctests of this tutorial).","category":"page"},{"location":"adding_new_equations/cubic_conservation_law/","page":"Scalar conservation law","title":"Scalar conservation law","text":"# Define new physics\nmodule CubicConservationLaw\n\nusing Trixi\n\nstruct CubicEquation <: Trixi.AbstractEquations{1 #= number of spatial dimensions =#,\n                                                1 #= number of primary variables, i.e. scalar =#}\nend\n\n@inline Trixi.flux(u, orientation, equation::CubicEquation) = u.^3\nTrixi.varnames(_, ::CubicEquation) = (\"scalar\",)\n\n@inline Trixi.flux_godunov(u_ll, u_rr, orientation, equation::CubicEquation) = flux(u_ll, orientation, equation)\n@inline function Trixi.flux_ec(u_ll, u_rr, orientation, equation::CubicEquation)\n  return SVector(0.25 * (u_ll[1]^3 + u_ll[1]^2 * u_rr[1] + u_ll[1] * u_rr[1]^2 + u_rr[1]^3))\nend\n\nend # module\n\n\n# Create a simulation setup\nimport .CubicConservationLaw\nusing Trixi\nusing OrdinaryDiffEq\nusing Plots\n\nequation = CubicConservationLaw.CubicEquation()\n\ninitial_condition_sine(x, t, equation::CubicConservationLaw.CubicEquation) = SVector(sinpi(x[1]))\n\nmesh = mesh = TreeMesh(-1.0, 1.0, # min/max coordinates\n                       initial_refinement_level=4,\n                       n_cells_max=10^4)\n\nsolver = DGSEM(3 #= polynomial degree =#, flux_central)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create ODE problem with given time span\ntspan = (0.0, 0.1)\node = semidiscretize(semi, tspan)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes the passed callbacks\nsol = solve(ode, SSPRK43(), save_everystep=false);\nplot(sol);\n\n\n# A new setup with dissipation\nsemi = remake(semi, solver=DGSEM(3, flux_godunov))\node = semidiscretize(semi, tspan)\nsol = solve(ode, SSPRK43(), save_everystep=false);\nplot!(sol);\n\n\n# A larger final time: Nonclassical shocks develop (you can even increase the refinement to 12)\nsemi = remake(semi, mesh=TreeMesh(-1.0, 1.0, initial_refinement_level=8, n_cells_max=10^5))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(), save_everystep=false);\nplot(sol);\n\n\n# Let's use a provably entropy-dissipative semidiscretization\nsemi = remake(semi, solver=DGSEM(3, flux_godunov, VolumeIntegralFluxDifferencing(flux_ec)))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(), save_everystep=false);\nplot(sol);","category":"page"},{"location":"visualization/#visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"There are two possible approaches to visualize results from Trixi: either directly from the REPL using Plots.jl or with ParaView/VisIt by postprocessing Trixi's output files with Trixi2Vtk.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"note: Note\nThere is also a package Trixi2Img that allows to create images from Trixi's HDF5 output files. However, it is deprecated in favor of plotting directly from the REPL with Plots.jl.","category":"page"},{"location":"visualization/#Plots.jl","page":"Visualization","title":"Plots.jl [experimental]","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"By far the easiest and most convenient plotting approach is to use the powerful Plots.jl package to directly visualize Trixi's results from the REPL. In the following, you will find more information on a number of topics for how to use Plots.jl together with Trixi:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Getting started\nCustomizing plot results via a PlotData2D object\nPlotting a 3D solution as a 2D plot\nCreating a 1D plot\nPlotting a 2D or 3D solutions as a 1D plot\nVisualizing results during a simulation","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"note: Note\nPlotting via Plots.jl is still considered an experimental feature and might change in any future releases.","category":"page"},{"location":"visualization/#getting-started-plots-jl","page":"Visualization","title":"Getting started","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"After running a simulation with Trixi in the REPL, load the Plots package with","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> using Plots","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To visualize the solution, execute","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(sol)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Here we assume that sol holds the return value of the solve(...) method (with type DiffEqBase.ODESolution), which is the default variable name when you use one of the example elixirs. This will generate a grid layout with one subplot for each solution variable, convenient for getting an overview of the current solution:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-sol)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You can save the resulting file as a PNG image file by calling savefig(...) with an output file name that ends in .png, e.g.,","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> savefig(\"solution-overview.png\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In Trixi, two plot types are available: 2D heatmap plots and 1D line plots. If you use plot(sol), Trixi will automatically choose the plot type that fits the dimensions of the sol input: 2D/3D data will be visualized as a heatmap, 1D data as a line plot. For more fine-grained control over what to plot, you can create such an object yourself, which can either be a PlotData2D or a PlotData1D object. For further details on both of these see below:","category":"page"},{"location":"visualization/#Customizing-plot-results-via-a-PlotData2D-object","page":"Visualization","title":"Customizing plot results via a PlotData2D object","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For more fine-grained control over what to plot, first create a PlotData2D object by executing","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(sol)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This takes the results generated by Trixi and stores them in a data format that can be understood by the Plots package, and pd holds all data relevant for plotting sol. You can pass variable names as strings to pd using a dictionary-like syntax, e.g.,","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(pd[\"rho\"])","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This will create a single 2D heatmap plot of the variable rho:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-rho)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The default plot type and style can be overridden by passing any additional arguments that are understood by the Plots package. For example, to change the color scheme and add names to the axes, modify the previous command to","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(pd[\"rho\"], seriescolor = :heat, xguide=\"x\", yguide=\"y\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"to yield","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-modified)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For more details on the various format options for plot, please consult the Plots documentation.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In addition, you can plot the mesh lines on top of the solution variables by calling the getmesh(...) function on the PlotData2D object","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot!(getmesh(pd)) # here we use `plot!` with an `!` to add to the previous plot","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"which modifies the previous plot to","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-modified-mesh)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"By default, PlotData2D will convert the conserved variables to primitive variables, but this can be changed by passing an appropriate conversion function in the solution_variables keyword argument, similar to the behavior of the SaveSolutionCallback:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(sol; solution_variables=cons2cons) # Plot conservative variables","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"There are several other keyword arguments that influence how the solution data is processed for visualization with the Plots package. A detailed explanation can be found in the docstring of the PlotData2D constructor.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Another way to change the appearance of a plot is to convert the solution to a uniformly refined mesh before plotting. This can be helpful, e.g., when trying different settings for a simulation with adaptive mesh refinement, where one would like to ignore the mesh changes when comparing solutions. This is achieved with adapt_to_mesh_level, which uses the mesh adaptation routines to adapt the solution to a uniform grid. For example, the AMR solution from above could be preprocessed with","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(adapt_to_mesh_level(sol, 4)...)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When plotted together with the mesh, this will yield the following visualization:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-uniform-mesh)","category":"page"},{"location":"visualization/#Plotting-a-3D-solution-as-a-2D-plot","page":"Visualization","title":"Plotting a 3D solution as a 2D plot","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"It is possible to plot 2D slices from 3D simulation data with the same commands as above:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(sol) # `sol` is from a 3D simulation","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"By default, plotting sol or creating a PlotData2D object from a 3D simulation will create a 2D slice of the solution in the xy-plane. You can customize this behavior by explicitly creating a PlotData2D object and passing appropriate keyword arguments:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"slice specifies the plane which is being sliced and can be :xy, :xz, or :yz (default: :xy)\npoint specifies a three-dimensional point. The sliced plane is then created such that it lies on the point (default: (0.0, 0.0, 0.0)).","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"All other attributes for PlotData2D objects apply here as well.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For example, to plot the velocity field orthogonal to the yz-plane at different x-axis locations, you can execute","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi_include(joinpath(examples_dir(), \"3d\", \"elixir_euler_taylor_green_vortex.jl\"), tspan=(0, 1))\n[...]\n\njulia> plots = []\nAny[]\n\njulia> for x in range(0, stop=pi/2, length=6)\n         pd = PlotData2D(sol, slice=:yz, point=(x, 0.0, 0.0))\n         push!(plots, plot(pd[\"v1\"], clims=(-1,1), title=\"x = \"*string(round(x, digits=2))))\n       end\n\njulia> plot(plots..., layout=(2, 3), size=(750,350))","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"which results in a 2x3 grid of slices of the yz-plane:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: plot-v1-0.0-to-0.5pi)","category":"page"},{"location":"visualization/#Creating-a-1D-plot","page":"Visualization","title":"Creating a 1D plot","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When plotting a 1D solution with","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(sol) # `sol` is from a 1D simulation","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Trixi automatically creates a PlotData1D object and visualizes it as a line plot: (Image: 1d-plot)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To customize your 1D plot, you can create a PlotData1D object manually as follows:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In a very similar fashion to PlotData2D, you can customize your plot:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"plot(pd) creates the same plot as in plot(sol).\nplot(pd[\"rho\", \"p\"]) only plots specific variables. In this case rho and p.\nplot!(getmesh(pd)) adds mesh lines after creating a plot.\nAny attributes from Plots can be used, e.g., plot(pd, yguide=:temperature).\npd = PlotData1D(adapt_to_mesh_level(sol, 4)...) adapts the mesh before plotting (in this example to a mesh with refinement level 4).","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You can also customize the PlotData1D object itself by passing attributes to the PlotData1D constructor:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"solution_variables specifies the variables to be plotted.\nnvisnodes sets the amount of nodes per element which the solution then is interpolated on.","category":"page"},{"location":"visualization/#Plotting-a-2D-or-3D-solutions-as-a-1D-plot","page":"Visualization","title":"Plotting a 2D or 3D solutions as a 1D plot","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"It is possible to extract a straight, axis-parallel line from a 2D or 3D solution and visualize it as a 1D plot. This is done by creating a PlotData1D object with a 2D/3D solution sol as input:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The plot is then created with:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> plot(pd)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"By default the x-axis is extracted, which can be changed with following attributes:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"slice specifies the axis which is being extracted and can be :x, :y or :z (:z is only for 3D input and default is :x)\npoint specifies a two or three dimensional point. The sliced axis is then created in such a way, that it lies on the point. (default: (0.0, 0.0) or (0.0, 0.0, 0.0))","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"All other attributes for PlotData1D objects apply here as well.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In the following, is an example for a 2D simulation of the linear scalar advection equation. First, we have the regular 2D heatmap plot: (Image: 2d-plot-for-slice)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"From this, we can extract a line plot parallel to the y-axis going through the point (1.0, 0.0) with the following commands:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol, slice=:y, point=(1.0, 0.0))\njulia> plot(pd)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: 1d-plot-for-slice)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This convenient method of slicing is limited to axis-parallel slices, but for 2D/3D solutions it is also possible to create a plot along any curve you want. To do so, you first need to create a list of 2D/3D points that define your curve. Then you can create a PlotData1D with the keyword argument curve set to your list.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Let's give an example of this with the basic advection equation from above by creating a plot along the circle marked in green: (Image: 2d-plot-along-cirlce)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"We can write a function like this, that outputs a list of points on a circle:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"function circle(radius, center, n_points)\n    coordinates = zeros(2, n_points)\n    for i in 1:n_points\n        coordinates[:,i] = radius*[cospi(2*i/n_points), sinpi(2*i/n_points)] .+ center\n    end\n    return coordinates\nend","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Then create and plot a PlotData1D object along a circle with radius one, center at (1,1), and 100 points:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"pd = PlotData1D(sol, curve=circle(1.0, (1.0, 1.0), 100))\nplot(pd)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This gives you the following plot: (Image: 1d-plot-along-circle)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Creating a plot like this has its downsides. For one, it is unclear what to put on the abscissa of the plot. By default, the arc length of the given curve is used. Also, with this way of plotting you lose the ability to use a mesh plot from getmesh.","category":"page"},{"location":"visualization/#Visualizing-results-during-a-simulation","page":"Visualization","title":"Visualizing results during a simulation","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To visualize solutions while a simulation is still running (also known as in-situ visualization), you can use the VisualizationCallback. It is created as a regular callback and accepts upon creation a number of keyword arguments that allow, e.g., to control the visualization interval, to specify the variables to plot, or to customize the plotting style.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"During the simulation, the visualization callback creates and displays visualizations of the current solution in regular intervals. This can be useful to, e.g., monitor the validity of a long-running simulation or for illustrative purposes. An example for how to create a VisualizationCallback can be found in examples/2d/elixir_advection_amr_visualization.jl:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"[...]\n\n# Enable in-situ visualization with a new plot generated every 20 time steps\n# and additional plotting options passed as keyword arguments\nvisualization = VisualizationCallback(interval=20; clims=(0,1))\n\n[...]","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The resulting output of the referenced elixir can be seen in the embedded video below:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"  <!--\n  Video creation details\n  * Set up terminal size and position appropriately\n  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)\n  * Upload to YouTube\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/UZtrqeDY1Fs' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"visualization/#Trixi2Vtk","page":"Visualization","title":"Trixi2Vtk","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Trixi2Vtk converts Trixi's .h5 output files to VTK files, which can be read by ParaView, VisIt, and other visualization tools. It automatically interpolates solution data from the original quadrature node locations to equidistant visualization nodes at a higher resolution, to make up for the loss of accuracy from going from a high-order polynomial representation to a piecewise constant representation in VTK.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In the Julia REPL, first load the package Trixi2Vtk","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> using Trixi2Vtk","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To process an HDF5 file generated by Trixi.jl, execute","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(joinpath(\"out\", \"solution_000000.h5\"), output_directory=\"out\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This will create two unstructured VTK files in the out subdirectory that can be opened with ParaView or VisIt: solution_000000.vtu contains the discontinuous Galerkin solution data while solution_000000_celldata.vtu holds any cell-based values such as the current AMR indicator or the cell refinement level.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: \"solution_000000_scalar_mesh\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This allows you to generate VTK files for solution, restart and mesh files. By default, Trixi2Vtk generates .vtu (unstructured VTK) files for both cell/element data (e.g., cell ids, element ids) and node data (e.g., solution variables). This format visualizes each cell with the same number of nodes, independent of its size.  Alternatively, you can provide format=:vti as a keyword argument to trixi2vtk, which causes Trixi2Vtk to generate .vti (image data VTK) files for the solution files, while still using .vtu files for cell-/element-based data. In .vti files, a uniform resolution is used throughout the entire domain, resulting in different number of visualization nodes for each element.  This can be advantageous to create publication-quality images, but increases the file size.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"If you want to convert multiple solution/restart files at once, you can just supply multiple input files as the positional arguments to trixi2vtk, e.g.,","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/solution_000000.h5\", \"out/solution_000040.h5\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You may also use file globbing to select a range of files based on filename patterns, e.g.,","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/solution_*.h5\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"to convert all solution files in the out/ directory or","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/restart_00[0-9]000.h5\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"to convert every one-thousandth restart file (out/restart_000000.h5, out/restart_001000.h5 etc.).","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"When multiple solution/restart files are provided, Trixi2Vtk will also generate a .pvd file, which allows ParaView to read all .vtu/.vti files at once and which uses the time attribute in solution/restart files to inform ParaView about the solution time. A comprehensive list of all possible arguments for trixi2vtk can be found in the Trixi2Vtk.jl API.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Further information regarding the development of Trixi2Vtk can be found in the development section.","category":"page"},{"location":"visualization/#Trixi2Img","page":"Visualization","title":"Trixi2Img","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"note: Trixi2Img is deprecated\nSince it is possible to visualize results from Trixi directly from the REPL using the Plots package, Trixi2Img has been deprecated. There are still some features missing when using Plots, such as postprocessing HDF5 files. Once these have been added to the Plots-based solution, Trixi2Img will be retired.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Trixi2Img can be used to directly convert Trixi's output files to image files, without having to use a third-pary visualization tool such as ParaView or VisIt. The downside of this approach is that it generally takes longer to visualize the data (especially for large files) and that it does not allow as much customization of the generated output files.  Currently, PNG and PDF are supported as output formats.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In the Julia REPL, first load the package Trixi2Img","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> using Trixi2Img","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To process an HDF5 file generated by Trixi.jl, execute","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2img(joinpath(\"out\", \"solution_000040.h5\"), output_directory=\"out\", grid_lines=true)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This will create a file solution_000040_scalar.png in the out/ subdirectory that can be opened with any image viewer:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: \"solution_000040_scalar_resized\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To visualize 3D data generated by Trixi.jl, a 2D slice must be extracted. A slice can only lie in a plane orthogonal to one of the coordinate axes. The slice plane is defined by the axis to which it is orthogonal and an axis intercept.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"For example, to create a 2D slice in the xy-plane at the axis intercept z = 0.5 from 3D data, execute","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2img(joinpath(\"out\", \"solution_000000.h5\"), output_directory=\"out\", grid_lines=true, slice_axis=:z, slice_axis_intercept=0.5)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Similar to Trixi2Vtk, you can also provide multiple files to trixi2img or use file globbing, e.g.,","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"julia> trixi2img(\"out/solution_*.h5\")","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"to convert all solution files. The default is to generate a PNG file for each variable found in the respective file. Use format=:pdf as a keyword argument to create PDF files. A comprehensive list of all possible arguments for trixi2img can be found in the Trixi2Img.jl API.","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Trixi.jl is designed to balance performance and readability. Since Julia provides a lot of zero-cost abstractions, it is often possible to optimize both goals simultaneously.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The usual development workflow in Julia is","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Make it work.\nMake it fast.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"To achieve the second step, you should be familiar with (at least) the section on performance tips in the Julia manual. Here, we just list some important aspects you should consider when developing Trixi.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Consider using @views/view(...) when using array slices, except on the left-side of an assignment (further details).\nFunctions are essentially for free, since they are usually automatically inlined where it makes sense (using @inline can be used as an additional hint to the compiler) (further details).\nFunction barriers can improve performance due to type stability (further details).\nLook for type instabilities using @code_warntype. Consider using @descend from Cthulhu.jl to investigate deeper call chains.","category":"page"},{"location":"performance/#Manual-benchmarking","page":"Performance","title":"Manual benchmarking","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"If you modify some internal parts of Trixi, you should check the impact on performance. Hence, you should at least investigate the performance roughly by comparing the reported timings of several elixirs. Deeper investigations and micro-benchmarks should usually use BenchmarkTools.jl. For example, the following steps were used to benchmark the changes introduced in https://github.com/trixi-framework/Trixi.jl/pull/256.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"git checkout e7ebf3846b3fd62ee1d0042e130afb50d7fe8e48 (new version)\nStart julia --threads=1 --check-bounds=no.\nExecute the following code in the REPL to benchmark the rhs! call at the final state.\njulia> using BenchmarkTools, Revise; using Trixi\n\njulia> trixi_include(\"examples/2d/elixir_euler_sedov_blast_wave.jl\")\n\njulia> du_test = copy(sol.u[end]); u_test = copy(sol.u[end]);\n\njulia> @benchmark Trixi.rhs!(\n          $(du_test),\n          $(u_test),\n          $(semi),\n          $(sol.t[end]))\nBenchmarkTools.Trial:\n memory estimate:  10.48 KiB\n allocs estimate:  67\n --------------\n minimum time:     4.510 ms (0.00% GC)\n median time:      4.646 ms (0.00% GC)\n mean time:        4.699 ms (0.00% GC)\n maximum time:     7.183 ms (0.00% GC)\n --------------\n samples:          1065\n evals/sample:     1\n\nshell> git checkout 222241ff54f8a4ca9876cc1fc25ae262416a4ea0\n\njulia> trixi_include(\"examples/2d/elixir_euler_sedov_blast_wave.jl\")\n\njulia> @benchmark Trixi.rhs!(\n          $(du_test),\n          $(u_test),\n          $(semi),\n          $(sol.t[end]))\nBenchmarkTools.Trial:\n memory estimate:  10.36 KiB\n allocs estimate:  67\n --------------\n minimum time:     4.500 ms (0.00% GC)\n median time:      4.635 ms (0.00% GC)\n mean time:        4.676 ms (0.00% GC)\n maximum time:     5.880 ms (0.00% GC)\n --------------\n samples:          1070\n evals/sample:     1\nRun the @benchmark ... commands multiple times to see whether there are any significant fluctuations.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Follow these steps for both commits you want to compare. The relevant benchmark results you should typically be looking at are the median and mean values of the runtime and the memory/allocs estimate. In this example, the differences of the runtimes are of the order of the fluctuations one gets when running the benchmarks multiple times. Since the memory/allocs are (roughly) the same, there doesn't seem to be a significant performance regression here.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"You can also make it more detailed by benchmarking only, e.g., the calculation of the volume terms, but whether that's necessary depends on the modifications you made and their (potential) impact.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Some more detailed description of manual profiling and benchmarking as well as resulting performance improvements of Trixi are given in the following blog posts.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Improving performance of AMR with p4est, cf. #638\nImproving performance of EC methods, cf. #643","category":"page"},{"location":"performance/#Automated-benchmarking","page":"Performance","title":"Automated benchmarking","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We use PkgBenchmark.jl to provide a standard set of benchmarks for Trixi. The relevant benchmark script is benchmark/benchmarks.jl. You can run a standard set of benchmarks via","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"julia> using PkgBenchmark, Trixi\n\njulia> results = benchmarkpkg(Trixi, BenchmarkConfig(juliacmd=`$(Base.julia_cmd()) --check-bounds=no --threads=1`))\n\njulia> export_markdown(joinpath(pathof(Trixi) |> dirname |> dirname, \"benchmark\", \"single_benchmark.md\"), results)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"This will save a markdown file with a summary of the benchmark results similar to this example. Note that this will take quite some time. Additional options are described in the docs of PkgBenchmark.jl. A particularly useful option is to specify a BenchmarkConfig including Julia command line options affecting the performance such as disabling bounds-checking and setting the number of threads.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"A useful feature when developing Trixi is to compare the performance of Trixi's current state vs. the main branch. This can be achieved by executing","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"julia> using PkgBenchmark, Trixi\n\njulia> results = judge(Trixi,\n             BenchmarkConfig(juliacmd=`$(Base.julia_cmd()) --check-bounds=no --threads=1`), # target\n             BenchmarkConfig(juliacmd=`$(Base.julia_cmd()) --check-bounds=no --threads=1`, id=\"main\") # baseline\n       )\n\njulia> export_markdown(joinpath(pathof(Trixi) |> dirname |> dirname, \"benchmark\", \"results.md\"), results)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"By default, the target is the current state of the repository. Remember that you need to be in a clean state (commit or stash your changes) to run this successfully. You can also run this comparison and an additional one using two threads via","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"julia> include(\"benchmark/run_benchmarks.jl\")","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Then, markdown files including the results are saved in benchmark/. This example result was obtained using a GitHub action for the PR #535. Note that GitHub actions run on in the cloud in a virtual machine. Hence, we do not really have control over it and performance results must be taken with a grain of salt. Nevertheless, significant runtime differences and differences of memory allocations should be robust indicators of performance changes.","category":"page"},{"location":"performance/#Runtime-performance-vs.-latency-aka-using-@nospecialize-selectively","page":"Performance","title":"Runtime performance vs. latency aka using @nospecialize selectively","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Usually, Julia will compile specialized versions of each method, using as much information from the types of function arguments as possible (based on some heuristics). The compiler will generate code that is as efficient as comparable code written in a low-level language such as C or Fortran. However, there are cases where the runtime performance does not really matter but the time needed to compile specializations becomes significant. This is related to latency or the time-to-first-plot problem, well-known in the Julia community. In such a case, it can be useful to remove some burden from the compiler by avoiding specialization on every possible argument types using the macro @nospecialize. A prime example of such a case is pretty printing of structs in the Julia REPL, see the associated PR for further discussions.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"As a rule of thumb:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Do not use @nospecialize in performance-critical parts, in particular not for methods involved in computing Trixi.rhs!.\nConsider using @nospecialize for methods like custom implementations of Base.show.","category":"page"},{"location":"github-git/#GitHub-and-Git","page":"GitHub & Git","title":"GitHub & Git","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"This page contains information on how to use GitHub and Git when developing Trixi.","category":"page"},{"location":"github-git/#Development-workflow","page":"GitHub & Git","title":"Development workflow","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"For adding modifications to Trixi, we generally follow these steps:","category":"page"},{"location":"github-git/#Create-an-issue-(optional)","page":"GitHub & Git","title":"Create an issue (optional)","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"In many cases it makes sense to start by creating an issue on GitHub. For example, if the implementation approach for a new feature is not yet clear or if there should be a discussion about the desired outcome, it is good practice to first get a consensus on what is the expected result of this modification. A GitHub issue is the place to lead this discussion, as it preserves it in the project and - together with the actual code changes - allows in the future to revisit the reasons for a particular choice of implementation or feature.","category":"page"},{"location":"github-git/#Create-a-branch-and-*immediately*-create-a-pull-request","page":"GitHub & Git","title":"Create a branch and immediately create a pull request","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"All feature development, bug fixes etc. should be developed in a branch and not directly on main. If you do not have write access to the main repository on GitHub, first create a fork of the Trixi.jl repository and clone the fork to your machine. Then, create a branch locally by executing git checkout -b yourbranch, push it to the repository, and create a pull request (PR).","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"If you have already cloned Trixi.jl from the main repo to your local machine, you can also work in that clone. You just need to add your fork as additional remote repository and push your new branch there.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"git remote add myfork git@github.com:YOUR_NAME/Trixi.jl.git\n# get latest main from the main repo\ngit checkout main\ngit pull\n# create a new branch for a cool new feature, bug fix, ...\ngit checkout -b YOUR_BRANCH_NAME\n# do some work and push it to your fork\ngit push -u myfork\n# go to https://github.com/trixi-framework/Trixi.jl/pull\n# and create a PR from your new branch","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"info: Why using pull requests?\nImmediately creating a PR for your branch has the benefit that all code discussions can now be held directly next to the corresponding code. Also, the PR allows to easily compare your branch to the upstream branch (usually main) to see what you have changed. Moreover, tests will run automatically.","category":"page"},{"location":"github-git/#Make-changes","page":"GitHub & Git","title":"Make changes","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"With a branch and PR in place, you can now write your code and commit it to your branch. If you request feedback from someone else, make sure to push your branch to the repository such that the others can easily review your changes or dive in and change something themselves.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"warning: Avoid committing unwanted files\nWhen you use git add . or similar catch-all versions, make sure you do not accidentally commit unwanted files (e.g., Trixi output files, images or videos etc.). If it happens anyways, you can undo the last commit (also multiple times) by running git reset HEAD~ (see also Undo last commit). However, this strategy only works if you have not yet pushed your changes. If you did push your changes, please talk to one of the core developers on how to proceed.","category":"page"},{"location":"github-git/#Keep-your-branch-in-sync-with-main","page":"GitHub & Git","title":"Keep your branch in sync with main","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"For larger features with longer-living branches, it may make sense to synchronize your branch with the current main, e.g., if there was a bug fix in main that is relevant for you. In this case, perform the following steps to merge the current main to your branch:","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Commit all your local changes to your branch and push it. This allows you to delete your clone in case you make a mistake and need to abort the merge.\nExecute git fetch to get the latest changes from the repository.\nMake sure you are in the correct branch by checking the output of git status or by running git checkout yourbranch.\nMerge main using git merge main. If there were no conflicts, hooray!, you are done. Otherwise you need to resolve your merge conflicts and commit the changes afterwards. A good guide for resolving merge conflicts can be found here.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"In general, always use git merge and not git rebase to get the latest changes from main. It is less error-prone and does not create problems on branches that are worked on collaboratively.","category":"page"},{"location":"github-git/#Prepare-for-review","page":"GitHub & Git","title":"Prepare for review","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"If you feel like your branch is ready to be merged to main, prepare it for review. That is, you should","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"merge the current main to your branch\nrun tests if available, but at least ensure that you did not accidentally change the results for one of the existing example elixirs\nproperly comment your code\ndelete old/unused code, especially commented lines (unless they contain helpful code, in which case you should add a comment on why you keep this around)\nremove debug statements\nadd a elixir_xxx.jl that uses your feature (only relevant for new features)\nmake sure your code formatting adheres to the Style guide\ndescribe changes in NEWS.md if appropriate","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"After you are confident that your branch is cleaned up properly, commit all changes and push them to the repository.","category":"page"},{"location":"github-git/#Get-reviewed","page":"GitHub & Git","title":"Get reviewed","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Ask one of the core developers to review your code. Sometimes this will be done directly, either face-to-face or via a video call. Other times a review will be conducted asynchronously, with the reviewer leaving comments and annotations. In some cases it will be necessary to do multiple rounds of reviews, especially if there are larger changes to be added. Just commit and push your changes to your branch, and the corresponding pull request will be updated automatically.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Please note that a review has nothing to do with the lack of experience of the person developing changes: We try to review all code before it gets added to main, even from the most experienced developers. This is good practice and helps to keep the error rate low while ensuring the the code is developed in a consistent fashion. Furthermore, do not take criticism of your code personally - we just try to keep Trixi as accessible and easy to use for everyone.","category":"page"},{"location":"github-git/#Merge-branch","page":"GitHub & Git","title":"Merge branch","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Once your branch is reviewed and declared ready for merging by the reviewer, make sure that all the latest changes have been pushed. Then, one of the developers will merge your PR. If you are one of the developers, you can also go to the pull request page on GitHub and and click on Merge pull request. Voilá, you are done! Your branch will have been merged to main and the source branch will have been deleted in the GitHub repository (if you are not working in your own fork).","category":"page"},{"location":"github-git/#Update-your-working-copy","page":"GitHub & Git","title":"Update your working copy","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Once you have merged your branch by accepting the PR on GitHub, you should clean up your local working copy of the repository by performing the following steps:","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Update your clone by running git fetch.\nCheck out main using git checkout main.\nDelete merged branch locally with git branch -d yourbranch.\nRemove local references to deleted remote branch by executing git remote prune origin.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"You can now proceed with your next changes by starting again at the top.","category":"page"},{"location":"github-git/#Using-Git","page":"GitHub & Git","title":"Using Git","text":"","category":"section"},{"location":"github-git/#Resources-for-learning-Git","page":"GitHub & Git","title":"Resources for learning Git","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Here are a few resources for learning do use Git that at least one of us found helpful in the past (roughly ordered from novice to advanced to expert):","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Git Handbook by GitHub\nLearn Git Branching","category":"page"},{"location":"github-git/#Tips-and-tricks","page":"GitHub & Git","title":"Tips and tricks","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"This is an unordered collection of different tips and tricks that can be helpful while working with Git. As usual, your mileage might vary.","category":"page"},{"location":"github-git/#Undo-last-commit","page":"GitHub & Git","title":"Undo last commit","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"If you made a mistake in your last commit, e.g., by committing an unwanted file, you can undo the latest commit by running","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"git reset HEAD~","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"This only works if you have not yet pushed your branch to the GitHub repository. In this case, please talk to one of the core developers on how to proceed. Especially when you accidentally committed a large file (image, or video), please let us know as fast as possible, since the effort to fix the repository grows considerably over time.","category":"page"},{"location":"github-git/#Remove-large-file-from-repository","page":"GitHub & Git","title":"Remove large file from repository","text":"","category":"section"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"If a large file was accidentally committed and pushed to the Trixi repository, please talk to one of the core developers as soon as possible so that they can fix it.","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"danger: Large files\nYou should never try to fix this yourself, as it potentially disrupts/destroys the work of others!","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Based on the instructions found here and here, the following steps need to be taken (as documented for GitLab in issue #33):","category":"page"},{"location":"github-git/","page":"GitHub & Git","title":"GitHub & Git","text":"Tell everyone to commit and push their changes to the repository.\nFix the branch in which the file was committed by removing it and committing the removal. This is especially important on main.\nPerform the following steps to clean up the Git repository:\ncd /tmp\n\n# Download bfg-1.13.0.jar from https://rtyley.github.io/bfg-repo-cleaner/\n\n# Get fresh clone of repo (so you can throw it away in case there is a problem)\ngit clone --mirror git@github.com:trixi-framework/Trixi.jl.git\n\n# Clean up repo of all files larger than 10M\njava -jar bfg-1.13.0.jar --strip-blobs-bigger-than 10M Trixi.jl.git\n\n# Enter repo\ncd Trixi.jl.git\n\n# Clean up reflog and force aggressive garbage collection\ngit reflog expire --expire=now --all && git gc --prune=now --aggressive\n\n# Push changes\ngit push\n\n# Delete clone\nrm -rf Trixi.jl.git\nTell everyone to clean up their local working copies by performing the following steps (also do this yourself):\n# Enter repo\ncd Trixi.jl\n\n# Get current changes\ngit fetch\n\n# Check out the fixed branch\ngit checkout branchname\n\n# IMPORTANT: Do a rebase instead of a pull!\ngit rebase\n\n# Clean reflog and force garbage collection\ngit reflog expire --expire=now --all && git gc --prune=now --aggressive\nIMPORTANT: You need to do a git rebase instead of a git pull when updating the fixed branch.","category":"page"},{"location":"conventions/#conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions/#Spatial-dimensions-and-directions","page":"Conventions","title":"Spatial dimensions and directions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"We use the following numbering schemes on Cartesian or curved structured meshes.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The orientations are numbered as 1 => x, 2 => y, 3 => z. For example, numerical fluxes such as flux_central(u_ll, u_rr, orientation, equations::AbstractEquations) use the orientation in this way.\nThe directions are numbered as 1 => -x, 2 => +x, 3 => -y, 4 => +y, 5 => -z, 6 => +z. For example, the boundary_conditions are ordered in this way when a Tuple of boundary conditions per direction is passed to the constructor of a SemidiscretizationHyperbolic.\nFor structured and unstructured curved meshes the concept of direction is generalized via the variable normal_direction. This variable points in the normal direction at a given, curved surface. For the computation of boundary fluxes the normal_direction is normalized to be a normal_vector used, for example, in FluxRotated.","category":"page"},{"location":"conventions/#Cells-vs.-elements-vs.-nodes","page":"Conventions","title":"Cells vs. elements vs. nodes","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To uniquely distinguish between different components of the discretization, we use the following naming conventions:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The computational domain is discretized by a mesh, which is made up of individual cells. In general, neither the mesh nor the cells should be aware of any solver-specific knowledge, i.e., they should not store anything that goes beyond the geometrical information and the connectivity.\nThe numerical solvers do not directly store their information inside the mesh, but use own data structures. Specifically, for each cell on which a solver wants to operate, the solver creates an element to store solver-specific data.\nFor discretization schemes such as the discontinuous Galerkin or the finite element method, inside each element multiple nodes may be defined, which hold nodal information. The nodes are again a solver-specific component, just like the elements.\nWe often identify elements, nodes, etc. with their (local or global) integer index. Convenience iterators such as eachelement, eachnode use these indices.","category":"page"},{"location":"conventions/#Variable-names","page":"Conventions","title":"Variable names","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Use descriptive names (using snake_case for variables/functions and CamelCase for types)\nUse a suffix _ as in name_ for local variables that would otherwise hide existing symbols.\nUse a prefix _ as in _name to indicate internal methods/data that are \"fragile\" in the sense that there's no guarantee that they might get changed without notice. These are also not documented with a docstring (but maybe with comments using #).","category":"page"},{"location":"conventions/#Array-types-and-wrapping","page":"Conventions","title":"Array types and wrapping","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"To allow adaptive mesh refinement efficiently when using time integrators from OrdinaryDiffEq, Trixi allows to represent numerical solutions in two different ways. Some discussion can be found online and in form of comments describing Trixi.wrap_array and Trixi.wrap_array_native in the source code of Trixi. The flexibility introduced by this possible wrapping enables additional performance optimizations. However, it comes at the cost of some additional abstractions (and needs to be used with caution, as described in the source code of Trixi). Thus, we use the following conventions to distinguish between arrays visible to the time integrator and wrapped arrays mainly used internally.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Arrays visible to the time integrator have a suffix _ode, e.g., du_ode, u_ode.\nWrapped arrays do not have a suffix, e.g., du, u.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Methods either accept arrays visible to the time integrator or wrapped arrays based on the following rules.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"When some solution is passed together with a semidiscretization semi, the solution must be a u_ode that needs to be  wrapped via wrap_array(u_ode, semi) (or wrap_array_native(u_ode, semi)) for further processing.\nWhen some solution is passed together with the mesh, equations, solver, cache, ..., it is already wrapped via wrap_array (or wrap_array_native).\nExceptions of this rule are possible, e.g. for AMR, but must be documented in the code.\nwrap_array should be used as default option. wrap_array_native should only be used when necessary, e.g., to avoid additional overhead when interfacing with external C libraries such as HDF5, MPI, or visualization.","category":"page"},{"location":"reference-trixi2img/#Trixi2Img.jl-API","page":"Trixi2Img.jl","title":"Trixi2Img.jl API","text":"","category":"section"},{"location":"reference-trixi2img/","page":"Trixi2Img.jl","title":"Trixi2Img.jl","text":"note: Trixi2Img is deprecated\nSince it is possible to visualize results from Trixi directly from the REPL using the Plots package, Trixi2Img has been deprecated. There are still some features missing when using Plots, such as postprocessing HDF5 files. Once these have been added to the Plots-based solution, Trixi2Img will be retired.","category":"page"},{"location":"reference-trixi2img/","page":"Trixi2Img.jl","title":"Trixi2Img.jl","text":"CurrentModule = Trixi2Img","category":"page"},{"location":"reference-trixi2img/","page":"Trixi2Img.jl","title":"Trixi2Img.jl","text":"Modules = [Trixi2Img]","category":"page"},{"location":"reference-trixi2img/#Trixi2Img.ndim","page":"Trixi2Img.jl","title":"Trixi2Img.ndim","text":"ndims\n\nNumber of spatial dimensions (= 2).\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi2img/#Trixi2Img.trixi2img-Tuple{Vararg{AbstractString, N} where N}","page":"Trixi2Img.jl","title":"Trixi2Img.trixi2img","text":"trixi2img(filename::AbstractString...;\n        format=:png, variables=[], verbose=false, grid_lines=false,\n        output_directory=\".\", nvisnodes=nothing, max_supported_level=11)\n\nConvert two-dimensional Trixi-generated output files to image files (PNG or PDF).\n\nArguments\n\nfilename: One or more 2D solution/restart files generated by Trixi to create an image from.             Filenames support file globbing, e.g., \"solution*\" to match all files starting             with solution.\nformat: Output format for solution/restart files. Can be 'vtu' or 'vti'.\nvariables: Names of the variables to create images for. If empty, each variable found in the              input file(s) will be plotted.\nverbose: Set to true to enable verbose output.\ngrid_lines: Plot outline of elements. (warning: this is an expensive operation!)\noutput_directory: Output directory where generated files are stored.\nnvisnodes: Number of visualization nodes per element (default: twice the number of DG nodes).              A value of 0 (zero) uses the number of nodes in the DG elements.\nmax_supported_level: Maximum cell refinement level supported for plotting.\nslice_axis: Axis orthogonal to the slice plane. Will be ignored in 2D. May be :x, :y or :z.\nslice_axis_intercept: Point on the slice axis where it intersects with the slice plane.\n\nExamples\n\njulia> trixi2img(\"out/solution_000*.h5\")\n[...]\n\njulia> trixi2img(\"out/solution_000*.h5\", slice_axis=:z, slice_axis_intercept=0.5) # Slice plane will be z=0.5\n[...]\n\n\n\n\n\n","category":"method"},{"location":"meshes/p4est_mesh/#P4est-based-mesh","page":"P4est-based mesh","title":"P4est-based mesh","text":"","category":"section"},{"location":"meshes/p4est_mesh/","page":"P4est-based mesh","title":"P4est-based mesh","text":"The P4estMesh is an unstructured, curvilinear, nonconforming mesh type for quadrilateral (2D) and hexahedral (3D) cells. It supports quadtree/octree-based adaptive mesh refinement (AMR) via the C library p4est. See AMRCallback for further information.","category":"page"},{"location":"meshes/p4est_mesh/","page":"P4est-based mesh","title":"P4est-based mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"During the development of Trixi, we rely on continuous testing to ensure that modifications or new features do not break existing functionality or add other errors. In the main Trixi repository (and the repositories for the visualization tools Trixi2Img and Trixi2Vtk), this is facilitated by GitHub Actions, which allows to run tests automatically upon certain events. When, how, and what is tested by GitHub Actions is controlled by the workflow file .github/workflows/ci.yml. In Trixi and its related repositories, tests are triggered by","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"each git push to main and\neach git push to any pull request.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Besides checking functionality, we also analyse the Test coverage to ensure that we do not miss important parts during testing.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Test and coverage requirements\nBefore merging a pull request (PR) to main, we require thatthe code passes all functional tests\ncode coverage does not decrease.","category":"page"},{"location":"testing/#Testing-setup","page":"Testing","title":"Testing setup","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"The entry point for all testing is the file test/runtests.jl, which is run by the automated tests and which can be triggered manually by executing","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"julia> using Pkg; Pkg.test(\"Trixi\")","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"in the REPL. Since there already exist many tests, we have split them up into multiple files in the test directory to allow for faster testing of individual parts of the code. Thus in addition to performing all tests, you can also just include one of the files named test_xxx.jl to run only a specific subset, e.g.,","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"julia> include(joinpath(\"test\", \"test_examples_2d.jl\")) # Run all 2D tests\n\njulia> include(joinpath(\"test\", \"test_examples_2d_euler.jl\")) # Run only 2D tests for the Euler equations","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"For the automated tests with GitHub Actions, we run multiple jobs in parallel to reduce the waiting time until all tests are finished. You can see the different components that are run as jobs by looking at the TRIXI_TEST variable in test/runtests.jl.","category":"page"},{"location":"testing/#Adding-new-tests","page":"Testing","title":"Adding new tests","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"We use Julia's built-in unit testing capabilities to configure tests. In general, newly added code must be covered by at least one test, and all new elixirs added to the examples/ directory must be used at least once during testing. New tests should be added to the corresponding test/test_xxx.jl file, e.g., a test involving the 3D linear advection equation would go into test/test_examples_3d_advection.jl. Please study one of the existing tests and stay consistent to the current style when creating new tests.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Since we want to test as much as possible, we have a lot of tests and frequently create new ones. Naturally, this increases the time to wait for all tests to pass with each novel feature added to Trixi. Therefore, new tests should be as short as reasonably possible, i.e., without being too insensitive to pick up changes or errors in the code.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Test duration\nAs a general rule, tests should last no more than 10 seconds when run with a single thread and after compilation (i.e., excluding the first run).","category":"page"},{"location":"testing/#Test-coverage","page":"Testing","title":"Test coverage","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"In addition to ensuring that the code produces the expected results, the automated tests also record the code coverage. The resulting coverage reports, i.e., which lines of code were executed by at least one test and are thus considered \"covered\" by testing, are automatically uploaded to Coveralls for easy analysis. Typically, you see a number of Coveralls results at the bottom of each pull request: One for each parallel job (see Testing setup), which can usually be ignored since they only cover parts of the code by definition, and a cumulative coverage result named coverage/coveralls. The \"Details\" link takes you to a detailed report on which lines of code are covered by tests, which ones are missed, and especially which new lines the pull requests adds to Trixi's code base that are not yet covered by testing.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Coverage requirements\nIn general, we require pull requests to not decrease the overall test coverage percentage in main, with a hard lower bound of 97%.","category":"page"},{"location":"troubleshooting/#Troubleshooting-and-FAQ","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"","category":"section"},{"location":"troubleshooting/#old-release","page":"Troubleshooting and FAQ","title":"Installing Trixi as a package only provides an older release","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"Trixi requires fairly recent versions of several of its dependencies, which sometimes causes issues when other installed packages have conflicting version requirements.  In this case, Julia's package manager Pkg will try to handle this gracefully by going back in history until it finds a Trixi release whose version requirements can be met, resulting in an older - and usually outdated - version of Trixi being installed.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"The following example illustrates this issue:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"The current Trixi release v0.3.6 requires package Foo with a minimum version of v0.2.\nAn older Trixi release v0.2.1 requires package Foo only with a minimum version of v0.1.\nA user has already installed package Bar, which itself requires Foo with a maximum version of v0.1.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"In this case, installing Trixi via Pkg will result in version v0.2.1 to be installed instead of the current release v0.3.6. That is, a specific release of Trixi may not be installable if it has a dependency with a higher minimum version that at the same time is restricted to a lower maximum version by another installed package.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"You can check whether an outdated version of Trixi is installed by executing","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"julia> import Pkg; Pkg.update(\"Trixi\"); Pkg.status(\"Trixi\")","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"in the REPL and comparing the reported Trixi version with the version of the latest release. If the versions differ, you can confirm that it is due to a version conflict by forcing Pkg to install the latest Trixi release, where version is the current release:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"julia> Pkg.add(name=\"Trixi\", version=\"0.3.6\")","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"In case of a conflict, the command above will produce an error that informs you about the offending packages, similar to the following:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nERROR: Unsatisfiable requirements detected for package DataStructures [864edb3b]:\n DataStructures [864edb3b] log:\n ├─possible versions are: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20, 0.18.0-0.18.8] or uninstalled\n ├─restricted by compatibility requirements with DiffEqCallbacks [459566f4] to versions: 0.18.0-0.18.8\n │ └─DiffEqCallbacks [459566f4] log:\n │   ├─possible versions are: [2.0.0, 2.1.0, 2.2.0, 2.3.0, 2.4.0, 2.5.0-2.5.2, 2.6.0, 2.7.0, 2.8.0, 2.9.0, 2.10.0, 2.11.0, 2.12.0-2.12.1, 2.13.0-2.13.5, 2.14.0-2.14.1, 2.15.0] or uninstalled\n │   ├─restricted by compatibility requirements with Trixi [a7f1ee26] to versions: [2.14.0-2.14.1, 2.15.0]\n │   │ └─Trixi [a7f1ee26] log:\n │   │   ├─possible versions are: [0.1.0-0.1.2, 0.2.0-0.2.6, 0.3.0-0.3.6] or uninstalled\n │   │   └─restricted to versions 0.3.6 by an explicit requirement, leaving only versions 0.3.6\n │   └─restricted by compatibility requirements with StaticArrays [90137ffa] to versions: 2.15.0 or uninstalled, leaving only versions: 2.15.0\n │     └─StaticArrays [90137ffa] log:\n │       ├─possible versions are: [0.8.0-0.8.3, 0.9.0-0.9.2, 0.10.0, 0.10.2-0.10.3, 0.11.0-0.11.1, 0.12.0-0.12.5, 1.0.0-1.0.1] or uninstalled\n │       └─restricted by compatibility requirements with Trixi [a7f1ee26] to versions: 1.0.0-1.0.1\n │         └─Trixi [a7f1ee26] log: see above\n └─restricted by compatibility requirements with JLD2 [033835bb] to versions: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20] — no versions left\n   └─JLD2 [033835bb] log:\n     ├─possible versions are: [0.1.0-0.1.14, 0.2.0-0.2.4, 0.3.0-0.3.1] or uninstalled\n     └─restricted by compatibility requirements with BinaryBuilder [12aac903] to versions: 0.1.0-0.1.14\n       └─BinaryBuilder [12aac903] log:\n         ├─possible versions are: [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6] or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6]","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"From the error message, we can see that ultimately BinaryBuilder is the problem here: It restricts the package DataStructures to version v0.17 (via its dependency JLD2), while Trixi requires at least v0.18 (via its dependency DiffEqCallbacks). Following the official Pkg documentation, there are a number of things you can try to fix such errors:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"Try updating all packages with julia -e 'using Pkg; Pkg.update()'. A newer version of the problematic package may exist that has updated version requirements.\nRemove the offending package. Running\njulia> import Pkg; Pkg.rm(\"BinaryBuilder\"); Pkg.update(); Pkg.status()\nin the REPL will remove BinaryBuilder and (hopefully) update Trixi to the latest version.\nReport the versioning issue to us and/or the development repository of the conflicting package.  Maybe it is possible to lift the version restrictions such that both packages can live side by side.\nInstead of installing Trixi and conflicting packages in the same (default) environment, consider creating new environments/projects and install only packages required for the specific tasks, as explained in the official Pkg documentation. For example, if you use Trixi for a research project (Bachelor/Master thesis or a paper), you should create a new Julia project/environment for that research and add Trixi as a dependency. If you track all your code and the Project.toml, Manifest.toml files (generated by Pkg) in a version control system such as git, you can make your research easily reproducible (if you also record the version of Julia you are using and leave some comments for others who do not know what you are trying to do, including your future self 😉).","category":"page"},{"location":"troubleshooting/#font-issues","page":"Troubleshooting and FAQ","title":"There are many questions marks and weird symbols in the output of Trixi","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"This probably means that the default font used by your operating system does not support enough Unicode symbols. Try installing a modern font with decent unicode support, e.g. JuliaMono. Detailed installation instructions are available there.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"This problems affects users of Mac OS particularly often. At the time of writing, installing JuliaMono is as simple as","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"$ brew tap homebrew/cask-fonts\n$ brew install --cask font-juliamono","category":"page"},{"location":"troubleshooting/#There-are-no-timing-results-of-the-initial-mesh-creation","page":"Troubleshooting and FAQ","title":"There are no timing results of the initial mesh creation","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"By default, the SummaryCallback resets the timer used internally by Trixi when it is initialized (when solve is called). If this step needs to be timed, e.g. to debug performance problems, explicit timings can be used as follows.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"using Trixi\n\nbegin\n  Trixi.reset_timer!(Trixi.timer())\n\n  equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n  mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), n_cells_max=10^5, initial_refinement_level=5)\n  solver = DGSEM(3)\n  semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test, solver)\n\n  Trixi.print_timer(Trixi.timer())\nend","category":"page"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Trixi's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about Trixi. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The Trixi Authors\" as mentioned under License.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Michael Schlottke-Lakemper, University of Cologne, Germany\nGregor Gassner, University of Cologne, Germany\nHendrik Ranocha, University of Münster, Germany\nAndrew Winters, Linköping University, Sweden","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to Trixi and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Benjamin Bolm\nLars Christmann\nChristof Czernik\nErik Faulhaber\nGregor Gassner\nLucas Gemein\nJulia Odenthal\nHendrik Ranocha\nAndrés M. Rueda-Ramírez\nFelipe Santillan\nMichael Schlottke-Lakemper\nAndrew Winters","category":"page"},{"location":"adding_new_equations/nonconservative_advection/#Adding-a-new-equation:-nonconservative-linear-advection","page":"Nonconservative equation","title":"Adding a new equation: nonconservative linear advection","text":"","category":"section"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"If you want to use Trixi for your own research, you might be interested in a new physics model that is not present in Trixi.jl. In this tutorial, we will implement the nonconservative linear advection equation","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"partial_t u(tx) + a(x) partial_x u(tx) = 0","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"in a periodic domain in one space dimension. In Trixi.jl, such a mathematical model is encoded as a subtype of Trixi.AbstractEquations.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"warning: Experimental interface\nThe support for nonconservative equations in Trixi is in an experimental stage and will likely change in future releases. The interface documented here is not considered to be part of the stable public API at the moment.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/#Basic-setup","page":"Nonconservative equation","title":"Basic setup","text":"","category":"section"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"Let's start by creating a module (in the REPL, in a file, in a Jupyter notebook, ...). That ensures that we can re-create structs defined therein without having to restart Julia.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"# Define new physics\nmodule NonconservativeLinearAdvection\n\nusing Trixi\nusing Trixi: AbstractEquations, get_node_vars\nimport Trixi: varnames, default_analysis_integrals, flux, max_abs_speed_naive,\n              have_nonconservative_terms, calcflux_twopoint_nonconservative,\n              noncons_interface_flux\n\n# Since there is no native support for variable coefficients, we use two\n# variables: one for the basic unknown `u` and another one for the coefficient `a`\nstruct NonconservativeLinearAdvectionEquation <: AbstractEquations{1 #= spatial dimension =#,\n                                                                   2 #= two variables (u,a) =#}\nend\n\nvarnames(::typeof(cons2cons), ::NonconservativeLinearAdvectionEquation) = (\"scalar\", \"advectionvelocity\")\n\ndefault_analysis_integrals(::NonconservativeLinearAdvectionEquation) = ()\n\n\n# The conservative part of the flux is zero\nflux(u, orientation, equation::NonconservativeLinearAdvectionEquation) = zero(u)\n\n# Calculate maximum wave speed for local Lax-Friedrichs-type dissipation\nfunction max_abs_speed_naive(u_ll, u_rr, orientation::Integer, ::NonconservativeLinearAdvectionEquation)\n  _, advectionvelocity_ll = u_ll\n  _, advectionvelocity_rr = u_rr\n\n  return max(abs(advectionvelocity_ll), abs(advectionvelocity_rr))\nend\n\n\n# We use nonconservative terms\nhave_nonconservative_terms(::NonconservativeLinearAdvectionEquation) = Val(true)\n\n# OBS! This is scaled by 1/2 because it will cancel later with the factor of 2\n# the flux differencing volume integral\nfunction calcflux_twopoint_nonconservative!(f1, u, element,\n                                                  equations::NonconservativeLinearAdvectionEquation,\n                                                  dg, cache)\n  for i in eachnode(dg)\n    _, advectionvelocity = get_node_vars(u, equations, dg, i, element)\n\n    for l in eachnode(dg)\n      scalar, _ = get_node_vars(u, equations, dg, l, element)\n      f1[1, l, i] += 0.5 * advectionvelocity * scalar\n    end\n  end\n\n  return nothing\nend\n\nfunction noncons_interface_flux(u_left, u_right, orientation, mode,\n                                      equations::NonconservativeLinearAdvectionEquation)\n  _, advectionvelocity = u_left\n  scalar, _            = u_right\n\n  # assume mode==:weak\n\n  return SVector(0.5 * advectionvelocity * scalar, zero(scalar))\nend\n\nend # module","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"The implementation of nononservative terms uses calcflux_twopoint_nonconservative! and noncons_interface_flux at the moment. This implementation is not considered to be part of the stable API and will likely change in future releases.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"Now, we can run a simple simulation using a DGSEM discretization. This code is written outside of our new module.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"# Create a simulation setup\nimport .NonconservativeLinearAdvection\nusing Trixi\nusing OrdinaryDiffEq\n\nequation = NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation()\n\n# You can derive the exact solution for this setup using the method of\n# characteristics\nfunction initial_condition_sine(x, t, equation::NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation)\n  x0 = -2 * atan(sqrt(3) * tan(sqrt(3) / 2 * t - atan(tan(x[1] / 2) / sqrt(3))))\n  scalar = sin(x0)\n  advectionvelocity = 2 + cos(x[1])\n  SVector(scalar, advectionvelocity)\nend\n\n# Create a uniform mesh in 1D in the interval [-π, π] with periodic boundaries\nmesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=4, n_cells_max=10^4)\n\n# Create a DGSEM solver with polynomials of degree `polydeg`\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs,\n               volume_integral=VolumeIntegralFluxDifferencing(flux_central))\n\n# Setup the spatial semidiscretization containing all ingredients\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create an ODE problem with given time span\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\n\n# Set up some standard callbacks summarizing the simulation setup and computing\n# errors of the numerical solution\nsummary_callback = SummaryCallback()\nanalysis_callback = AnalysisCallback(semi, interval=50)\ncallbacks = CallbackSet(summary_callback, analysis_callback);\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes\n# the passed callbacks\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false, callback=callbacks);\n\n# Print the timer summary\nsummary_callback()\n\n# Plot the numerical solution at the final time\nusing Plots: plot\nplot(sol)","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"You should see a plot of the final solution that looks as follows.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"(Image: tutorial_nonconservative_advection)","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"We can check whether everything fits together by refining the grid and comparing the numerical errors. First, we look at the error using the grid resolution above.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"julia> analysis_callback(sol).l2 |> first\n0.00029610274971929974","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"Next, we increase the grid resolution by one refinement level and run the simulation again.","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"mesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=5, n_cells_max=10^4)\n\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs,\n               volume_integral=VolumeIntegralFluxDifferencing(flux_central))\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\n\nsummary_callback = SummaryCallback()\nanalysis_callback = AnalysisCallback(semi, interval=50)\ncallbacks = CallbackSet(summary_callback, analysis_callback);\n\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false, callback=callbacks);\nsummary_callback()","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"As expected, the new error is roughly reduced by a factor of 16, corresponding to an experimental order of convergence of 4 (for polynomials of degree 3).","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"julia> analysis_callback(sol).l2 |> first\n1.8602959063280523e-5\n\njulia> 0.00029610274971929974 / 1.8602959063280523e-5\n15.916970451424719","category":"page"},{"location":"adding_new_equations/nonconservative_advection/#Summary-of-the-code","page":"Nonconservative equation","title":"Summary of the code","text":"","category":"section"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"Here is the complete code that we used (without the callbacks since these create a lot of unnecessary output in the doctests of this tutorial).","category":"page"},{"location":"adding_new_equations/nonconservative_advection/","page":"Nonconservative equation","title":"Nonconservative equation","text":"# Define new physics\nmodule NonconservativeLinearAdvection\n\nusing Trixi\nusing Trixi: AbstractEquations, get_node_vars\nimport Trixi: varnames, default_analysis_integrals, flux, max_abs_speed_naive,\n              have_nonconservative_terms, calcflux_twopoint_nonconservative!,\n              noncons_interface_flux\n\n# Since there is no native support for variable coefficients, we use two\n# variables: one for the basic unknown `u` and another one for the coefficient `a`\nstruct NonconservativeLinearAdvectionEquation <: AbstractEquations{1 #= spatial dimension =#,\n                                                                   2 #= two variables (u,a) =#}\nend\n\nvarnames(::typeof(cons2cons), ::NonconservativeLinearAdvectionEquation) = (\"scalar\", \"advectionvelocity\")\n\ndefault_analysis_integrals(::NonconservativeLinearAdvectionEquation) = ()\n\n\n# The conservative part of the flux is zero\nflux(u, orientation, equation::NonconservativeLinearAdvectionEquation) = zero(u)\n\n# Calculate maximum wave speed for local Lax-Friedrichs-type dissipation\nfunction max_abs_speed_naive(u_ll, u_rr, orientation::Integer, ::NonconservativeLinearAdvectionEquation)\n  _, advectionvelocity_ll = u_ll\n  _, advectionvelocity_rr = u_rr\n\n  return max(abs(advectionvelocity_ll), abs(advectionvelocity_rr))\nend\n\n\n# We use nonconservative terms\nhave_nonconservative_terms(::NonconservativeLinearAdvectionEquation) = Val(true)\n\n# OBS! This is scaled by 1/2 because it will cancel later with the factor of 2\n# the flux differencing volume integral\nfunction calcflux_twopoint_nonconservative!(f1, u, element,\n                                                  equations::NonconservativeLinearAdvectionEquation,\n                                                  dg, cache)\n  for i in eachnode(dg)\n    _, advectionvelocity = get_node_vars(u, equations, dg, i, element)\n\n    for l in eachnode(dg)\n      scalar, _ = get_node_vars(u, equations, dg, l, element)\n      f1[1, l, i] += 0.5 * advectionvelocity * scalar\n    end\n  end\n\n  return nothing\nend\n\nfunction noncons_interface_flux(u_left, u_right, orientation, mode,\n                                      equations::NonconservativeLinearAdvectionEquation)\n  _, advectionvelocity = u_left\n  scalar, _            = u_right\n\n  # assume mode==:weak\n\n  return SVector(0.5 * advectionvelocity * scalar, zero(scalar))\nend\n\nend # module\n\n\n\n# Create a simulation setup\nimport .NonconservativeLinearAdvection\nusing Trixi\nusing OrdinaryDiffEq\n\nequation = NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation()\n\n# You can derive the exact solution for this setup using the method of\n# characteristics\nfunction initial_condition_sine(x, t, equation::NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation)\n  x0 = -2 * atan(sqrt(3) * tan(sqrt(3) / 2 * t - atan(tan(x[1] / 2) / sqrt(3))))\n  scalar = sin(x0)\n  advectionvelocity = 2 + cos(x[1])\n  SVector(scalar, advectionvelocity)\nend\n\n# Create a uniform mesh in 1D in the interval [-π, π] with periodic boundaries\nmesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=4, n_cells_max=10^4)\n\n# Create a DGSEM solver with polynomials of degree `polydeg`\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs,\n               volume_integral=VolumeIntegralFluxDifferencing(flux_central))\n\n# Setup the spatial semidiscretization containing all ingredients\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create an ODE problem with given time span\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes\n# the passed callbacks\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false);\n\n# Plot the numerical solution at the final time\nusing Plots: plot\nplot(sol)","category":"page"},{"location":"parallelization/#Parallelization","page":"Parallelization","title":"Parallelization","text":"","category":"section"},{"location":"parallelization/#Shared-memory-parallelization-with-threads","page":"Parallelization","title":"Shared-memory parallelization with threads","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Many compute-intensive loops in Trixi.jl are parallelized using the multi-threading support provided by Julia. You can recognize those loops by the @threaded macro prefixed to them, e.g.,","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"@threaded for element in eachelement(dg, cache)\n  ...\nend","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"This will statically assign an equal iteration count to each available thread.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"To use multi-threading, you need to tell Julia at startup how many threads you want to use by either setting the environment variable JULIA_NUM_THREADS or by providing the -t/--threads command line argument. For example, to start Julia with four threads, start Julia with","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"julia --threads=4","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"If both the environment variable and the command line argument are specified at the same time, the latter takes precedence.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"warning: Warning\nNot everything is parallelized yet and there are likely opportunities to improve scalability. Multi-threading isn't considered part of the public API of Trixi yet.","category":"page"},{"location":"parallelization/#Distributed-computing-with-MPI","page":"Parallelization","title":"Distributed computing with MPI","text":"","category":"section"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"In addition to the shared memory parallelization with multi-threading, Trixi.jl supports distributed parallelism via MPI.jl, which leverages the Message Passing Interface (MPI). MPI.jl comes with its own MPI library binaries such that there is no need to install MPI yourself. However, it is also possible to instead use an existing MPI installation, which is recommended if you are running MPI programs on a cluster or supercomputer (see the MPI.jl docs to find out how to select the employed MPI library).","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"warning: Work in progress\nMPI-based parallelization is work in progress and not finished yet. Nothing related to MPI is part of the official API of Trixi yet.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"To start Trixi in parallel with MPI, there are three options:","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"Run from the REPL with mpiexec(): You can start a parallel execution directly from the REPL by executing\njulia> using MPI\n\njulia> mpiexec() do cmd\n         run(`$cmd -n 3 $(Base.julia_cmd()) --threads=1 --project=@. -e 'using Trixi; trixi_include(default_example())'`)\n       end\nThe parameter -n 3 specifies that Trixi should run with three processes (or ranks in MPI parlance) and should be adapted to your available computing resources and problem size. The $(Base.julia_cmd()) argument ensures that Julia is executed in parallel with the same optimization level etc. as you used for the REPL; if this is unnecessary or undesired, you can also just use julia.  Further, if you are not running Trixi from a local clone but have installed it as a package, you need to omit the --project=@..\nRun from the command line with mpiexecjl: Alternatively, you can use the mpiexecjl script provided by MPI.jl, which allows you to start Trixi in parallel directly from the command line. As a preparation, you need to install the script once by running\njulia> using MPI\n\njulia> MPI.install_mpiexecjl(destdir=\"/somewhere/in/your/PATH\")\nThen, to execute Trixi in parallel, execute the following command from your command line:\nmpiexecjl -n 3 julia --threads=1 --project=@. -e 'using Trixi; trixi_include(default_example())'\nRun interactively with tmpi (Linux/MacOS only): If you are on a Linux/macOS system, you have a third option which lets you run Julia in parallel interactively from the REPL. This comes in handy especially during development, as in contrast to the first two options, it allows to reuse the compilation cache and thus facilitates much faster startup times after the first execution. It requires tmux and the OpenMPI library to be installed before, both of which are usually available through a package manager. Once you have installed both tools, you need to configure MPI.jl to use the OpenMPI for your system, which is explained here. Then, you can download and install the tmpi script by executing\ncurl https://raw.githubusercontent.com/Azrael3000/tmpi/master/tmpi -o /somewhere/in/your/PATH/tmpi\nFinally, you can start and control multiple Julia REPLs simultaneously by running\ntmpi 3 julia --threads=1 --project=@.\nThis will start Julia inside tmux three times and multiplexes all commands you enter in one REPL to all other REPLs (try for yourself to understand what it means). If you have no prior experience with tmux, handling the REPL this way feels slightly weird in the beginning. However, there is a lot of documentation for tmux available and once you get the hang of it, developing Trixi in parallel becomes much smoother this way.","category":"page"},{"location":"parallelization/","page":"Parallelization","title":"Parallelization","text":"note: Hybrid parallelism\nIt is possible to combine MPI with shared memory parallelism via threads by starting Julia with more than one thread, e.g. by passing the command line argument julia --threads=2 instead of julia --threads=1 used in the examples above. In that case, you should make sure that your system supports the number of processes/threads that you try to start.","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2020-present The Trixi Authors (see Authors)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"reference-trixi/#Trixi.jl-API","page":"Trixi.jl","title":"Trixi.jl API","text":"","category":"section"},{"location":"reference-trixi/","page":"Trixi.jl","title":"Trixi.jl","text":"CurrentModule = Trixi","category":"page"},{"location":"reference-trixi/","page":"Trixi.jl","title":"Trixi.jl","text":"Modules = [Trixi]","category":"page"},{"location":"reference-trixi/#Trixi.Trixi","page":"Trixi.jl","title":"Trixi.Trixi","text":"Trixi\n\nTrixi.jl is a numerical simulation framework for hyperbolic conservation laws. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures.\n\nTo get started, run your first simulation with Trixi using\n\ntrixi_include(default_example())\n\nSee also: trixi-framework/Trixi.jl\n\n\n\n\n\n","category":"module"},{"location":"reference-trixi/#Trixi.boundary_condition_periodic","page":"Trixi.jl","title":"Trixi.boundary_condition_periodic","text":"boundary_condition_periodic = BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi/#Trixi.flux_hll","page":"Trixi.jl","title":"Trixi.flux_hll","text":"flux_hll\n\nSee FluxHLL.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi/#Trixi.flux_lax_friedrichs","page":"Trixi.jl","title":"Trixi.flux_lax_friedrichs","text":"flux_lax_friedrichs\n\nSee FluxLaxFriedrichs.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi/#Trixi.AMRCallback","page":"Trixi.jl","title":"Trixi.AMRCallback","text":"AMRCallback(semi, controller [,adaptor=AdaptorAMR(semi)];\n            interval,\n            adapt_initial_condition=true,\n            adapt_initial_condition_only_refine=true)\n\nPerforms adaptive mesh refinement (AMR) every interval time steps for a given semidiscretization semi using the chosen controller.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.AbstractEquations","page":"Trixi.jl","title":"Trixi.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the compressible Euler equations. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.AbstractMesh","page":"Trixi.jl","title":"Trixi.AbstractMesh","text":"AbstractMesh{NDIMS}\n\nAn abstract supertype of specific mesh types such as TreeMesh or StructuredMesh. The type parameters encode the number of spatial dimensions (NDIMS).\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.AcousticPerturbationEquations2D","page":"Trixi.jl","title":"Trixi.AcousticPerturbationEquations2D","text":"AcousticPerturbationEquations2D(v_mean_global, c_mean_global, rho_mean_global)\n\nwarning: Experimental code\nThis system of equations is experimental and may change in any future release.\n\nAcoustic perturbation equations (APE) in two space dimensions. The equations are given by\n\nbeginaligned\n  fracpartialmathbfvpartial t + nabla (barmathbfvcdotmathbfv)\n    + nablaleft( fracpbarrho right) = 0 \n  fracpartial ppartial t + nablacdot (barc^2 barrho^2 mathbfv + barv p)\n    = left( barrhomathbfv + barmathbfvfracpbarc^2 right)cdotnablabarc^2\nendaligned\n\nThe bar bar(cdot) indicates time-averaged quantities. The unknowns of the APE are the perturbed velocities mathbfv = (v_1 v_2)^T and the perturbed pressure p, where perturbed variables are defined by phi = phi - barphi.\n\nNote that the source term must be defined separately and passed manually to SemidiscretizationHyperbolic.\n\nIn addition to the unknowns, Trixi currently stores the mean values in the state vector, i.e. the state vector used internally is given by\n\nmathbfu =\n  beginpmatrix\n    v_1  v_2  p  barv_1  barv_2  barc  barrho\n  endpmatrix\n\nThis affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the mean values must be zero.\nThe mean values have to be considered when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes these variables too.\nTrixi's visualization tools will visualize the mean values by default.\n\nThe constructor accepts a 2-tuple v_mean_global and scalars c_mean_global and rho_mean_global which can be used to make the definition of initial conditions for problems with constant mean flow more flexible. These values are ignored if the mean values are defined internally in an initial condition.\n\nThe equations are based on the APE-4 system introduced in the following paper:\n\nRoland Ewert and Wolfgang Schröder (2003) Acoustic perturbation equations based on flow decomposition via source filtering DOI: 10.1016/S0021-9991(03)00168-2\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.AliveCallback","page":"Trixi.jl","title":"Trixi.AliveCallback","text":"AliveCallback(analysis_interval=0, alive_interval=analysis_interval÷10)\n\nInexpensive callback showing that a simulation is still running by printing some information such as the current time to the screen every alive_interval time steps. If analysis_interval ≂̸ 0, the output is omitted every analysis_interval time steps.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.AnalysisCallback","page":"Trixi.jl","title":"Trixi.AnalysisCallback","text":"AnalysisCallback(semi; interval=0,\n                       save_analysis=false,\n                       output_directory=\"out\",\n                       analysis_filename=\"analysis.dat\",\n                       extra_analysis_errors=Symbol[],\n                       extra_analysis_integrals=())\n\nAnalyze a numerical solution every interval time steps and print the results to the screen. If save_analysis, the results are also saved in joinpath(output_directory, analysis_filename).\n\nAdditional errors can be computed, e.g. by passing extra_analysis_errors = [:primitive].\n\nFurther scalar functions func in extra_analysis_integrals are applied to the numerical solution and integrated over the computational domain. See Trixi.analyze, Trixi.pretty_form_utf, Trixi.pretty_form_ascii for further information on how to create custom analysis quantities.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.BoundaryConditionDirichlet","page":"Trixi.jl","title":"Trixi.BoundaryConditionDirichlet","text":"BoundaryConditionDirichlet(boundary_value_function)\n\nCreate a Dirichlet boundary condition that uses the function boundary_value_function to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as\n\nboundary_value_function(x, t, equations)\n\nwhere x specifies the coordinates, t is the current time, and equation is the corresponding system of equations.\n\nExamples\n\njulia> BoundaryConditionDirichlet(initial_condition_convergence_test)\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.BoundaryConditionWall","page":"Trixi.jl","title":"Trixi.BoundaryConditionWall","text":"BoundaryConditionWall(boundary_value_function)\n\nCreate a generic wall type boundary condition that uses the function boundary_value_function to specify the external solution values. The boundary wall function is called with arguments for an internal solution state from inside an element u_inner, an outward pointing normal_direction and a particular set of equations, e.g.,\n\nboundary_value_function(u_inner, normal_direction, equations)\n\nwhich will return an external solution state.\n\nExample\n\njulia> BoundaryConditionWall(boundary_state_slip_wall)\n\nwarning: Experimental code\nThis boundary condition can change any time and is currently only implemented for the CompressibleEulerEquations2D and AcousticPerturbationEquations2D.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CarpenterKennedy2N43","page":"Trixi.jl","title":"Trixi.CarpenterKennedy2N43","text":"  CarpenterKennedy2N43()\n\nCarpenter, Kennedy (1994) Third order 2N storage RK schemes with error control\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CarpenterKennedy2N54","page":"Trixi.jl","title":"Trixi.CarpenterKennedy2N54","text":"CarpenterKennedy2N54()\n\nThe following structures and methods provide a minimal implementation of the low-storage explicit Runge-Kutta method of\n\nCarpenter, Kennedy (1994) Fourth order 2N storage RK schemes, Solution 3\n\nusing the same interface as OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CompressibleEulerEquations1D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations1D","text":"CompressibleEulerEquations1D(gamma)\n\nThe compressible Euler equations for an ideal gas with ratio of specific heats gamma in one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CompressibleEulerEquations2D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations2D","text":"CompressibleEulerEquations2D(gamma)\n\nThe compressible Euler equations for an ideal gas with ratio of specific heats gamma in two space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CompressibleEulerEquations3D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations3D","text":"CompressibleEulerEquations3D(gamma)\n\nThe compressible Euler equations for an ideal gas with ratio of specific heats gamma in three space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CompressibleEulerMulticomponentEquations1D","page":"Trixi.jl","title":"Trixi.CompressibleEulerMulticomponentEquations1D","text":"CompressibleEulerMulticomponentEquations1D(; gammas, gas_constants)\n\nwarning: Experimental code\nThis system of equations is experimental and can change any time.\n\nMulticomponent version of the compressible Euler equations\n\npartial t\nbeginpmatrix\nrho v_1  E  rho_1  rho_2  vdots  rho_n\nendpmatrix\n+\npartial x\nbeginpmatrix\nrho v_1  rho v_1^2 + p  (E+p) v_1  rho_1 v_1  rho_2 v_1  vdots  rho_n v_1\nendpmatrix\n\n=\nbeginpmatrix\n0  0  0  0  vdots  0\nendpmatrix\n\nfor calorically perfect gas in one space dimension.\n\nIn case of more than one component, the specific heat ratios gammas and the gas constants gas_constants should be passed as tuples, e.g., gammas=(1.4, 1.667).\n\nThe remaining variables like the specific heats at constant volume 'cv' or the specific heats at constant pressure 'cp' are then calculated considering a calorically perfect gas.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.CompressibleEulerMulticomponentEquations2D","page":"Trixi.jl","title":"Trixi.CompressibleEulerMulticomponentEquations2D","text":"CompressibleEulerMulticomponentEquations2D(; gammas, gas_constants)\n\nwarning: Experimental code\nThis system of equations is experimental and can change any time.\n\nMulticomponent version of the compressible Euler equations\n\npartial t\nbeginpmatrix\nrho v_1  rho v_2  E  rho_1  rho_2  vdots  rho_n\nendpmatrix\n+\npartial x\nbeginpmatrix\nrho v_1^2 + p  rho v_1 v_2  (E+p) v_1  rho_1 v_1  rho_2 v_1  vdots  rho_n v_1\nendpmatrix\n+\npartial y\nbeginpmatrix\nrho v_1 v_2  rho v_2^2 + p  (E+p) v_2  rho_1 v_2  rho_2 v_2  vdots  rho_n v_2\nendpmatrix\n=\nbeginpmatrix\n0  0  0  0  0  vdots  0\nendpmatrix\n\nfor calorically perfect gas in two space dimensions.\n\nIn case of more than one component, the specific heat ratios gammas and the gas constants gas_constants in [kJ/(kg*K)] should be passed as tuples, e.g., gammas=(1.4, 1.667).\n\nThe remaining variables like the specific heats at constant volume 'cv' or the specific heats at constant pressure 'cp' are then calculated considering a calorically perfect gas.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.ControllerThreeLevel","page":"Trixi.jl","title":"Trixi.ControllerThreeLevel","text":"ControllerThreeLevel(semi, indicator; base_level=1,\n                                      med_level=base_level, med_threshold=0.0,\n                                      max_level=base_level, max_threshold=1.0)\n\nAn AMR controller based on three levels (in decending order of precedence):\n\nset the target level to max_level if indicator > max_threshold\nset the target level to med_level if indicator > med_threshold; if med_level < 0, set the target level to the current level\nset the target level to base_level otherwise\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.ControllerThreeLevelCombined","page":"Trixi.jl","title":"Trixi.ControllerThreeLevelCombined","text":"ControllerThreeLevelCombined(semi, indicator_primary, indicator_secondary;\n                             base_level=1,\n                             med_level=base_level, med_threshold=0.0,\n                             max_level=base_level, max_threshold=1.0,\n                             max_threshold_secondary=1.0)\n\nAn AMR controller based on three levels (in decending order of precedence):\n\nset the target level to max_level if indicator_primary > max_threshold\nset the target level to med_level if indicator_primary > med_threshold; if med_level < 0, set the target level to the current level\nset the target level to base_level otherwise\n\nIf indicator_secondary >= max_threshold_secondary, set the target level to max_level.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.DG","page":"Trixi.jl","title":"Trixi.DG","text":"DG(; basis, mortar, surface_integral, volume_integral)\n\nCreate a discontinuous Galerkin method. If basis isa LobattoLegendreBasis, this creates a DGSEM.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.DGSEM","page":"Trixi.jl","title":"Trixi.DGSEM","text":"DGSEM(; RealT=Float64, polydeg::Integer,\n        surface_flux=flux_central,\n        surface_integral=SurfaceIntegralWeakForm(surface_flux),\n        volume_integral=VolumeIntegralWeakForm(),\n        mortar=MortarL2(basis))\n\nCreate a discontinuous Galerkin spectral element method (DGSEM) using a LobattoLegendreBasis with polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.DissipationGlobalLaxFriedrichs","page":"Trixi.jl","title":"Trixi.DissipationGlobalLaxFriedrichs","text":"DissipationGlobalLaxFriedrichs(λ)\n\nCreate a global Lax-Friedrichs dissipation operator with dissipation coefficient λ.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.DissipationLocalLaxFriedrichs","page":"Trixi.jl","title":"Trixi.DissipationLocalLaxFriedrichs","text":"DissipationLocalLaxFriedrichs(max_abs_speed=max_abs_speed_naive)\n\nCreate a local Lax-Friedrichs dissipation operator where the maximum absolute wave speed is estimated as max_abs_speed(u_ll, u_rr, orientation_or_normal_direction, equations), defaulting to max_abs_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.FluxHLL","page":"Trixi.jl","title":"Trixi.FluxHLL","text":"FluxHLL(min_max_speed=min_max_speed_naive)\n\nCreate an HLL (Harten, Lax, van Leer) numerical flux where the minimum and maximum wave speeds are estimated as λ_min, λ_max = min_max_speed(u_ll, u_rr, orientation_or_normal_direction, equations), defaulting to min_max_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.FluxLaxFriedrichs","page":"Trixi.jl","title":"Trixi.FluxLaxFriedrichs","text":"FluxLaxFriedrichs(max_abs_speed=max_abs_speed_naive)\n\nLocal Lax-Friedrichs (Rusanov) flux with maximum wave speed estimate provided by max_abs_speed, cf. DissipationLocalLaxFriedrichs and max_abs_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.FluxPlusDissipation","page":"Trixi.jl","title":"Trixi.FluxPlusDissipation","text":"FluxPlusDissipation(numerical_flux, dissipation)\n\nCombine a numerical_flux with a dissipation operator to create a new numerical flux.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.FluxRotated","page":"Trixi.jl","title":"Trixi.FluxRotated","text":"FluxRotated(numerical_flux)\n\nCompute a numerical_flux flux in direction of a normal vector by rotating the solution, computing the numerical flux in x-direction, and rotating the calculated flux back.\n\nRequires a rotationally invariant equation with equation-specific functions rotate_to_x and rotate_from_x.\n\nwarning: Experimental code\nThis flux is experimental and is likely to change in a future release. Do not use it in production code.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.GlmSpeedCallback","page":"Trixi.jl","title":"Trixi.GlmSpeedCallback","text":"GlmSpeedCallback(; glm_scale=0.5, cfl)\n\nUpdate the divergence cleaning wave speed c_h according to the time step computed in StepsizeCallback for the ideal GLM-MHD equations. The cfl number should be set to the same value as for the time step size calculation. The glm_scale ensures that the GLM wave speed is lower than the fastest physical waves in the MHD solution and should thus be set to a value within the interval [0,1]. Note that glm_scale = 0 deactivates the divergence cleaning.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.HypDiffN3Erk3Sstar52","page":"Trixi.jl","title":"Trixi.HypDiffN3Erk3Sstar52","text":"HypDiffN3Erk3Sstar52()\n\nFive stage, second-order acurate explicit Runge-Kutta scheme with stability region optimized for the hyperbolic diffusion equation with LLF flux and polynomials of degree polydeg=3.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.HyperbolicDiffusionEquations1D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations1D","text":"HyperbolicDiffusionEquations1D\n\nThe linear hyperbolic diffusion equations in one space dimension. A description of this system can be found in Sec. 2.5 of the book\n\nMasatsuka (2013) I Do Like CFD, Too: Vol 1. Freely available at http://www.cfdbooks.com/\n\nFurther analysis can be found in the paper\n\nNishikawa (2007) A first-order system approach for diffusion equation. I: Second-order residual-distribution schemes DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.HyperbolicDiffusionEquations2D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations2D","text":"HyperbolicDiffusionEquations2D\n\nThe linear hyperbolic diffusion equations in two space dimensions. A description of this system can be found in Sec. 2.5 of the book \"I Do Like CFD, Too: Vol 1\". The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.HyperbolicDiffusionEquations3D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations3D","text":"HyperbolicDiffusionEquations3D\n\nThe linear hyperbolic diffusion equations in three space dimensions. A description of this system can be found in Sec. 2.5 of the book \"I Do Like CFD, Too: Vol 1\". The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IdealGlmMhdEquations1D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations1D","text":"IdealGlmMhdEquations1D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in one space dimension.\n\nnote: Note\nThere is no divergence cleaning variable psi because the divergence-free constraint is satisfied trivially in one spatial dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IdealGlmMhdEquations2D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations2D","text":"IdealGlmMhdEquations2D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in two space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IdealGlmMhdEquations3D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations3D","text":"IdealGlmMhdEquations3D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in three space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IdealGlmMhdMulticomponentEquations1D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdMulticomponentEquations1D","text":"IdealGlmMhdMulticomponentEquations1D\n\nThe ideal compressible multicomponent GLM-MHD equations in one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IdealGlmMhdMulticomponentEquations2D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdMulticomponentEquations2D","text":"IdealGlmMhdMulticomponentEquations2D\n\nThe ideal compressible multicomponent GLM-MHD equations in two space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IndicatorHennemannGassner","page":"Trixi.jl","title":"Trixi.IndicatorHennemannGassner","text":"IndicatorHennemannGassner\n\nIndicator used for shock-capturing or AMR used by\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.IndicatorLöhner","page":"Trixi.jl","title":"Trixi.IndicatorLöhner","text":"IndicatorLöhner (equivalent to IndicatorLoehner)\n\nAMR indicator adapted from a FEM indicator by Löhner (1987), also used in the FLASH code as standard AMR indicator. The indicator estimates a weighted second derivative of a specified variable locally.\n\nLöhner (1987) \"An adaptive finite element scheme for transient problems in CFD\" doi: 10.1016/0045-7825(87)90098-3\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node59.html#SECTION05163100000000000000\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.InviscidBurgersEquation1D","page":"Trixi.jl","title":"Trixi.InviscidBurgersEquation1D","text":"InviscidBurgersEquation1D\n\nThe inviscid Burgers' equation\n\npartial_t u + frac12 partial_1 u^2 = 0\n\nin one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LatticeBoltzmannEquations2D","page":"Trixi.jl","title":"Trixi.LatticeBoltzmannEquations2D","text":"LatticeBoltzmannEquations2D(; Ma, Re, collision_op=collision_bgk,\n                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)\n\nThe Lattice-Boltzmann equations\n\npartial_t u_alpha + v_alpha1 partial_1 u_alpha + v_alpha2 partial_2 u_alpha = 0\n\nin two space dimensions for the D2Q9 scheme.\n\nThe characteristic Mach number and Reynolds numbers are specified as Ma and Re. By the default, the collision operator collision_op is set to the BGK model. c, L, and rho0 specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity u0 directly (Ma needs to be set to nothing in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity nu directly (in this case, Re needs to be set to nothing).\n\nThe nine discrete velocity directions of the D2Q9 scheme are sorted as follows [4]:\n\n  6     2     5       y\n    ┌───┼───┐         │\n    │       │         │\n  3 ┼   9   ┼ 1        ──── x\n    │       │        ╱\n    └───┼───┘       ╱\n  7     4     8    z\n\nNote that usually the velocities are numbered from 0 to 8, where 0 corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from 1 to 9, where 1 through 8 correspond to the velocity directions in [4] and 9 is the zero velocity.\n\nThe corresponding opposite directions are:\n\n1 ←→ 3\n2 ←→ 4\n3 ←→ 1\n4 ←→ 2\n5 ←→ 7\n6 ←→ 8\n7 ←→ 5\n8 ←→ 6\n9 ←→ 9\n\nThe main sources for the base implementation were\n\nMisun Min, Taehun Lee, A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows, J Comput Phys 230(1), 2011 doi:10.1016/j.jcp.2010.09.024\nKarsten Golly, Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum, Master Thesis, University of Cologne, 2018.\nDieter Hänel, Molekulare Gasdynamik, Springer-Verlag Berlin Heidelberg, 2004 doi:10.1007/3-540-35047-0\nDieter Krüger et al., The Lattice Boltzmann Method, Springer International Publishing, 2017 doi:10.1007/978-3-319-44649-3\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LatticeBoltzmannEquations3D","page":"Trixi.jl","title":"Trixi.LatticeBoltzmannEquations3D","text":"LatticeBoltzmannEquations3D(; Ma, Re, collision_op=collision_bgk,\n                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)\n\nThe Lattice-Boltzmann equations\n\npartial_t u_alpha + v_alpha1 partial_1 u_alpha + v_alpha2 partial_2 u_alpha + v_alpha3 partial_3 u_alpha = 0\n\nin three space dimensions for the D3Q27 scheme.\n\nThe characteristic Mach number and Reynolds numbers are specified as Ma and Re. By the default, the collision operator collision_op is set to the BGK model. c, L, and rho0 specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity u0 directly (Ma needs to be set to nothing in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity nu directly (in this case, Re needs to be set to nothing).\n\nThe twenty-seven discrete velocity directions of the D3Q27 scheme are sorted as follows [4]:\n\nplane at z = -1:\n  24    17     21       y\n     ┌───┼───┐          │\n     │       │          │\n  10 ┼   6   ┼ 15        ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n  20    12     26    z\nplane at z = 0:\n  14     3     7        y\n     ┌───┼───┐          │\n     │       │          │\n   2 ┼  27   ┼ 1         ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n   8     4     13    z\nplane at z = +1:\n  25    11     19       y\n     ┌───┼───┐          │\n     │       │          │\n  16 ┼   5   ┼ 9         ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n  22    18     23    z\n\nNote that usually the velocities are numbered from 0 to 26, where 0 corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from 1 to 27, where 1 through 26 correspond to the velocity directions in [4] and 27 is the zero velocity.\n\nThe corresponding opposite directions are:\n\n1 ←→  2\n2 ←→  1\n3 ←→  4\n4 ←→  3\n5 ←→  6\n6 ←→  5\n7 ←→  8\n8 ←→  7\n9 ←→ 10\n10 ←→  9\n11 ←→ 12\n12 ←→ 11\n13 ←→ 14\n14 ←→ 13\n15 ←→ 16\n16 ←→ 15\n17 ←→ 18\n18 ←→ 17\n19 ←→ 20\n20 ←→ 19\n21 ←→ 22\n22 ←→ 21\n23 ←→ 24\n24 ←→ 23\n25 ←→ 26\n26 ←→ 25\n27 ←→ 27\n\nThe main sources for the base implementation were\n\nMisun Min, Taehun Lee, A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows, J Comput Phys 230(1), 2011 doi:10.1016/j.jcp.2010.09.024\nKarsten Golly, Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum, Master Thesis, University of Cologne, 2018.\nDieter Hänel, Molekulare Gasdynamik, Springer-Verlag Berlin Heidelberg, 2004 doi:10.1007/3-540-35047-0\nDieter Krüger et al., The Lattice Boltzmann Method, Springer International Publishing, 2017 doi:10.1007/978-3-319-44649-3\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LinearScalarAdvectionEquation1D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation1D","text":"LinearScalarAdvectionEquation1D\n\nThe linear scalar advection equation\n\npartial_t u + a partial_1 u  = 0\n\nin one space dimension with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LinearScalarAdvectionEquation2D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation2D","text":"LinearScalarAdvectionEquation2D\n\nThe linear scalar advection equation\n\npartial_t u + a_1 partial_1 u + a_2 partial_2 u = 0\n\nin two space dimensions with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LinearScalarAdvectionEquation3D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation3D","text":"LinearScalarAdvectionEquation3D\n\nThe linear scalar advection equation\n\npartial_t u + a_1 partial_1 u + a_2 partial_2 u + a_3 partial_3 u = 0\n\nin three space dimensions with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.LobattoLegendreBasis","page":"Trixi.jl","title":"Trixi.LobattoLegendreBasis","text":"LobattoLegendreBasis([RealT=Float64,] polydeg::Integer)\n\nCreate a nodal Lobatto-Legendre basis for polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.P4estMesh","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nAn unstructured curved mesh based on trees that uses the C library p4est to manage trees and mesh refinement.\n\nwarning: Experimental code\nThis mesh type is experimental and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.P4estMesh-Tuple{Any}","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh(trees_per_dimension; polydeg,\n          mapping=nothing, faces=nothing, coordinates_min=nothing, coordinates_max=nothing,\n          RealT=Float64, initial_refinement_level=0, periodicity=true, unsaved_changes=true)\n\nCreate a structured curved P4estMesh of the specified size.\n\nThere are three ways to map the mesh to the physical domain.\n\nDefine a mapping that maps the hypercube [-1, 1]^n.\nSpecify a Tuple faces of functions that parametrize each face.\nCreate a rectangular mesh by specifying coordinates_min and coordinates_max.\n\nNon-periodic boundaries will be called :x_neg, :x_pos, :y_neg, :y_pos, :z_neg, :z_pos.\n\nArguments\n\ntrees_per_dimension::NTupleE{NDIMS, Int}: the number of trees in each dimension.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nmapping: a function of NDIMS variables to describe the mapping that transforms            the reference mesh ([-1, 1]^n) to the physical domain.            Use only one of mapping, faces and coordinates_min/coordinates_max.\nfaces::NTuple{2*NDIMS}: a tuple of 2 * NDIMS functions that describe the faces of the domain.                           Each function must take NDIMS-1 arguments.                           faces[1] describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by faces[2].                           faces[3:4] describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           faces[5:6] describe the faces in positive and negative z-direction respectively (in 3D).                           Use only one of mapping, faces and coordinates_min/coordinates_max.\ncoordinates_min: vector or tuple of the coordinates of the corner in the negative direction of each dimension                    to create a rectangular mesh.                    Use only one of mapping, faces and coordinates_min/coordinates_max.\ncoordinates_max: vector or tuple of the coordinates of the corner in the positive direction of each dimension                    to create a rectangular mesh.                    Use only one of mapping, faces and coordinates_min/coordinates_max.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool}                deciding for each dimension if the boundaries in this dimension are periodic.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh{NDIMS}(meshfile::String;\n                 mapping=nothing, polydeg=1, RealT=Float64,\n                 initial_refinement_level=0, unsaved_changes=true)\n\nImport an uncurved, unstructured, conforming mesh from an Abaqus mesh file (.inp), map the mesh with the specified mapping, and create a P4estMesh from the curved mesh.\n\nCells in the mesh file will be imported as trees in the P4estMesh. The mesh will only have one boundary :all, as distinguishing different boundaries is non-trivial.\n\nArguments\n\nmeshfile::String: an uncurved Abaqus mesh file that can be imported by p4est.\nmapping: a function of NDIMS variables to describe the mapping that transforms            the imported mesh to the physical domain. Use nothing for the identity map.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of 1 creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.ParametersEulerGravity","page":"Trixi.jl","title":"Trixi.ParametersEulerGravity","text":"ParametersEulerGravity(; background_density=0.0,\n                         gravitational_constant=1.0,\n                         cfl=1.0,\n                         resid_tol=1.0e-4,\n                         n_iterations_max=10^4,\n                         timestep_gravity=timestep_gravity_erk52_3Sstar!)\n\nSet up parameters for the gravitational part of a SemidiscretizationEulerGravity.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.ParsaniKetchesonDeconinck3Sstar32","page":"Trixi.jl","title":"Trixi.ParsaniKetchesonDeconinck3Sstar32","text":"ParsaniKetchesonDeconinck3Sstar32()\n\nParsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems DOI: 10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.ParsaniKetchesonDeconinck3Sstar94","page":"Trixi.jl","title":"Trixi.ParsaniKetchesonDeconinck3Sstar94","text":"ParsaniKetchesonDeconinck3Sstar94()\n\nParsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems DOI: 10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.PerformanceCounter","page":"Trixi.jl","title":"Trixi.PerformanceCounter","text":"PerformanceCounter\n\nA PerformanceCounter be used to track the runtime performance of some calls. Add a new runtime measurement via put!(counter, runtime) and get the averaged runtime of all measurements added so far via take!(counter), resetting the counter.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.PlotData1D","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D\n\nHolds all relevant data for creating 1D plots of multiple solution variables and to visualize the mesh.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.PlotData1D-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D(u, semi [or mesh, equations, solver, cache];\n           solution_variables=nothing, nvisnodes=nothing)\n\nCreate a new PlotData1D object that can be used for visualizing 1D DGSEM solution data array u with Plots.jl. All relevant geometrical information is extracted from the semidiscretization semi. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to solution_variables.\n\nnvisnodes specifies the number of visualization nodes to be used. If it is nothing, twice the number of solution DG nodes are used for visualization, and if set to 0, exactly the number of nodes in the DG elements are used.\n\nWhen visualizing data from a two-dimensional simulation, a 1D slice is extracted for plotting. slice specifies the axis along which the slice is extracted and may be :x, or :y. The slice position is specified by a point that lies on it, which defaults to (0.0, 0.0). Both of these values are ignored when visualizing 1D data. This applies analogously to three-dimensonal simulations, where slice may be xy:, :xz, or :yz.\n\nAnother way to visualize 2D/3D data is by creating a plot along a given curve. This is done with the keyword argument curve. It can be set to a list of 2D/3D points which define the curve. When using curve any other input from slice or point will be ignored.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.PlotData1D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P<:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_<:Trixi.AbstractSemidiscretization, F_<:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D(sol; kwargs...)\n\nCreate a PlotData1D object from a solution object created by either OrdinaryDiffEq.solve! (which returns a DiffEqBase.ODESolution) or Trixi's own solve! (which returns a TimeIntegratorSolution).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.PlotData2D","page":"Trixi.jl","title":"Trixi.PlotData2D","text":"PlotData2D\n\nHolds all relevant data for creating 2D plots of multiple solution variables and to visualize the mesh.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.PlotData2D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P<:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_<:Trixi.AbstractSemidiscretization, F_<:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}","page":"Trixi.jl","title":"Trixi.PlotData2D","text":"PlotData2D(sol; kwargs...)\n\nCreate a PlotData2D object from a solution object created by either OrdinaryDiffEq.solve! (which returns a DiffEqBase.ODESolution) or Trixi's own solve! (which returns a TimeIntegratorSolution).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.PositivityPreservingLimiterZhangShu","page":"Trixi.jl","title":"Trixi.PositivityPreservingLimiterZhangShu","text":"PositivityPreservingLimiterZhangShu(; threshold, variables)\n\nThe fully-discrete positivity-preserving limiter of\n\nZhang, Shu (2011) Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments doi: 10.1098/rspa.2011.0153\n\nThe limiter is applied to all scalar variables in their given order using the associated thresholds to determine the minimal acceptable values. The order of the variables is important and might have a strong influence on the robustness.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SaveRestartCallback","page":"Trixi.jl","title":"Trixi.SaveRestartCallback","text":"SaveRestartCallback(; interval=0,\n                      save_final_restart=true,\n                      output_directory=\"out\")\n\nSave the current numerical solution in a restart file every interval time steps.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SaveSolutionCallback","page":"Trixi.jl","title":"Trixi.SaveSolutionCallback","text":"SaveSolutionCallback(; interval=0,\n                       save_initial_solution=true,\n                       save_final_solution=true,\n                       output_directory=\"out\",\n                       solution_variables=cons2prim)\n\nSave the current numerical solution every interval time steps. solution_variables can be any callable that converts the conservative variables at a single point to a set of solution variables. The first parameter passed to solution_variables will be the set of conservative variables and the second parameter is the equation struct.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SemidiscretizationEulerGravity","page":"Trixi.jl","title":"Trixi.SemidiscretizationEulerGravity","text":"SemidiscretizationEulerGravity\n\nA struct containing everything needed to describe a spatial semidiscretization of a the compressible Euler equations with self-gravity, reformulating the Poisson equation for the gravitational potential as steady-state problem of the hyperblic diffusion equations.\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) \"A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics\" arXiv: 2008.10593\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler<:(SemidiscretizationHyperbolic{Mesh, var\"#s2407\", InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var\"#s2407\"<:Trixi.AbstractCompressibleEulerEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache}), SemiGravity<:(SemidiscretizationHyperbolic{Mesh, var\"#s2406\", InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var\"#s2406\"<:Trixi.AbstractHyperbolicDiffusionEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache})}","page":"Trixi.jl","title":"Trixi.SemidiscretizationEulerGravity","text":"SemidiscretizationEulerGravity(semi_euler::SemiEuler, semi_gravity::SemiGravity, parameters)\n\nConstruct a semidiscretization of the compressible Euler equations with self-gravity. parameters should be given as ParametersEulerGravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.SemidiscretizationHyperbolic","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolic","text":"SemidiscretizationHyperbolic\n\nA struct containing everything needed to describe a spatial semidiscretization of a hyperbolic conservation law.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolic","text":"SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver;\n                             source_terms=nothing,\n                             boundary_conditions=boundary_condition_periodic,\n                             RealT=real(solver),\n                             uEltype=RealT,\n                             initial_cache=NamedTuple())\n\nConstruct a semidiscretization of a hyperbolic PDE.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.SteadyStateCallback","page":"Trixi.jl","title":"Trixi.SteadyStateCallback","text":"SteadyStateCallback(; abstol=1.0e-8, reltol=1.0e-6)\n\nTerminates the integration when the residual_steady_state(du, equations) falls below the threshold specified by abstol, reltol.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.StepsizeCallback","page":"Trixi.jl","title":"Trixi.StepsizeCallback","text":"StepsizeCallback(; cfl=1.0)\n\nSet the time step size according to a CFL condition with CFL number cfl if the time integration method isn't adaptive itself.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.StructuredMesh","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nA structured curved mesh.\n\nDifferent numbers of cells per dimension are possible and arbitrary functions can be used as domain faces.\n\nwarning: Experimental code\nThis mesh type is experimental and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.StructuredMesh-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, coordinates_min, coordinates_max)\n\nCreate a StructuredMesh that represents a uncurved structured mesh with a rectangular domain.\n\nArguments\n\ncells_per_dimension::NTuple{NDIMS, Int}: the number of cells in each dimension.\ncoordinates_min::NTuple{NDIMS, RealT}: coordinate of the corner in the negative direction of each dimension.\ncoordinates_max::NTuple{NDIMS, RealT}: coordinate of the corner in the positive direction of each dimension.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool} deciding for                each dimension if the boundaries in this dimension are periodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.StructuredMesh-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, mapping, RealT; unsaved_changes=true, mapping_as_string=mapping2string(mapping, length(cells_per_dimension)))\n\nCreate a StructuredMesh of the given size and shape that uses RealT as coordinate type.\n\nArguments\n\ncells_per_dimension::NTupleE{NDIMS, Int}: the number of cells in each dimension.\nmapping: a function of NDIMS variables to describe the mapping, which transforms            the reference mesh to the physical domain.            If no mapping_as_string is defined, this function must be defined with the name mapping            to allow for restarts.            This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.\nRealT::Type: the type that should be used for coordinates.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool}                deciding for each dimension if the boundaries in this dimension are periodic.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\nmapping_as_string::String: the code that defines the mapping.                              If CodeTracking can't find the function definition, it can be passed directly here.                              The code string must define the mapping function with the name mapping.                              This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.StructuredMesh-Tuple{Any, Tuple}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, faces, RealT; unsaved_changes=true, faces_as_string=faces2string(faces))\n\nCreate a StructuredMesh of the given size and shape that uses RealT as coordinate type.\n\nArguments\n\ncells_per_dimension::NTupleE{NDIMS, Int}: the number of cells in each dimension.\nfaces::NTuple{2*NDIMS}: a tuple of 2 * NDIMS functions that describe the faces of the domain.                           Each function must take NDIMS-1 arguments.                           faces[1] describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by faces[2].                           faces[3:4] describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           faces[5:6] describe the faces in positive and negative z-direction respectively (in 3D).\nRealT::Type: the type that should be used for coordinates.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool} deciding for                each dimension if the boundaries in this dimension are periodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.SurfaceIntegralStrongForm","page":"Trixi.jl","title":"Trixi.SurfaceIntegralStrongForm","text":"SurfaceIntegralStrongForm(surface_flux=flux_central)\n\nThe classical strong form surface integral type for FD/DG methods.\n\nSee also VolumeIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.SurfaceIntegralWeakForm","page":"Trixi.jl","title":"Trixi.SurfaceIntegralWeakForm","text":"SurfaceIntegralWeakForm(surface_flux=flux_central)\n\nThe classical weak form surface integral type for DG methods as explained in standard textbooks such as\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\n\nSee also VolumeIntegralWeakForm.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.TimeSeriesCallback","page":"Trixi.jl","title":"Trixi.TimeSeriesCallback","text":"TimeSeriesCallback(semi, point_coordinates;\n                   interval=1, solution_variables=cons2cons,\n                   output_directory=\"out\", filename=\"time_series.h5\",\n                   RealT=real(solver), uEltype=eltype(cache.elements))\n\nCreate a callback that records point-wise data at points given in point_coordinates every interval time steps. The point coordinates are to be specified either as a vector of coordinate tuples or as a two-dimensional array where the first dimension is the point number and the second dimension is the coordinate dimension. By default, the conservative variables are recorded, but this can be controlled by passing a different conversion function to solution_variables.\n\nAfter the last time step, the results are stored in an HDF5 file filename in directory output_directory.\n\nThe real data type RealT and data type for solution variables uEltype default to the respective types used in the solver and the cache.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.TreeMesh","page":"Trixi.jl","title":"Trixi.TreeMesh","text":"TreeMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nA Cartesian mesh based on trees of hypercubes to support adaptive mesh refinement.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.UnstructuredMesh2D","page":"Trixi.jl","title":"Trixi.UnstructuredMesh2D","text":"UnstructuredMesh2D{RealT<:Real} <: AbstractMesh{2}\n\nAn unstructured (possibly curved) quadrilateral mesh.\n\nUnstructuredMesh2D(filename; RealT=Float64, periodicity=false)\n\nAll mesh information, neighbour coupling, and boundary curve information is read in from a mesh file filename.\n\nwarning: Experimental code\nThis mesh type is experimental and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.UnstructuredSortedBoundaryTypes","page":"Trixi.jl","title":"Trixi.UnstructuredSortedBoundaryTypes","text":"UnstructuredSortedBoundaryTypes{N, BCs<:NTuple{N, Any}}\n\nGeneral container to sort the boundary conditions by type for the unstructured quadrilateral solver. It stores a set of global indices for each boundary condition type to expedite computation during the call to calc_boundary_flux!. The original dictionary form of the boundary conditions set by the user in the elixir file is also stored for printing.\n\nwarning: Experimental code\nThis boundary condition container is experimental and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.VisualizationCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.VisualizationCallback","text":"VisualizationCallback(; interval=0,\n                        solution_variables=cons2prim,\n                        variable_names=[],\n                        show_mesh=false,\n                        plot_data_creator=PlotData2D,\n                        plot_creator=show_plot,\n                        plot_arguments...)\n\nCreate a callback that visualizes results during a simulation, also known as in-situ visualization.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in any future releases.\n\nThe interval specifies the number of time step iterations after which a new plot is generated. The available variables to plot are configured with the solution_variables parameter, which acts the same way as for the SaveSolutionCallback. The variables to be actually plotted can be selected by providing a single string or a list of strings to variable_names, and if show_mesh is true, an additional plot with the mesh will be generated.\n\nTo customize the generated figure, plot_data_creator allows to use different plot data types. With plot_creator you can further specify an own function to visualize results, which must support the same interface as the default implementation show_plot. All remaining keyword arguments are collected and passed as additional arguments to the plotting command.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.VolumeIntegralFluxDifferencing","page":"Trixi.jl","title":"Trixi.VolumeIntegralFluxDifferencing","text":"VolumeIntegralFluxDifferencing\n\nVolume integral type for DG methods based on SBP operators and flux differencing using symmetric two-point volume fluxes. Based upon the theory developed by\n\nLeFloch, Mercier, Rohde (2002) Fully Discrete, Entropy Conservative Schemes of Arbitrary Order doi: 10.1137/S003614290240069X\nFisher, Carpenter (2013) High-order entropy stable finite difference schemes for nonlinear conservation laws: Finite domains doi: 10.1016/j.jcp.2013.06.014\nHendrik Ranocha (2017) Comparison of Some Entropy Conservative Numerical Fluxes for the Euler Equations arXiv: 1701.02264 doi: 10.1007/s10915-017-0618-1\nChen, Shu (2017) Entropy stable high order discontinuous Galerkin methods with suitable quadrature rules for hyperbolic conservation laws doi: 10.1016/j.jcp.2017.05.025\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.VolumeIntegralPureLGLFiniteVolume","page":"Trixi.jl","title":"Trixi.VolumeIntegralPureLGLFiniteVolume","text":"VolumeIntegralPureLGLFiniteVolume\n\nA volume integral that only uses the subcell finite volume scheme from the paper\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\nThis gives a formally O(1)-accurate finite volume scheme on an LGL-type subcell mesh (LGL = Legendre-Gauss-Lobatto).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.VolumeIntegralShockCapturingHG","page":"Trixi.jl","title":"Trixi.VolumeIntegralShockCapturingHG","text":"VolumeIntegralShockCapturingHG\n\nShock-capturing volume integral type for DG methods proposed by\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.VolumeIntegralStrongForm","page":"Trixi.jl","title":"Trixi.VolumeIntegralStrongForm","text":"VolumeIntegralStrongForm\n\nThe classical strong form volume integral type for FD/DG methods.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Trixi.VolumeIntegralWeakForm","page":"Trixi.jl","title":"Trixi.VolumeIntegralWeakForm","text":"VolumeIntegralWeakForm\n\nThe classical weak form volume integral type for DG methods as explained in standard textbooks such as\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi/#Base.getindex-Tuple{PlotData2D, Any}","page":"Trixi.jl","title":"Base.getindex","text":"Base.getindex(pd::PlotData2D, variable_name)\n\nExtract a single variable variable_name from pd for plotting with Plots.plot.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Base.resize!-Tuple{Trixi.AbstractContainer, Any}","page":"Trixi.jl","title":"Base.resize!","text":"resize!(c::AbstractContainer, new_length) -> AbstractContainer\n\nResize c to contain new_length elements. If new_length is smaller than the current container length, the first new_length elements will be retained. If new_length is larger, the new elements are invalidated.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}","page":"Trixi.jl","title":"PolynomialBases.integrate","text":"integrate(f, u, basis::LobattoLegendreBasis)\n\nMap the function f to the coefficients u and integrate with respect to the quadrature rule given by basis.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func","page":"Trixi.jl","title":"PolynomialBases.integrate","text":"integrate([func=(u_node,equations)->u_node,] u_ode, semi::AbstractSemidiscretization; normalize=true)\n\nCall func(u_node, equations) for each vector of nodal variables u_node in u_ode and integrate the result using a quadrature associated with the semidiscretization semi.\n\nIf normalize is true, the result is divided by the total volume of the computational domain.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.LBMCollisionCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.LBMCollisionCallback","text":"LBMCollisionCallback()\n\nApply the Lattice-Boltzmann method (LBM) collision operator before each time step. See LatticeBoltzmannEquations2D for further details.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.P4estMeshCubedSphere-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.P4estMeshCubedSphere","text":"P4estMesh(trees_per_face_dimension, layers, inner_radius, thickness;\n          polydeg, RealT=Float64,\n          initial_refinement_level=0, unsaved_changes=true)\n\nBuild a \"Cubed Sphere\" mesh as P4estMesh with 6 * trees_per_face_dimension^2 * layers trees.\n\nThe mesh will have two boundaries, :inside and :outside.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the first two local dimensions of                                      each face.\nlayers::Integer: the number of trees in the third local dimension of each face, i.e., the number                    of layers of the sphere.\ninner_radius::Integer: the inner radius of the sphere.\nthickness::Integer: the thickness of the sphere. The outer radius will be inner_radius + thickness.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.SummaryCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.SummaryCallback","text":"SummaryCallback()\n\nCreate and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.TrivialCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.TrivialCallback","text":"TrivialCallback()\n\nA callback that does nothing. This can be useful to disable some callbacks easily via trixi_include.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.adapt_to_mesh_level!","text":"adapt_to_mesh_level!(u_ode, semi, level)\nadapt_to_mesh_level!(sol::Trixi.TrixiODESolution, level)\n\nLike adapt_to_mesh_level, but modifies the solution and parts of the semidiscretization (mesh and caches) in place.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.adapt_to_mesh_level","text":"adapt_to_mesh_level(u_ode, semi, level)\nadapt_to_mesh_level(sol::Trixi.TrixiODESolution, level)\n\nUse the regular adaptive mesh refinement routines to adaptively refine/coarsen the solution u_ode with semidiscretization semi towards a uniformly refined grid with refinement level level. The solution and semidiscretization are copied such that the original objects remain unaltered.\n\nA convenience method accepts an ODE solution object, from which solution and semidiscretization are extracted as needed.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: adapt_to_mesh_level!\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_couette-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_couette","text":"boundary_condition_couette(u_inner, orientation, direction, x, t,\n                           surface_flux_function,\n                           equations::LatticeBoltzmannEquations2D)\n\nMoving upper wall boundary condition for a Couette flow setup. To be used in combination with boundary_condition_wall_noslip for the lower wall and boundary_condition_periodic for the lateral boundaries.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_lid_driven_cavity-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_lid_driven_cavity","text":"boundary_condition_lid_driven_cavity(u_inner, orientation, direction, x, t,\n                                     surface_flux_function,\n                                     equations::LatticeBoltzmannEquations2D)\n\nBoundary condition for a lid-driven cavity flow setup, where the top lid (+y boundary) is a moving no-slip wall. To be used in combination with initial_condition_lid_driven_cavity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x","text":"boundary_condition_linear_x(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation1D)\n\nBoundary conditions for initial_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x","text":"boundary_condition_linear_x(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x_y","text":"boundary_condition_linear_x_y(u_inner, orientation, direction, x, t,\n                              surface_flux_function,\n                              equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_x_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_y","text":"boundary_condition_linear_y(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_z","text":"boundary_condition_linear_z(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation1D)\n\nBoundary conditions for boundary_condition_linear_z.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_monopole-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_monopole","text":"boundaryconditionmonopole(uinner, orientation, direction, x, t, surfaceflux_function,                               equations::AcousticPerturbationEquations2D)\n\nBoundary condition for a monopole in a boundary layer at the -y boundary, i.e. direction = 3. This will return an error for any other direction. This boundary condition is used in combination with initial_condition_monopole.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.boundary_condition_poisson_nonperiodic","text":"boundary_condition_poisson_nonperiodic(u_inner, orientation, direction, x, t,\n                                    surface_flux_function,\n                                    equations::HyperbolicDiffusionEquations1D)\n\nBoundary conditions used for convergence tests in combination with initial_condition_poisson_nonperiodic and source_terms_poisson_nonperiodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_sedov_self_gravity","text":"boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,\n                                      surface_flux_function,\n                                      equations::CompressibleEulerEquations2D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with initial_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_sedov_self_gravity","text":"boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,\n                                      surface_flux_function,\n                                      equations::CompressibleEulerEquations2D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with initial_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_sedov_self_gravity","text":"boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,\n                                      surface_flux_function,\n                                      equations::HyperbolicDiffusionEquations2D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with initial_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_sedov_self_gravity","text":"boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,\n                                      surface_flux_function,\n                                      equations::HyperbolicDiffusionEquations3D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with initial_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_wall","text":"boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,\n                        equations::AcousticPerturbationEquations2D)\n\nBoundary conditions for a solid wall.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_wall_noslip","text":"boundary_condition_wall_noslip(u_inner, orientation, direction, x, t,\n                               surface_flux_function,\n                               equations::LatticeBoltzmannEquations2D)\n\nNo-slip wall boundary condition using the bounce-back approach.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_condition_zero-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_zero","text":"boundary_condition_zero(u_inner, orientation, direction, x, t, surface_flux_function,\n                        equations::AcousticPerturbationEquations2D)\n\nBoundary condition that uses a boundary state where the state variables are zero and the mean variables are the same as in u_inner.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_state_slip_wall","text":"boundary_state_slip_wall(u_inner, normal_direction::AbstractVector,\n                         equations::AcousticPertubationEquations2D)\n\nIdea behind this boundary condition is to use an orthogonal projection of the perturbed velocities to zero out the normal velocity while retaining the possibility of a tangential velocity in the boundary state. Further details are available in the paper:\n\nMarcus Bauer, Jürgen Dierke and Roland Ewert (2011) Application of a discontinuous Galerkin method to discretize acoustic perturbation equations DOI: 10.2514/1.J050333\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_state_slip_wall","text":"boundary_state_slip_wall(u_internal, normal_direction::AbstractVector,\n                         equations::CompressibleEulerEquations2D)\n\nDetermine the external solution value for a slip wall condition. Sets the normal velocity of the the exterior fictitious element to the negative of the internal value.\n\nwarning: Experimental code\nThis wall function can change any time.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_state_slip_wall","text":"boundary_state_slip_wall(u_internal, normal_direction::AbstractVector,\n                         equations::CompressibleEulerEquations3D)\n\nDetermine the external solution value for a slip wall condition. Sets the normal velocity of the the exterior fictitious element to the negative of the internal value.\n\nwarning: Experimental code\nThis wall function can change any time.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}","page":"Trixi.jl","title":"Trixi.calc_error_norms","text":"calc_error_norms([func=(u_node,equations)->u_node,] u_ode, t, analyzer, semi::AbstractSemidiscretization, cache_analysis)\n\nCalculate discrete L2 and L∞ error norms of func applied to each nodal variable u_node in u_ode. If no exact solution is available, \"errors\" are calculated using some reference state and can be useful for regression tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations1D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations2D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations3D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.collision_bgk","text":"collision_bgk(u, dt, equations::LatticeBoltzmannEquations2D)\n\nCollision operator for the Bhatnagar, Gross, and Krook (BGK) model.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.collision_bgk","text":"collision_bgk(u, dt, equations::LatticeBoltzmannEquations3D)\n\nCollision operator for the Bhatnagar, Gross, and Krook (BGK) model.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.compute_coefficients!","text":"compute_coefficients!(u_ode, func, t, semi::AbstractSemidiscretization)\n\nSame as compute_coefficients but stores the result in u_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.compute_coefficients","text":"compute_coefficients(func, t, semi::AbstractSemidiscretization)\n\nCompute the discrete coefficients of the continuous function func at time t associated with the semidiscretization semi. For example, the discrete coefficients of func for a discontinuous Galerkin spectral element method (DGSEM) are the values of func at the Lobatto-Legendre nodes. Similarly, a classical finite difference method will use the values of func at the nodes of the grid assoociated with the semidiscretization semi.\n\nFor semidiscretizations semi associated with an initial condition, func can be omitted to use the given initial condition at time t.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}","page":"Trixi.jl","title":"Trixi.cons2cons","text":"cons2cons(u, equations)\n\nReturn the conserved variables u. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.cons2entropy","page":"Trixi.jl","title":"Trixi.cons2entropy","text":"cons2entropy(u, equations)\n\nConvert the conserved variables u to the entropy variables for a given set of equations with chosen standard entropy. The inverse conversion is performed by entropy2cons.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.cons2prim","page":"Trixi.jl","title":"Trixi.cons2prim","text":"cons2prim(u, equations)\n\nConvert the conserved variables u to the primitive variables for a given set of equations. The inverse conversion is performed by prim2cons.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.convergence_test-Tuple{Module, AbstractString, Any}","page":"Trixi.jl","title":"Trixi.convergence_test","text":"convergence_test([mod::Module=Main,] elixir::AbstractString, iterations; kwargs...)\n\nRun iterations Trixi simulations using the setup given in elixir and compute the experimental order of convergence (EOC) in the L^2 and L^infty norm. In each iteration, the resolution of the respective mesh will be doubled. Additional keyword arguments kwargs... and the optional module mod are passed directly to trixi_include.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.default_example-Tuple{}","page":"Trixi.jl","title":"Trixi.default_example","text":"default_example()\n\nReturn the path to an example elixir that can be used to quickly see Trixi in action on a [TreeMesh]@(ref). See also examples_dir and get_examples.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.default_example_unstructured-Tuple{}","page":"Trixi.jl","title":"Trixi.default_example_unstructured","text":"default_example_unstructured()\n\nReturn the path to an example elixir that can be used to quickly see Trixi in action on an [UnstructuredMesh2D]@(ref). This simulation is run on the example curved, unstructured mesh given in the Trixi documentation regarding unstructured meshes.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.density","text":"density(p::Real, equations::LatticeBoltzmannEquations2D)\ndensity(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic density from the pressure p or the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.density","text":"density(p::Real, equations::LatticeBoltzmannEquations3D)\ndensity(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic density from the pressure p or the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.entropy","page":"Trixi.jl","title":"Trixi.entropy","text":"entropy(u, equations)\n\nReturn the chosen entropy of the conserved variables u for a given set of equations.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.entropy2cons","page":"Trixi.jl","title":"Trixi.entropy2cons","text":"entropy2cons(w, equations)\n\nConvert the entropy variables w based on a standard entropy to the conserved variables for a given set of equations . The inverse conversion is performed by cons2entropy.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.equilibrium_distribution","text":"equilibrium_distribution(alpha, rho, v1, v2, v3, equations::LatticeBoltzmannEquations3D)\n\nCalculate the local equilibrium distribution for the distribution function with index alpha and given the macroscopic state defined by rho, v1, v2, v3.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.equilibrium_distribution","text":"equilibrium_distribution(alpha, rho, v1, v2, equations::LatticeBoltzmannEquations2D)\n\nCalculate the local equilibrium distribution for the distribution function with index alpha and given the macroscopic state defined by rho, v1, v2.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.examples_dir-Tuple{}","page":"Trixi.jl","title":"Trixi.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with Trixi.jl are located. If Trixi is installed as a regular package (with ]add Trixi), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir:\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux","page":"Trixi.jl","title":"Trixi.flux","text":"flux(u, orientation_or_normal, equations)\n\nGiven the conservative variables u, calculate the (physical) flux in Cartesian direction orientation::Integer or in arbitrary direction normal::AbstractVector for the corresponding set of governing equations. orientation is 1, 2, and 3 for the x-, y-, and z-directions, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.flux_central-Tuple{Any, Any, Any, Trixi.AbstractEquations}","page":"Trixi.jl","title":"Trixi.flux_central","text":"flux_central(u_ll, u_rr, orientation_or_normal_direction, equations::AbstractEquations)\n\nThe classical central numerical flux f((u_ll) + f(u_rr)) / 2. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations1D)\n\nEntropy conserving two-point flux by\n\nAyoub Gouasmi, Karthik Duraisamy (2020) \"Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations\"\" arXiv:1904.00972v3 [math.NA] 4 Feb 2020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations2D)\n\nEntropy conserving two-point flux by\n\nAyoub Gouasmi, Karthik Duraisamy (2020) \"Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations\"\" arXiv:1904.00972v3 [math.NA] 4 Feb 2020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations3D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nEntropy conserving two-point flux adapted by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)\n\nEntropy conserving two-point flux adapted by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_hindenlang-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang","text":"flux_hindenlang(u_ll, u_rr, orientation_or_normal_direction,\n                equations::IdealGlmMhdEquations2D)\n\nEntropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_hindenlang-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang","text":"flux_hindenlang(u_ll, u_rr, orientation_or_normal_direction,\n                equations::IdealGlmMhdEquations3D)\n\nEntropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,\n                    equations::CompressibleEulerEquations2D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,\n                    equations::CompressibleEulerEquations3D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerEquations2D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerEquations3D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,\n                equations::CompressibleEulerEquations2D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,\n                equations::CompressibleEulerEquations3D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.get_examples-Tuple{}","page":"Trixi.jl","title":"Trixi.get_examples","text":"get_examples()\n\nReturn a list of all example elixirs that are provided by Trixi. See also examples_dir and default_example.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.get_name-Tuple{Any}","page":"Trixi.jl","title":"Trixi.get_name","text":"get_name(x)\n\nReturns a name of x ready for pretty printing. By default, return string(y) if x isa Val{y} and return string(x) otherwise.\n\nExamples\n\njulia> Trixi.get_name(\"test\")\n\"test\"\n\njulia> Trixi.get_name(Val(:test))\n\"test\"\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.get_name-Tuple{Trixi.AbstractEquations}","page":"Trixi.jl","title":"Trixi.get_name","text":"get_name(equations::AbstractEquations)\n\nReturns the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> Trixi.get_name(CompressibleEulerEquations1D(1.4))\n\"CompressibleEulerEquations1D\"\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.getmesh-Tuple{PlotData2D}","page":"Trixi.jl","title":"Trixi.getmesh","text":"getmesh(pd::PlotData2D)\n\nExtract grid lines from pd for plotting with Plots.plot.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.global_mean_vars","text":"global_mean_vars(equations::AcousticPerturbationEquations2D)\n\nReturns the global mean variables stored in equations. This makes it easier to define flexible initial conditions for problems with constant mean flow.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.init_mpi-Tuple{}","page":"Trixi.jl","title":"Trixi.init_mpi","text":"init_mpi()\n\nInitialize MPI by calling MPI.Initialized(). The function will check if MPI is already initialized and if yes, do nothing, thus it is safe to call it multiple times.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.init_p4est-Tuple{}","page":"Trixi.jl","title":"Trixi.init_p4est","text":"init_p4est()\n\nInitialize p4est by calling p4est_init and setting the log level to SC_LP_ERROR. This function will check if p4est is already initialized and if yes, do nothing, thus it is safe to call it multiple times.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_blast_wave","text":"initial_condition_blast_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA medium blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_blast_wave","text":"initial_condition_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n\nA medium blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_blast_wave","text":"initial_condition_blast_wave(x, t, equations::IdealGlmMhdEquations2D)\n\nAn MHD blast wave taken from\n\nDominik Derigs, Gregor J. Gassner, Stefanie Walch & Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics doi: 10.1365/s13291-018-0178-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_blob","text":"initial_condition_blob(x, t, equations::CompressibleEulerEquations2D)\n\nThe blob test case taken from\n\nAgertz et al. (2006) Fundamental differences between SPH and grid methods arXiv: astro-ph/0610051\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_blob","text":"initial_condition_blob(x, t, equations::CompressibleEulerEquations3D)\n\nThe blob test case taken from\n\nAgertz et al. (2006) Fundamental differences between SPH and grid methods arXiv: astro-ph/0610051\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_briowu_shock_tube","text":"initial_condition_briowu_shock_tube(x, t, equations::IdealGlmMhdEquations1D)\n\nCompound shock tube test case for one dimensional ideal MHD equations. It is bascially an MHD extension of the Sod shock tube. Taken from Section V of the article\n\nBrio and Wu (1988) An Upwind Differencing Scheme for the Equations of Ideal Magnetohydrodynamics DOI: 10.1016/0021-9991(88)90120-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_briowu_shock_tube","text":"initial_condition_briowu_shock_tube(x, t, equations::IdealGlmMhdMulticomponentEquations1D)\n\nCompound shock tube test case for one dimensional ideal MHD equations. It is bascially an MHD extension of the Sod shock tube. Taken from Section V of the article\n\nBrio and Wu (1988) An Upwind Differencing Scheme for the Equations of Ideal Magnetohydrodynamics DOI: 10.1016/0021-9991(88)90120-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::AcousticPerturbationEquations2D)\n\nA constant initial condition where the state variables are zero and the mean flow is constant. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::IdealGlmMhdEquations1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::IdealGlmMhdEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initialconditionconstant(x, t, equations::IdealGlmMhdEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::InviscidBurgersEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LatticeBoltzmannEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LatticeBoltzmannEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::AcousticPerturbationEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations1D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations3D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations1D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations2D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations3D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations1D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations2D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::InviscidBurgersEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA smooth initial condition used for convergence tests (in combination with BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_couette_steady-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_couette_steady","text":"initial_condition_couette_unsteady(x, t, equations::LatticeBoltzmannEquations2D)\n\nInitial state for a steady Couette flow setup. To be used in combination with boundary_condition_couette and boundary_condition_wall_noslip.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_couette_unsteady-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_couette_unsteady","text":"initial_condition_couette_unsteady(x, t, equations::LatticeBoltzmannEquations2D)\n\nInitial state for an unsteady Couette flow setup, which is also the exact solution for the incompressible Navier-Stokes equations. To be used in combination with boundary_condition_couette and boundary_condition_wall_noslip. In the limit, this setup will converge to the state set in initial_condition_couette_steady.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_pressure_pulse","text":"initial_condition_density_pressure_pulse(x, t, equations::CompressibleEulerEquations2D)\n\nA Gaussian pulse in density and pressure with constant velocity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_pulse","text":"initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations1D)\n\nA Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_pulse","text":"initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations2D)\n\nA Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_pulse","text":"initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations3D)\n\nA Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_wave","text":"initial_condition_density_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper\n\nGregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes arXiv: 2007.09026\n\nwith the following parameters\n\ndomain [-1, 1]\nmesh = 4x4\npolydeg = 5\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_wave","text":"initial_condition_density_wave(x, t, equations::CompressibleEulerEquations2D)\n\nA sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper\n\nGregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes arXiv: 2007.09026\n\nwith the following parameters\n\ndomain [-1, 1]\nmesh = 4x4\npolydeg = 5\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations1D)\n\nOne dimensional variant of the setup used for convergence tests of the Euler equations with self-gravity from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nnote: Note\nThere is no additional source term necessary for the manufactured solution in one spatial dimension. Thus, source_terms_eoc_test_coupled_euler_gravity is not present there.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_eoc_test_coupled_euler_gravity or source_terms_eoc_test_euler.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_eoc_test_coupled_euler_gravity or source_terms_eoc_test_euler.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations1D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::AcousticPerturbationEquations2D)\n\nA Gaussian pulse in a constant mean flow. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA Gaussian pulse used together with BoundaryConditionDirichlet(initial_condition_gauss).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equation::LinearScalarAdvectionEquation2D)\n\nA Gaussian pulse used together with BoundaryConditionDirichlet(initial_condition_gauss).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA Gaussian pulse.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_gauss_wall-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss_wall","text":"initial_condition_gauss_wall(x, t, equations::AcousticPerturbationEquations2D)\n\nA Gaussian pulse, used in the gauss_wall example elixir in combination with boundary_condition_wall. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_harmonic_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_harmonic_nonperiodic","text":"initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)\n\nA non-priodic harmonic function used in combination with source_terms_poisson_nonperiodic and boundary_condition_poisson_nonperiodic.\n\nnote: Note\nThe only harmonic functions in 1D have the form phi(x) = A + Bx\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_isentropic_vortex-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_isentropic_vortex","text":"initial_condition_isentropic_vortex(x, t, equations::CompressibleEulerEquations2D)\n\nThe classical isentropic vortex test case of\n\nChi-Wang Shu (1997) Essentially Non-Oscillatory and Weighted Essentially Non-Oscillatory Schemes for Hyperbolic Conservation Laws NASA/CR-97-206253\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_khi-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_khi","text":"initial_condition_khi(x, t, equations::CompressibleEulerEquations2D)\n\nThe classical Kelvin-Helmholtz instability based on\n\nhttps://rsaa.anu.edu.au/research/established-projects/fyris/2-d-kelvin-helmholtz-test\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_lid_driven_cavity-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_lid_driven_cavity","text":"initial_condition_lid_driven_cavity(x, t, equations::LatticeBoltzmannEquations2D)\n\nInitial state for a lid-driven cavity flow setup. To be used in combination with boundary_condition_lid_driven_cavity and boundary_condition_wall_noslip.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x","text":"initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA linear function of x[1] used together with boundary_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x","text":"initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] used together with boundary_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x_y","text":"initial_condition_linear_x_y(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] + x[2] used together with boundary_condition_linear_x_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_y","text":"initial_condition_linear_y(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] used together with boundary_condition_linear_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_z","text":"initial_condition_linear_z(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA linear function of x[3] used together with boundary_condition_linear_z.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_medium_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_medium_sedov_blast_wave","text":"initial_condition_medium_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n\nThe Sedov blast wave setup based on Flash\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flashug_devel/node184.html#SECTION010114000000000000000\n\nwith smaller strength of the initial discontinuity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_monopole-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_monopole","text":"initialconditionmonopole(x, t, equations::AcousticPerturbationEquations2D)\n\nInitial condition for the monopole in a boundary layer setup, used in combination with boundary_condition_monopole.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_orszag_tang","text":"initial_condition_orszag_tang(x, t, equations::IdealGlmMhdEquations2D)\n\nThe classical Orszag-Tang vortex test case. Here, the setup is taken from\n\nDominik Derigs, Gregor J. Gassner, Stefanie Walch & Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics doi: 10.1365/s13291-018-0178-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_orszag_tang","text":"initial_condition_orszag_tang(x, t, equations::IdealGlmMhdEquations3D)\n\nThe classical Orszag-Tang vortex test case. Here, the setup is taken from\n\nDominik Derigs, Gregor J. Gassner, Stefanie Walch & Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics doi: 10.1365/s13291-018-0178-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_poisson_nonperiodic","text":"initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)\n\nA non-priodic smooth initial condition. Can be used for convergence tests in combination with source_terms_poisson_nonperiodic and boundary_condition_poisson_nonperiodic.\n\nnote: Note\nThe solution is periodic but the initial guess is not.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_pressure_pulse","text":"initial_condition_pressure_pulse(x, t, equations::CompressibleEulerEquations2D)\n\nA Gaussian pulse in the pressure with constant velocity and density.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_rotor","text":"initial_condition_rotor(x, t, equations::IdealGlmMhdEquations2D)\n\nThe classical MHD rotor test case. Here, the setup is taken from\n\nDominik Derigs, Gregor J. Gassner, Stefanie Walch & Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics doi: 10.1365/s13291-018-0178-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_rotor","text":"initial_condition_rotor(x, t, equations::IdealGlmMhdMulticomponentEquations2D)\n\nThe classical MHD rotor test case adapted to twocomponent. Here, the setup is taken from\n\nDominik Derigs, Gregor J. Gassner, Stefanie Walch & Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics doi: 10.1365/s13291-018-0178-9\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_ryujones_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_ryujones_shock_tube","text":"initial_condition_ryujones_shock_tube(x, t, equations::IdealGlmMhdEquations1D)\n\nRyu and Jones shock tube test case for one dimensional ideal MHD equations. Contains fast shocks, slow shocks, and rational discontinuities that propagate on either side of the contact discontinuity. Exercises the scheme to capture all 7 types of waves present in the one dimensional MHD equations. It is the second test from Section 4 of\n\nRyu and Jones (1995) Numerical Magnetohydrodynamics in Astrophysics: Algorithm and Tests for One-Dimensional Flow DOI: 10.1086/175437\n\nnote: Note\nThis paper has a typo in the initial conditions. Their variable E should be p.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_blast_wave","text":"initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations1D)\n\nThe Sedov blast wave setup based on Flash\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flashug_devel/node184.html#SECTION010114000000000000000\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_blast_wave","text":"initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n\nThe Sedov blast wave setup based on Flash\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flashug_devel/node184.html#SECTION010114000000000000000\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_blast_wave","text":"initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations3D)\n\nThe Sedov blast wave setup based on Flash\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flashug_devel/node184.html#SECTION010114000000000000000\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_self_gravity","text":"initial_condition_sedov_self_gravity(x, t, equations::CompressibleEulerEquations2D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with boundary_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_self_gravity","text":"initial_condition_sedov_self_gravity(x, t, equations::CompressibleEulerEquations3D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with boundary_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_self_gravity","text":"initial_condition_sedov_self_gravity(x, t, equations::HyperbolicDiffusionEquations2D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with boundary_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_sedov_self_gravity","text":"initial_condition_sedov_self_gravity(x, t, equations::HyperbolicDiffusionEquations3D)\n\nAdaptation of the Sedov blast wave with self-gravity taken from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nbased on\n\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node184.html#SECTION010114000000000000000\n\nShould be used together with boundary_condition_sedov_self_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_shock_bubble-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D{10, 7, RealT} where RealT<:Real}","page":"Trixi.jl","title":"Trixi.initial_condition_shock_bubble","text":"initial_condition_shock_bubble(x, t, equations::CompressibleEulerMulticomponentEquations2D{10, 7})\n\nAdaption of the shock-bubble testcase for multicomponent Euler equations to 7 components\n\nAyoub Gouasmi, Karthik Duraisamy, Scott Murman Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations arXiv: 1904.00972\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_shock_bubble-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D{5, 2, RealT} where RealT<:Real}","page":"Trixi.jl","title":"Trixi.initial_condition_shock_bubble","text":"initial_condition_shock_bubble(x, t, equations::CompressibleEulerMulticomponentEquations2D{5, 2})\n\nA shock-bubble testcase for multicomponent Euler equations\n\nAyoub Gouasmi, Karthik Duraisamy, Scott Murman Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations arXiv: 1904.00972\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_shock_bubble-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D{6, 3, RealT} where RealT<:Real}","page":"Trixi.jl","title":"Trixi.initial_condition_shock_bubble","text":"initial_condition_shock_bubble(x, t, equations::CompressibleEulerMulticomponentEquations2D{6, 3})\n\nAdaption of the shock-bubble testcase for multicomponent Euler equations to 3 components\n\nAyoub Gouasmi, Karthik Duraisamy, Scott Murman Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations arXiv: 1904.00972\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_shu_osher_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_shu_osher_shock_tube","text":"initial_condition_shu_osher_shock_tube(x, t, equations::IdealGlmMhdEquations1D)\n\nExtended version of the test of Shu and Osher for one dimensional ideal MHD equations. Taken from Section 4.1 of\n\nDerigs et al. (2016) A Novel High-Order, Entropy Stable, 3D AMR MHD Solver withGuaranteed Positive Pressure DOI: 10.1016/j.jcp.2016.04.048\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_shu_osher_shock_tube_flipped-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_shu_osher_shock_tube_flipped","text":"initial_condition_shu_osher_shock_tube_flipped(x, t, equations::IdealGlmMhdEquations1D)\n\nExtended version of the test of Shu and Osher for one dimensional ideal MHD equations but shock propogates from right to left.\n\nnote: Note\nThis is useful to exercise some of the components of the HLL flux.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin","text":"initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin","text":"initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin_sin","text":"initial_condition_sin_sin(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_taylor_green_vortex","text":"initial_condition_taylor_green_vortex(x, t, equations::CompressibleEulerEquations3D)\n\nThe classical inviscid Taylor-Green vortex.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_taylor_green_vortex","text":"initial_condition_taylor_green_vortex(x, t, equations::LatticeBoltzmannEquations3D)\n\nInitialize the flow field to the Taylor-Green vortex setup\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_torrilhon_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_torrilhon_shock_tube","text":"initial_condition_torrilhon_shock_tube(x, t, equations::IdealGlmMhdEquations1D)\n\nTorrilhon's shock tube test case for one dimensional ideal MHD equations.\n\nTorrilhon (2003) Uniqueness conditions for Riemann problems of ideal magnetohydrodynamics DOI: 10.1017/S0022377803002186\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_two_interacting_blast_waves-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_two_interacting_blast_waves","text":"initial_condition_two_interacting_blast_waves(x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nA multicomponent two interacting blast wave test taken from\n\nT. Plewa & E. Müller (1999) The consistent multi-fluid advection method arXiv: 9807241\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations3D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nA for multicomponent adapted weak blast wave adapted to multicomponent and taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nA for multicomponent adapted weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations2D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations3D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations2D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any, N} where N}} where Func","page":"Trixi.jl","title":"Trixi.integrate_via_indices","text":"integrate_via_indices(func, u_ode, semi::AbstractSemidiscretization, args...; normalize=true)\n\nCall func(u, i..., element, equations, solver, args...) for all nodal indices i..., element and integrate the result using a quadrature associated with the semidiscretization semi.\n\nIf normalize is true, the result is divided by the total volume of the computational domain.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.inv_ln_mean-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.inv_ln_mean","text":"inv_ln_mean(x, y)\n\nCompute the inverse 1 / ln_mean(x, y) of the logarithmic mean ln_mean.\n\nThis function may be used to increase performance where the inverse of the logarithmic mean is needed, by replacing a (slow) division by a (fast) multiplication.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.jacobian_ad_forward","text":"jacobian_ad_forward(semi::AbstractSemidiscretization;\n                    t0=zero(real(semi)),\n                    u0_ode=compute_coefficients(t0, semi))\n\nUses the right-hand side operator of the semidiscretization semi and forward mode automatic differentiation to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.jacobian_fd","text":"jacobian_fd(semi::AbstractSemidiscretization;\n            t0=zero(real(semi)),\n            u0_ode=compute_coefficients(t0, semi))\n\nUses the right-hand side operator of the semidiscretization semi and simple second order finite difference to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.linear_structure","text":"linear_structure(semi::AbstractSemidiscretization;\n                 t0=zero(real(semi)))\n\nWraps the right-hand side operator of the semidiscretization semi at time t0 as an affine-linear operator given by a linear operator A and a vector b.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.ln_mean-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.ln_mean","text":"ln_mean(x, y)\n\nCompute the logarithmic mean\n\nln_mean(x, y) = (y - x) / (log(y) - log(x)) = (y - x) / log(y / x)\n\nProblem: The formula above has a removable singularity at x == y. Thus, some care must be taken to implement it correctly without problems or loss of accuracy when x ≈ y. Here, we use the approach proposed by Ismail and Roe (2009). Set ξ = y / x. Then, we have\n\n(y - x) / log(y / x) = (x + y) / log(ξ) * (ξ - 1) / (ξ + 1)\n\nSet f = (ξ - 1) / (ξ + 1) = (y - x) / (x + y). Then, we use the expansion\n\nlog(ξ) = 2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7) + O(ξ^9)\n\nInserting the first few terms of this expansion yields\n\n(y - x) / log(ξ) ≈ (x + y) * f / (2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7))\n                 = (x + y) / (2 + 2/3 * f^2 + 2/5 * f^4 + 2/7 * f^6)\n\nSince divisions are usually more expensive on modern hardware than multiplications (Agner Fog), we try to avoid computing two divisions. Thus, we use\n\nf^2 = (y - x)^2 / (x + y)^2\n    = (x * (x - 2 * y) + y * y) / (x * (x + 2 * y) + y * y)\n\nGiven ε = 1.0e-4, we use the following algorithm.\n\nif f^2 < ε\n  # use the expansion above\nelse\n  # use the direct formula (y - x) / log(y / x)\nend\n\nReferences\n\nIsmail, Roe (2009). Affordable, entropy-consistent Euler flux functions II: Entropy production at shocks. DOI: 10.1016/j.jcp.2009.04.021\nAgner Fog. Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD, and VIA CPUs. https://www.agner.org/optimize/instruction_tables.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.load_mesh-Tuple{AbstractString}","page":"Trixi.jl","title":"Trixi.load_mesh","text":"load_mesh(restart_file::AbstractString; n_cells_max)\n\nLoad the mesh from the restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.load_time-Tuple{AbstractString}","page":"Trixi.jl","title":"Trixi.load_time","text":"load_time(restart_file::AbstractString)\n\nLoad the time saved in a restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.max_abs_speed_naive","page":"Trixi.jl","title":"Trixi.max_abs_speed_naive","text":"max_abs_speed_naive(u_ll, u_rr, orientation::Integer,   equations)\nmax_abs_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)\n\nSimple and fast estimate of the maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, based only on the local wave speeds associated to u_ll and u_rr.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.min_max_speed_naive","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation::Integer,   equations)\nmin_max_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)\n\nSimple and fast estimate of the minimal and maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, usually based only on the local wave speeds associated to u_ll and u_rr.\n\nAmiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws DOI: 10.1137/1025002\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations3D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.multiply_dimensionwise-Tuple{AbstractMatrix{T} where T, AbstractMatrix{var\"#s324\"} where var\"#s324\"}","page":"Trixi.jl","title":"Trixi.multiply_dimensionwise","text":"multiply_dimensionwise(matrix::AbstractMatrix, data_in::AbstractArray{<:Any, NDIMS+1})\n\nMultiply the array data_in by matrix in each coordinate direction, where data_in is assumed to have the first coordinate for the number of variables and the remaining coordinates are multiplied by matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.ndofs","text":"ndofs(semi::AbstractSemidiscretization)\n\nReturn the number of degrees of freedom associated with each scalar variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.noncons_interface_flux-Tuple{Any, Any, Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.noncons_interface_flux","text":"noncons_interface_flux(u_left, u_right, orientation, mode, equations::IdealGlmMhdEquations2D)\n\nStrong form of non-conservative flux on a surface (Powell and GLM terms)\n\nphi^L 12 (B^L + B^R)_normal - phi^L B^L+normal = phi^L 12 (B^R - B^L)_normal\n\nnote: Note\nThe non-conservative interface flux depends on the discretization. Following \"modes\" are available::weak: 'weak' formulation of split DG already includes the contribution -12 (phi^L B^L_normal) so this mode only adds 12 (phi^L B^R_normal), analogously for the Galilean nonconservative term\n:whole: This mode adds the whole non-conservative term: phi^L 1/2 (B^R-B^L)\n:inner: This mode adds the split-form DG volume integral contribution: This is equivalent to (2)-(1) - 12 (phi^L B^L)\n\nwarning: Warning\nThis is non-unique along an interface! The normal direction is super important.\n\nFor details see Section 4 of the paper\n\nBohm et al. (2018) An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification DOI: 10.1016/j.jcp.2018.06.027\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.noncons_interface_flux-Tuple{Any, Any, Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.noncons_interface_flux","text":"noncons_interface_flux(u_left, u_right, orientation, mode, equations::IdealGlmMhdEquations2D)\n\nStrong form of non-conservative flux on a surface (Powell and GLM terms)\n\nphi^L 12 (B^L + B^R)_normal - phi^L B^L+normal = phi^L 12 (B^R - B^L)_normal\n\nnote: Note\nThe non-conservative interface flux depends on the discretization. Following \"modes\" are available::weak: 'weak' formulation of split DG already includes the contribution -12 (phi^L B^L_normal) so this mode only adds 12 (phi^L B^R_normal), analogously for the Galilean nonconservative term\n:whole: This mode adds the whole non-conservative term: phi^L 1/2 (B^R-B^L)\n:inner: This mode adds the split-form DG volume integral contribution: This is equivalent to (2)-(1) - 12 (phi^L B^L)\n\nwarning: Warning\nThis is non-unique along an interface! The normal direction is super important.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.partition!-Tuple{TreeMesh{NDIMS, var\"#s154\"} where {NDIMS, var\"#s154\"<:Trixi.ParallelTree{NDIMS}}}","page":"Trixi.jl","title":"Trixi.partition!","text":"partition!(mesh::ParallelTreeMesh, allow_coarsening=true)\n\nPartition mesh using a static domain decomposition algorithm based on leaf cell count and tree structure. If allow_coarsening is true, the algorithm will keep leaf cells together on one rank when needed for local coarsening (i.e. when all children of a cell are leaves).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.pressure","text":"pressure(rho::Real, equations::LatticeBoltzmannEquations2D)\npressure(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic pressure from the density rho or the  particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.pressure","text":"pressure(rho::Real, equations::LatticeBoltzmannEquations3D)\npressure(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic pressure from the density rho or the  particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.prim2cons","page":"Trixi.jl","title":"Trixi.prim2cons","text":"prim2cons(u, equations)\n\nConvert the conserved variables u to the primitive variables for a given set of equations. The inverse conversion is performed by cons2prim.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.residual_steady_state","text":"residual_steady_state(du, ::AbstractHyperbolicDiffusionEquations)\n\nUsed to determine the termination criterion of a SteadyStateCallback. For hyperbolic diffusion, this checks convergence of the potential phi.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.rotate_from_x","page":"Trixi.jl","title":"Trixi.rotate_from_x","text":"rotate_from_x(u, normal, equations)\n\nApply the rotation that maps the x-axis onto normal to the convservative variables u. This is used by FluxRotated to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.\n\nSee also: rotate_to_x\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.rotate_to_x","page":"Trixi.jl","title":"Trixi.rotate_to_x","text":"rotate_to_x(u, normal, equations)\n\nApply the rotation that maps normal onto the x-axis to the convservative variables u. This is used by FluxRotated to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.\n\nSee also: rotate_from_x\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi/#Trixi.save_plot-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.save_plot","text":"save_plot(plot_data, variable_names;\n          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),\n          time=nothing, timestep=nothing)\n\nVisualize the plot data object provided in plot_data and save result as a PNG file in the out directory, plotting only the variables in variable_names and, optionally, the mesh (if show_mesh is true).  Additionally, plot_arguments will be unpacked and passed as keyword arguments to the Plots.plot command.\n\nThe timestep is used in the filename. time is currently unused by this function.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: VisualizationCallback, show_plot\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}","page":"Trixi.jl","title":"Trixi.semidiscretize","text":"semidiscretize(semi::AbstractSemidiscretization, tspan, restart_file::AbstractString)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem. The initial condition etc. is taken from the restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}","page":"Trixi.jl","title":"Trixi.semidiscretize","text":"semidiscretize(semi::AbstractSemidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.show_plot-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.show_plot","text":"show_plot(plot_data, variable_names;\n          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),\n          time=nothing, timestep=nothing)\n\nVisualize the plot data object provided in plot_data and display result, plotting only the variables in variable_names and, optionally, the mesh (if show_mesh is true).  Additionally, plot_arguments will be unpacked and passed as keyword arguments to the Plots.plot command.\n\nThis function is the default plot_creator argument for the VisualizationCallback. time and timestep are currently unused by this function.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: VisualizationCallback, save_plot\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"sourcetermsconvergence_test(u, x, t, equations::AcousticPerturbationEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations3D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::InviscidBurgersEquation1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_coupled_euler_gravity","text":"source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_coupled_euler_gravity","text":"source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_euler","text":"source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_euler","text":"source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\nnote: Note\nThis method is to be used for testing pure Euler simulations with analytic self-gravity. If you intend to do coupled Euler-gravity simulations, you need to use source_terms_eoc_test_coupled_euler_gravity instead.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_harmonic","text":"source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations1D)\n\nSource term that only includes the forcing from the hyperbolic diffusion system used with initial_condition_harmonic_nonperiodic and BoundaryConditionDirichlet(initial_condition_harmonic_nonperiodic).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_poisson_nonperiodic","text":"source_terms_poisson_nonperiodic(u, x, t,\n                                 equations::HyperbolicDiffusionEquations1D)\n\nSource terms that include the forcing function f(x) and right hand side for the hyperbolic diffusion system that is used with initial_condition_poisson_nonperiodic and boundary_condition_poisson_nonperiodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.totalgamma","text":"totalgamma(u, equations::CompressibleEulerMulticomponentEquations1D)\n\nFunction that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.totalgamma","text":"totalgamma(u, equations::CompressibleEulerMulticomponentEquations2D)\n\nFunction that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.trixi_include-Tuple{Module, AbstractString}","page":"Trixi.jl","title":"Trixi.trixi_include","text":"trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. It's basic purpose is to make it easier to modify some parameters while running Trixi from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nExamples\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n0.1\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.uses_amr-Tuple{Any}","page":"Trixi.jl","title":"Trixi.uses_amr","text":"uses_amr(callback)\n\nChecks whether the provided callback or CallbackSet is an AMRCallback or contains one.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, orientation, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic velocity for the given orientation (1 -> x, 2 -> y) from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, orientation, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic velocity for the given orientation (1 -> x, 2 -> y, 3 -> z) from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic velocity vector from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic velocity vector from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi/#Trixi.@threaded-Tuple{Any}","page":"Trixi.jl","title":"Trixi.@threaded","text":"@threaded for ... end\n\nSemantically the same as Threads.@threads when iterating over a AbstractUnitRange but without guarantee that the underlying implementation uses Threads.@threads or works for more general for loops. In particular, there may be an additional check whether only one thread is used to reduce the overhead of serial execution or the underlying threading capabilities might be provided by other packages such as Polyester.jl.\n\nwarn: Warn\nThis macro does not necessarily work for general for loops. For example, it does not necessarily support general iterables such as eachline(filename).\n\nSome discussion can be found at https://discourse.julialang.org/t/overhead-of-threads-threads/53964 and https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435.\n\n\n\n\n\n","category":"macro"},{"location":"styleguide/#Style-guide","page":"Style guide","title":"Style guide","text":"","category":"section"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"The following lists a few coding conventions for Trixi:","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"Modules, types, structs with CamelCase.\nFunctions, variables with lowercase snake_case.\nIndentation with 2 spaces (never tabs!), line continuations indented with 4 spaces.\nMaximum line length (strictly): 100.\nFunctions that mutate their input are named with a trailing !.\nFunctions order their parameters similar to Julia Base.\nThe main modified argument comes first. For example, if the right-hand side du is modified,  it should come first. If only the cache is modified, e.g., in prolong2interfaces!  and its siblings, put the cache first.\nOtherwise, use the order mesh, equations, solver, cache.\nIf something needs to be specified in more detail for dispatch, put the additional argument before the general one  that is specified in more detail. For example, we use have_nonconservative_terms(equations), equations and dg.mortar, dg.\nPrefer for i in ... to for i = ... for better semantic clarity and greater flexibility.\nExecutable code should only use ASCII characters.\nDocstrings and comments can and should use Unicode characters where it helps understanding.\nMultiline expressions should be explicitly grouped by parentheses and not rely on Julia's implicit line continuation syntax.\nWhen naming multiple functions of a single or similar category, prefer to put the general classification first and the specialization second. Example: Use flux_central instead of central_flux. This helps when searching for available functions on the REPL (e.g., when trying to find all flux functions).","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"Based on that, and personal experience, a formatting tool with a few helpful options is included in utils/julia-format.jl. Note, however, that this tool is not yet optimal, as it re-indents too greedily.","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"This is a list of handy style guides that are mostly consistent with each other and this guide, and which have been used as a basis:","category":"page"},{"location":"styleguide/","page":"Style guide","title":"Style guide","text":"https://www.juliaopt.org/JuMP.jl/stable/style/\nhttps://github.com/jrevels/YASGuide","category":"page"},{"location":"overview/#Overview-of-the-structure-of-Trixi","page":"Overview","title":"Overview of the structure of Trixi","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Trixi is designed as a library of components for discretizations of hyperbolic conservation laws. Thus, it is not a monolithic PDE solver that is configured at runtime via parameter files, as it is often found in classical numerical simulation codes. Instead, each simulation is configured by pure Julia code. Many examples of such simulation setups, called elixirs in Trixi, are provided in the examples folder.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Trixi uses the method of lines, i.e., the full space-time discretization is separated into two steps; the spatial semidiscretization is performed at first and the resulting ODE system is solved numerically using a suitable time integration method. Thus, the main ingredients of an elixir designed to solve a PDE numerically are the spatial semidiscretization and the time integration scheme.","category":"page"},{"location":"overview/#Semidiscretizations","page":"Overview","title":"Semidiscretizations","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Semidiscretizations are high-level descriptions of spatial discretizations specialized for certain PDEs. Trixi's main focus is on hyperbolic conservation laws represented in a SemidiscretizationHyperbolic. Such semidiscretizations are usually named semi in Trixi.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: semidiscretization_overview)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The basic building blocks of a semidiscretization are","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"a mesh describing the geometry of the domain\na set of equations describing the physical model\na solver describing the numerical approach","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In addition, a semidiscretization bundles initial and boundary conditions, and possible source terms. These different ingredients of a semidiscretization can be configured individually and combined together. When a semidiscretization is constructed, it will create an internal cache, i.e., a collection of setup-specific data structures, that is usually passed to all lower level functions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Due to Trixi's modular nature using Julia's multiple dispatch features, new ingredients can be created specifically for a certain combination of other ingredients. For example, a new mesh type can be created and implemented at first only for a specific solver. Thus, there is no need to consider all possible combinations of meshes, equations, and solvers when implementing new features. This allows rapid prototyping of new ideas and is one of the main design goals behind Trixi. Below is a brief overview of the availability of different features on different mesh types.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Feature TreeMesh StructuredMesh UnstructuredMesh2D P4estMesh\nSpatial dimension 1D, 2D, 3D 1D, 2D, 3D 2D 2D, 3D\nCoordinates Cartesian curvilinear curvilinear curvilinear\nConnectivity h-nonconforming conforming conforming h-nonconforming\nElement type line, square, cube line, quadᵃ, hexᵃ quadᵃ quadᵃ, hexᵃ\nAdaptive mesh refinement (AMRCallback) ✅ ❌ ❌ ✅\nDomain hypercube mapped hypercube arbitrary arbitrary\nWeak form (VolumeIntegralWeakForm) ✅ ✅ ✅ ✅\nFlux differencing (VolumeIntegralFluxDifferencing) ✅ ✅ ✅ ✅\nShock capturing (VolumeIntegralShockCapturingHG) ✅ ❌ ❌ ❌","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"ᵃ: quad = quadrilateral, hex = hexahedron","category":"page"},{"location":"overview/#Time-integration-methods","page":"Overview","title":"Time integration methods","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Trixi is compatible with the SciML ecosystem for ordinary differential equations. In particular, a spatial semidiscretization can be wrapped in an ODE problem using semidiscretize, which returns an ODEProblem. This ODEProblem is a wrapper of Trixi.rhs!(du_ode, u_ode, semi, t), which gets called in ODE solvers. Further information can be found in the section on time integration methods.","category":"page"},{"location":"overview/#Next-steps","page":"Overview","title":"Next steps","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We explicitly encourage people interested in Trixi to have a look at the examples bundled with Trixi to get an impression of what is possible and the general look and feel of Trixi. Before doing that, it is usually good to get an idea of how to visualize numerical results.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If you like learning by doing, looking at the tutorials and trying to mix your own elixirs based thereon is probably a good next step. Otherwise, you can further dig into the documentation by looking at Trixi's basic building blocks.","category":"page"},{"location":"callbacks/#callbacks-id","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Many of the advanced features of Trixi, such as adaptive mesh refinement, are implemented as callbacks. A callback is an algorithmic entity that gets passed to the ODE solver and is called at specific points during execution to perform certain tasks. Callbacks in Trixi are either called after each time step (step callbacks) or after each stage of the ODE solver (stage callbacks).","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"(Image: callbacks_illustration)","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The advantage of callbacks over hard-coding all features is that it allows to extend Trixi without modifying the internal source code. Trixi provides callbacks for time step control, adaptive mesh refinement, I/O, and more.","category":"page"},{"location":"callbacks/#Step-callbacks","page":"Callbacks","title":"Step callbacks","text":"","category":"section"},{"location":"callbacks/#CFL-based-time-step-control","page":"Callbacks","title":"CFL-based time step control","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Time step control can be performed with a StepsizeCallback. An example making use of this can be found at examples/2d/elixir_advection_basic.jl","category":"page"},{"location":"callbacks/#Adaptive-mesh-refinement","page":"Callbacks","title":"Adaptive mesh refinement","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Trixi uses a hierarchical Cartesian mesh which can be locally refined in a solution-adaptive way. This can be used to speed up simulations with minimal loss in overall accuracy. Adaptive mesh refinement (AMR) can be used by passing an AMRCallback to the ODE solver. The AMRCallback requires a controller such as ControllerThreeLevel or ControllerThreeLevelCombined to tell the AMR algorithm which cells to refine/coarsen.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"An example elixir using AMR can be found at examples/2d/elixir_advection_amr.jl.","category":"page"},{"location":"callbacks/#Analyzing-the-numerical-solution","page":"Callbacks","title":"Analyzing the numerical solution","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The AnalysisCallback can be used to analyze the numerical solution, e.g. calculate errors or user-specified integrals, and print the results to the screen. The results can also be saved in a file. An example can be found at examples/2d/elixir_euler_vortex.jl.","category":"page"},{"location":"callbacks/#I/O","page":"Callbacks","title":"I/O","text":"","category":"section"},{"location":"callbacks/#Solution-and-restart-files","page":"Callbacks","title":"Solution and restart files","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"To save the solution in regular intervals you can use a SaveSolutionCallback. It is also possible to create restart files using the SaveRestartCallback. An example making use of these can be found at examples/2d/elixir_advection_extended.jl. An example showing how to restart a simulation from a restart file can be found at examples/2d/elixir_advection_restart.jl.","category":"page"},{"location":"callbacks/#Time-series","page":"Callbacks","title":"Time series","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Sometimes it is useful to record the evoluation of state variables over time at a given set of points. This can be achieved by the TimeSeriesCallback, which is used, e.g., in examples/2d/elixir_ape_gaussian_source.jl. The TimeSeriesCallback constructor expects a semidiscretization and a list of points at which the solution should be recorded in regular time step intervals. After the last time step, the entire record is stored in an HDF5 file.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"For the points, two different input formats are supported: You can either provide them as a list of tuples, which is handy if you specify them by hand on the REPL. Alternatively, you can provide them as a two-dimensional array, where the first dimension is the point number and the second dimension is the coordinate dimension. This is especially useful when reading them from a file.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"For example, to record the primitive variables at the points (0.0, 0.0) and (-1.0, 0.5) every five timesteps and storing the collected data in the file tseries.h5, you can create the TimeSeriesCallback as","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"time_series = TimeSeriesCallback(semi, [(0.0, 0.0), (-1.0, 0.5)];\n                                 interval=5,\n                                 solution_variables=cons2prim,\n                                 filename=\"tseries.h5\")","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"For a full list of possible arguments, please check the documentation for the TimeSeriesCallback. As an alternative to specifying the point coordinates directly in the elixir or on the REPL, you can read them from a file. For instance, with a text file points.dat with content","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":" 0.0 0.0\n-1.0 0.5","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"you can create a time series callback with","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"using DelimitedFiles: readdlm\ntime_series = TimeSeriesCallback(semi, readdlm(\"points.dat\"))","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"To plot the individual point data series over time, you can create a PlotData1D from the TimeSeriesCallback and a given point ID. For example, executing","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"julia> using Trixi, Plots\n\njulia> trixi_include(\"examples/2d/elixir_ape_gaussian_source.jl\")\n\njulia> pd1 = PlotData1D(time_series, 1)\n\njulia> pd2 = PlotData1D(time_series, 2)\n\njulia> plot(pd1[\"p_prime\"]); plot!(pd2[\"p_prime\"], xguide=\"t\")","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"will yield the following plot:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"(Image: image)","category":"page"},{"location":"callbacks/#Miscellaneous","page":"Callbacks","title":"Miscellaneous","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The AliveCallback prints some information to the screen to show that a simulation is still running.\nThe SummaryCallback prints a human-readable summary of the simulation setup and controls the automated performance measurements, including an output of the recorded timers after a simulation.\nThe VisualizationCallback can be used for in-situ visualization. See Visualizing results during a simulation.\nThe TrivialCallback does nothing and can be used to to easily disable some callbacks via trixi_include.","category":"page"},{"location":"callbacks/#Equation-specific-callbacks","page":"Callbacks","title":"Equation-specific callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Some callbacks provided by Trixi implement specific features for certain equations:","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The LBMCollisionCallback implements the Lattice-Boltzmann method (LBM) collision operator and should only be used when solving the Lattice-Boltzmann equations. See e.g. examples/2d/elixir_lbm_constant.jl\nThe SteadyStateCallback terminates the time integration when the residual steady state falls below a certain threshold. This checks the convergence of the potential phi for hyperbolic diffusion. See e.g. examples/2d/elixir_hypdiff_nonperiodic.jl.\nThe GlmSpeedCallback updates the divergence cleaning wave speed c_h for the ideal GLM-MHD equations. See e.g. examples/2d/elixir_mhd_alfven_wave.jl.","category":"page"},{"location":"callbacks/#Usage-of-step-callbacks","page":"Callbacks","title":"Usage of step callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Step callbacks are passed to the solve method from the ODE solver via the keyword argument callback. If you want to use a single callback cb, pass it as callback=cb. When using two or more callbacks, you need to turn them into a CallbackSet first by calling callbacks = CallbackSet(cb1, cb2) and passing it as callback=callbacks.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Note\nThere are some restrictions regarding the order of callbacks in a CallbackSet.The callbacks are called after each time step but some callbacks actually belong to the next time step. Therefore, the callbacks should be ordered in the following way:Callbacks that belong to the current time step:\nSummaryCallback controls, among other things, timers and should thus be first\nSteadyStateCallback may mark a time step as the last one\nAnalysisCallback may do some checks that mark a time step as the last one\nAliveCallback should be nearby AnalysisCallback\nSaveSolutionCallback/SaveRestartCallback should save the current solution before it is degraded by AMR\nVisualizationCallback should be called before the mesh is adapted\nCallbacks that belong to the next time step:\nAMRCallback\nStepsizeCallback must be called after AMRCallback to accomodate potential changes to the mesh\nGlmSpeedCallback must be called after StepsizeCallback because the step size affects the value of c_h\nLBMCollisionCallback is already part of the calculations of the next time step and should therefore be called after StepsizeCallback","category":"page"},{"location":"callbacks/#Stage-callbacks","page":"Callbacks","title":"Stage callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"PositivityPreservingLimiterZhangShu is a positivity-preserving limiter, used to enforce physical constraints. An example elixir using this feature can be found at examples/2d/elixir_euler_positivity.jl.","category":"page"},{"location":"callbacks/#Implementing-new-callbacks","page":"Callbacks","title":"Implementing new callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Since Trixi is compatible with OrdinaryDiffEq.jl, both packages share the same callback interface. A detailed description of it can be found in the OrdinaryDiffEq.jl documentation. Step callbacks are just called callbacks. Stage callbacks are called stage_limiter!.","category":"page"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"An example elixir showing how to implement a new simple stage callback and a new simple step callback can be found at examples/2d/elixir_advection_callbacks.jl.","category":"page"},{"location":"meshes/structured_mesh/#Structured-mesh","page":"Structured mesh","title":"Structured mesh","text":"","category":"section"},{"location":"meshes/structured_mesh/","page":"Structured mesh","title":"Structured mesh","text":"The StructuredMesh is a structured, curvilinear, conforming mesh type available for one-, two-, and three-dimensional simulations.","category":"page"},{"location":"meshes/structured_mesh/","page":"Structured mesh","title":"Structured mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"#Trixi.jl","page":"Home","title":"Trixi.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Trixi.jl is a numerical simulation framework for hyperbolic conservation laws written in Julia. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures. Its features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hierarchical quadtree/octree grid with adaptive mesh refinement\nNative support for 1D, 2D, and 3D simulations\nHigh-order accuracy in space in time\nNodal discontinuous Galerkin spectral element methods\nKinetic energy-preserving and entropy-stable split forms\nEntropy-stable shock capturing\nPositivity-preserving limiting\nCompatible with the SciML ecosystem for ordinary differential equations\nExplicit low-storage Runge-Kutta time integration\nStrong stability preserving methods\nCFL-based and error-based time step control\nSquare/cubic domains with periodic and weakly-enforced boundary conditions\nMultiple governing equations:\nCompressible Euler equations\nMagnetohydrodynamics equations\nHyperbolic diffusion equations for elliptic problems\nLattice-Boltzmann equations (D2Q9 and D3Q27 schemes)\nScalar advection\nMulti-physics simulations\nSelf-gravitating gas dynamics\nShared-memory parallelization via multithreading\nVisualization and postprocessing of the results\nIn-situ and a posteriori visualization with Plots.jl\nPostprocessing with ParaView/VisIt via Trixi2Vtk","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. Trixi works with Julia v1.6.","category":"page"},{"location":"#For-users","page":"Home","title":"For users","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Trixi and its related tools are registered Julia packages. Hence, you can install Trixi, the visualization tool Trixi2Vtk, OrdinaryDiffEq.jl, and Plots.jl by executing the following commands in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add([\"Trixi\", \"Trixi2Vtk\", \"OrdinaryDiffEq\", \"Plots\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can copy and paste all commands to the REPL including the leading julia> prompts - they will automatically be stripped away by Julia. The package OrdinaryDiffEq.jl provides time integration schemes used by Trixi, while Plots.jl can be used to directly visualize Trixi's results from the REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note on package versions: If some of the examples for how to use Trixi do not work, verify that you are using a recent Trixi release by comparing the installed Trixi version from","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.update(\"Trixi\"); Pkg.status(\"Trixi\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"to the latest release. If the installed version does not match the current release, please check the Troubleshooting section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The commands above can also be used to update Trixi. A brief list of notable changes to Trixi is available in NEWS.md.","category":"page"},{"location":"#for-developers","page":"Home","title":"For developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you plan on editing Trixi itself, you have two options: installing it as a dev package or cloning it to a local folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install Trixi as a dev package: You can install Trixi as a dev package by running\njulia> import Pkg\n\njulia> Pkg.develop(\"Trixi\")\nThis will download and install Trixi to a designated package development directory (usually .julia/dev, but you can determine the path on your system with Pkg.devdir()). As opposed to using the Pkg.add method as described above, packages installed via Pkg.develop may have their files edited locally.\nInstall Trixi in a local folder: Alternatively, you can download Trixi locally and use it from within the cloned directory:\ngit clone git@github.com:trixi-framework/Trixi.jl.git\ncd Trixi.jl\njulia --project=@. -e 'import Pkg; Pkg.instantiate()' # Install Trixi's dependencies\nThe last line can also be used to update the dependencies if they have changed since you first installed Trixi.\nIf you installed Trixi this way, you always have to start Julia with the --project flag set to your local Trixi clone, e.g.,\njulia --project=@.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Either way, since the postprocessing tool Trixi2Vtk typically does not need to be modified, it is recommended to install it as a normal package by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"Trixi2Vtk\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the Julia REPL. Likewise, you can install OrdinaryDiffEq.jl and Plots.jl as ordinary packages with the following REPL commands:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"OrdinaryDiffEq\"); Pkg.add(\"Plots\")","category":"page"},{"location":"#Example:-Installing-Trixi-as-a-package","page":"Home","title":"Example: Installing Trixi as a package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  <script id=\"asciicast-373869\"\n          src=\"https://asciinema.org/a/373869.js\"\n          async\n          data-cols=100\n          data-rows=20\n          data-speed=3></script>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that the playback speed is set to 3x, thus the entire installation procedure lasts around 45 seconds in real time (depending on the performance of your computer and on how many dependencies had already been installed before).","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package Trixi","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Trixi","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then start a simulation by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> trixi_include(default_example())","category":"page"},{"location":"","page":"Home","title":"Home","text":"To visualize the results, load the package Plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"and generate a heatmap plot of the results with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> plot(sol) # No trailing semicolon, otherwise no plot is shown","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will open a new window with a 2D visualization of the final solution:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The method trixi_include(...) expects a single string argument with the path to a Trixi elixir, i.e., a text file containing Julia code necessary to set up and run a simulation. To quickly see Trixi in action, default_example() returns the path to an example elixir with a short, two-dimensional problem setup. A list of all example elixirs packaged with Trixi can be obtained by running get_examples(). Alternatively, you can also browse the examples/ subdirectory. If you want to modify one of the elixirs to set up your own simulation, download it to your machine, edit the configuration, and pass the file path to trixi_include(...).","category":"page"},{"location":"#Example:-Running-a-simulation-with-Trixi","page":"Home","title":"Example: Running a simulation with Trixi","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  <script id=\"asciicast-372987\"\n          src=\"https://asciinema.org/a/372987.js\"\n          async\n          data-cols=100\n          data-rows=48></script>","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this produces weird symbols or question marks in the terminal on your system, you are probably using Mac OS with problematic fonts. In that case, please check the Troubleshooting section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note on performance: Julia uses just-in-time compilation to transform its source code to native, optimized machine code at the time of execution and caches the compiled methods for further use. That means that the first execution of a Julia method is typically slow, with subsequent runs being much faster. For instance, in the example above the first execution of trixi_include takes about 20 seconds, while subsequent runs require less than 60 milliseconds.","category":"page"},{"location":"#Performing-a-convergence-analysis","page":"Home","title":"Performing a convergence analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To automatically determine the experimental order of convergence (EOC) for a given setup, execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> convergence_test(default_example(), 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will run a convergence test with the elixir default_example(), using four iterations with different initial refinement levels. The initial iteration will use the elixir unchanged, while for each subsequent iteration the initial_refinement_level parameter is incremented by one. Finally, the measured l^2 and l^infty errors and the determined EOCs will be displayed like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[...]\nl2\nscalar\nerror     EOC\n9.14e-06  -\n5.69e-07  4.01\n3.55e-08  4.00\n2.22e-09  4.00\n\nmean      4.00\n--------------------------------------------------------------------------------\nlinf\nscalar\nerror     EOC\n6.44e-05  -\n4.11e-06  3.97\n2.58e-07  3.99\n1.62e-08  4.00\n\nmean      3.99\n--------------------------------------------------------------------------------","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example with multiple variables looks like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> convergence_test(joinpath(examples_dir(), \"2d\", \"elixir_euler_source_terms.jl\"), 3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"[...]\nl2\nrho                 rho_v1              rho_v2              rho_e\nerror     EOC       error     EOC       error     EOC       error     EOC\n8.52e-07  -         1.24e-06  -         1.24e-06  -         4.28e-06  -\n6.49e-08  3.71      8.38e-08  3.88      8.38e-08  3.88      2.96e-07  3.85\n4.33e-09  3.91      5.39e-09  3.96      5.39e-09  3.96      1.93e-08  3.94\n\nmean      3.81      mean      3.92      mean      3.92      mean      3.90\n--------------------------------------------------------------------------------\nlinf\nrho                 rho_v1              rho_v2              rho_e\nerror     EOC       error     EOC       error     EOC       error     EOC\n8.36e-06  -         1.03e-05  -         1.03e-05  -         4.50e-05  -\n5.58e-07  3.90      6.58e-07  3.97      6.58e-07  3.97      2.92e-06  3.94\n3.77e-08  3.89      4.42e-08  3.90      4.42e-08  3.90      1.91e-07  3.93\n\nmean      3.90      mean      3.93      mean      3.93      mean      3.94\n--------------------------------------------------------------------------------","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Trixi in your own research or write a paper using results obtained with the help of Trixi, please cite the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{schlottkelakemper2021purely,\n  title={A purely hyperbolic discontinuous {G}alerkin approach for\n         self-gravitating gas dynamics},\n  author={Schlottke-Lakemper, Michael and Winters, Andrew R and\n          Ranocha, Hendrik and Gassner, Gregor J},\n  journal={Journal of Computational Physics},\n  pages={110467},\n  year={2021},\n  month={06},\n  publisher={Elsevier},\n  doi={10.1016/j.jcp.2021.110467},\n  eprint={2008.10593},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, you can also refer to Trixi directly as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{schlottkelakemper2020trixi,\n  title={{T}rixi.jl: A tree-based numerical simulation framework\n         for hyperbolic {PDE}s written in {J}ulia},\n  author={Schlottke-Lakemper, Michael and Gassner, Gregor J and\n          Ranocha, Hendrik and Winters, Andrew R},\n  year={2020},\n  month={08},\n  howpublished={\\url{https://github.com/trixi-framework/Trixi.jl}},\n  doi={10.5281/zenodo.3996439}\n}","category":"page"},{"location":"#authors-index-md","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Trixi was initiated by Michael Schlottke-Lakemper and Gregor Gassner (both University of Cologne, Germany). Together with Hendrik Ranocha (University of Münster, Germany) and Andrew Winters (Linköping University, Sweden), they are the principal developers of Trixi. The full list of contributors can be found under Authors.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Trixi is licensed under the MIT license (see License). Since Trixi is an open-source project, we are very happy to accept contributions from the community. Please refer to Contributing for more details. To get in touch with the developers, join us on Slack or create an issue.","category":"page"},{"location":"reference-trixi2vtk/#Trixi2Vtk.jl-API","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl API","text":"","category":"section"},{"location":"reference-trixi2vtk/","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl","text":"CurrentModule = Trixi2Vtk","category":"page"},{"location":"reference-trixi2vtk/","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl","text":"Modules = [Trixi2Vtk]","category":"page"},{"location":"reference-trixi2vtk/#Trixi2Vtk.trixi2vtk-Tuple{Vararg{AbstractString, N} where N}","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.trixi2vtk","text":"trixi2vtk(filename::AbstractString...;\n          format=:vtu, verbose=false, hide_progress=false, pvd=nothing,\n          output_directory=\".\", nvisnodes=nothing)\n\nConvert Trixi-generated output files to VTK files (VTU or VTI).\n\nArguments\n\nfilename: One or more Trixi solution/restart/mesh files to convert to a VTK file.             Filenames support file globbing, e.g., \"solution*\" to match all files starting             with solution.\nformat: Output format for solution/restart files. Can be 'vtu' or 'vti'.\nverbose: Set to true to enable verbose output.\nhide_progress: Hide progress bar (will be hidden automatically if verbose is true).\npvd: Use this filename to store PVD file (instead of auto-detecting name). Note that        only the name will be used (directory and file extension are ignored).\noutput_directory: Output directory where generated files are stored.\nnvisnodes: Number of visualization nodes per element.              (default: number of DG nodes for StructuredMesh or UnstructuredMesh2D,                        twice the number of DG nodes for TreeMesh).              A value of 0 (zero) uses the number of nodes in the DG elements.\nsave_celldata: Boolean value to determine if cell-based data should be saved.                  (the default nothing is converted to false                  for StructuredMesh/UnstructuredMesh2D and true for TreeMesh)\n\nExamples\n\njulia> trixi2vtk(\"out/solution_000*.h5\")\n[...]\n\n\n\n\n\n","category":"method"},{"location":"time_integration/#time-integration","page":"Time integration","title":"Time integration methods","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"Trixi is compatible with the SciML ecosystem for ordinary differential equations. In particular, explicit Runge-Kutta methods from OrdinaryDiffEq.jl are tested extensively. Interesting classes of time integration schemes are","category":"page"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"Explicit low-storage Runge-Kutta methods\nStrong stability preserving methods","category":"page"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"Some common options for solve from OrdinaryDiffEq.jl are the following. Further documentation can be found in the SciML docs.","category":"page"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"If you use a fixed time step method like CarpenterKennedy2N54, you need to pass a time step as dt=.... If you use a StepsizeCallback, the value passed as dt=... is irrelevant since it will be overwritten by the StepsizeCallback.\nYou should usually set save_everystep=false. Otherwise, OrdinaryDiffEq.jl will (try to) save the numerical solution after every time step in RAM (until you run out of memory or start to swap).\nYou can set the maximal number of time steps via maxiters=....\nSSP methods and 2N low-storage methods from OrdinaryDiffEq.jl support stage_limiter!s and step_limiter!s, e.g. PositivityPreservingLimiterZhangShu from Trixi.","category":"page"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"note: Number of `rhs!` calls\nIf you use explicit Runge-Kutta methods from OrdinaryDiffEq.jl, the total number of rhs! calls can be (slightly) bigger than the number of steps times the number of stages, e.g. to allow for interpolation (dense output), root-finding for continuous callbacks, and error-based time step control. In general, you often should not need to worry about this if you use Trixi.","category":"page"}]
}
