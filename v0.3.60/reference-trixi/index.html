<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trixi.jl · Trixi.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Trixi.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Trixi.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Adding a new equation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../adding_new_equations/cubic_conservation_law/">Scalar conservation law</a></li><li><a class="tocitem" href="../adding_new_equations/nonconservative_advection/">Nonconservative equation</a></li></ul></li><li><a class="tocitem" href="../differentiable_programming/">Differentiable programming</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../meshes/mesh_data_meshes/">Simplicial mesh</a></li></ul></li><li><a class="tocitem" href="../time_integration/">Time integration</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../conventions/">Conventions</a></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../styleguide/">Style guide</a></li><li><a class="tocitem" href="../testing/">Testing</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Trixi.jl</a></li><li><a class="tocitem" href="../reference-trixi2vtk/">Trixi2Vtk.jl</a></li><li><a class="tocitem" href="../reference-trixi2img/">Trixi2Img.jl</a></li></ul></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Trixi.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Trixi.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/trixi-framework/Trixi.jl/blob/master/docs/src/reference-trixi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Trixi.jl-API"><a class="docs-heading-anchor" href="#Trixi.jl-API">Trixi.jl API</a><a id="Trixi.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#Trixi.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Trixi.Trixi" href="#Trixi.Trixi"><code>Trixi.Trixi</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Trixi</code></pre><p><strong>Trixi.jl</strong> is a numerical simulation framework for hyperbolic conservation laws. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures.</p><p>To get started, run your first simulation with Trixi using</p><pre><code class="nohighlight hljs">trixi_include(default_example())</code></pre><p>See also: <a href="https://github.com/trixi-framework/Trixi.jl">trixi-framework/Trixi.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/Trixi.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_periodic" href="#Trixi.boundary_condition_periodic"><code>Trixi.boundary_condition_periodic</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_periodic = BoundaryConditionPeriodic()</code></pre><p>A singleton struct indicating periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/basic_types.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hll" href="#Trixi.flux_hll"><code>Trixi.flux_hll</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">flux_hll</code></pre><p>See <a href="#Trixi.FluxHLL"><code>FluxHLL</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_lax_friedrichs" href="#Trixi.flux_lax_friedrichs"><code>Trixi.flux_lax_friedrichs</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">flux_lax_friedrichs</code></pre><p>See <a href="#Trixi.FluxLaxFriedrichs"><code>FluxLaxFriedrichs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AMRCallback" href="#Trixi.AMRCallback"><code>Trixi.AMRCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AMRCallback(semi, controller [,adaptor=AdaptorAMR(semi)];
            interval,
            adapt_initial_condition=true,
            adapt_initial_condition_only_refine=true)</code></pre><p>Performs adaptive mesh refinement (AMR) every <code>interval</code> time steps for a given semidiscretization <code>semi</code> using the chosen <code>controller</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/amr.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AbstractEquations" href="#Trixi.AbstractEquations"><code>Trixi.AbstractEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEquations{NDIMS, NVARS}</code></pre><p>An abstract supertype of specific equations such as the compressible Euler equations. The type parameters encode the number of spatial dimensions (<code>NDIMS</code>) and the number of primary variables (<code>NVARS</code>) of the physics model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/basic_types.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AbstractMesh" href="#Trixi.AbstractMesh"><code>Trixi.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{NDIMS}</code></pre><p>An abstract supertype of specific mesh types such as <code>TreeMesh</code> or <code>StructuredMesh</code>. The type parameters encode the number of spatial dimensions (<code>NDIMS</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/basic_types.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AcousticPerturbationEquations2D" href="#Trixi.AcousticPerturbationEquations2D"><code>Trixi.AcousticPerturbationEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AcousticPerturbationEquations2D(v_mean_global, c_mean_global, rho_mean_global)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This system of equations is experimental and may change in any future release.</p></div></div><p>Acoustic perturbation equations (APE) in two space dimensions. The equations are given by</p><p class="math-container">\[\begin{aligned}
  \frac{\partial\mathbf{v&#39;}}{\partial t} + \nabla (\bar{\mathbf{v}}\cdot\mathbf{v&#39;})
    + \nabla\left( \frac{p&#39;}{\bar{\rho}} \right) &amp;= 0 \\
  \frac{\partial p&#39;}{\partial t} + \nabla\cdot (\bar{c}^2 \bar{\rho}^2 \mathbf{v&#39;} + \bar{v} p&#39;)
    &amp;= \left( \bar{\rho}\mathbf{v&#39;} + \bar{\mathbf{v}}\frac{p&#39;}{\bar{c}^2} \right)\cdot\nabla\bar{c}^2.
\end{aligned}\]</p><p>The bar <span>$\bar{(\cdot)}$</span> indicates time-averaged quantities. The unknowns of the APE are the perturbed velocities <span>$\mathbf{v&#39;} = (v_1&#39;, v_2&#39;)^T$</span> and the perturbed pressure <span>$p&#39;$</span>, where perturbed variables are defined by <span>$\phi&#39; = \phi - \bar{\phi}$</span>.</p><p>Note that the source term must be defined separately and passed manually to <a href="#Trixi.SemidiscretizationHyperbolic"><code>SemidiscretizationHyperbolic</code></a>.</p><p>In addition to the unknowns, Trixi currently stores the mean values in the state vector, i.e. the state vector used internally is given by</p><p class="math-container">\[\mathbf{u} =
  \begin{pmatrix}
    v_1&#39; \\ v_2&#39; \\ p&#39; \\ \bar{v_1} \\ \bar{v_2} \\ \bar{c} \\ \bar{\rho}
  \end{pmatrix}.\]</p><p>This affects the implementation and use of these equations in various ways:</p><ul><li>The flux values corresponding to the mean values must be zero.</li><li>The mean values have to be considered when defining initial conditions, boundary conditions or source terms.</li><li><a href="#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> analyzes these variables too.</li><li>Trixi&#39;s visualization tools will visualize the mean values by default.</li></ul><p>The constructor accepts a 2-tuple <code>v_mean_global</code> and scalars <code>c_mean_global</code> and <code>rho_mean_global</code> which can be used to make the definition of initial conditions for problems with constant mean flow more flexible. These values are ignored if the mean values are defined internally in an initial condition.</p><p>The equations are based on the APE-4 system introduced in the following paper:</p><ul><li>Roland Ewert and Wolfgang Schröder (2003) Acoustic perturbation equations based on flow decomposition via source filtering <a href="https://doi.org/10.1016/S0021-9991(03)00168-2">DOI: 10.1016/S0021-9991(03)00168-2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L8-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AliveCallback" href="#Trixi.AliveCallback"><code>Trixi.AliveCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AliveCallback(analysis_interval=0, alive_interval=analysis_interval÷10)</code></pre><p>Inexpensive callback showing that a simulation is still running by printing some information such as the current time to the screen every <code>alive_interval</code> time steps. If <code>analysis_interval ≂̸ 0</code>, the output is omitted every <code>analysis_interval</code> time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/alive.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.AnalysisCallback" href="#Trixi.AnalysisCallback"><code>Trixi.AnalysisCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalysisCallback(semi; interval=0,
                       save_analysis=false,
                       output_directory=&quot;out&quot;,
                       analysis_filename=&quot;analysis.dat&quot;,
                       extra_analysis_errors=Symbol[],
                       extra_analysis_integrals=())</code></pre><p>Analyze a numerical solution every <code>interval</code> time steps and print the results to the screen. If <code>save_analysis</code>, the results are also saved in <code>joinpath(output_directory, analysis_filename)</code>.</p><p>Additional errors can be computed, e.g. by passing <code>extra_analysis_errors = [:primitive]</code>.</p><p>Further scalar functions <code>func</code> in <code>extra_analysis_integrals</code> are applied to the numerical solution and integrated over the computational domain. See <code>Trixi.analyze</code>, <code>Trixi.pretty_form_utf</code>, <code>Trixi.pretty_form_ascii</code> for further information on how to create custom analysis quantities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/analysis.jl#L10-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.BoundaryConditionDirichlet" href="#Trixi.BoundaryConditionDirichlet"><code>Trixi.BoundaryConditionDirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditionDirichlet(boundary_value_function)</code></pre><p>Create a Dirichlet boundary condition that uses the function <code>boundary_value_function</code> to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as</p><pre><code class="language-julia hljs">boundary_value_function(x, t, equations)</code></pre><p>where <code>x</code> specifies the coordinates, <code>t</code> is the current time, and <code>equation</code> is the corresponding system of equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; BoundaryConditionDirichlet(initial_condition_convergence_test)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L100-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.BoundaryConditionWall" href="#Trixi.BoundaryConditionWall"><code>Trixi.BoundaryConditionWall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryConditionWall(boundary_value_function)</code></pre><p>Create a generic wall type boundary condition that uses the function <code>boundary_value_function</code> to specify the external solution values. The boundary wall function is called with arguments for an internal solution state from inside an element <code>u_inner</code>, an outward pointing <code>normal_direction</code> and a particular set of <code>equations</code>, e.g.,</p><pre><code class="language-julia hljs">boundary_value_function(u_inner, normal_direction, equations)</code></pre><p>which will return an external solution state.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; BoundaryConditionWall(boundary_state_slip_wall)</code></pre><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This boundary condition can change any time and is currently only implemented for the <a href="#Trixi.CompressibleEulerEquations2D"><code>CompressibleEulerEquations2D</code></a> and <a href="#Trixi.AcousticPerturbationEquations2D"><code>AcousticPerturbationEquations2D</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L154-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CarpenterKennedy2N43" href="#Trixi.CarpenterKennedy2N43"><code>Trixi.CarpenterKennedy2N43</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  CarpenterKennedy2N43()</code></pre><p>Carpenter, Kennedy (1994) Third order 2N storage RK schemes with error control</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/time_integration/methods_2N.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CarpenterKennedy2N54" href="#Trixi.CarpenterKennedy2N54"><code>Trixi.CarpenterKennedy2N54</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CarpenterKennedy2N54()</code></pre><p>The following structures and methods provide a minimal implementation of the low-storage explicit Runge-Kutta method of</p><pre><code class="nohighlight hljs">Carpenter, Kennedy (1994) Fourth order 2N storage RK schemes, Solution 3</code></pre><p>using the same interface as OrdinaryDiffEq.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/time_integration/methods_2N.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CompressibleEulerEquations1D" href="#Trixi.CompressibleEulerEquations1D"><code>Trixi.CompressibleEulerEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations1D(gamma)</code></pre><p>The compressible Euler equations for an ideal gas with ratio of specific heats <code>gamma</code> in one space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CompressibleEulerEquations2D" href="#Trixi.CompressibleEulerEquations2D"><code>Trixi.CompressibleEulerEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations2D(gamma)</code></pre><p>The compressible Euler equations for an ideal gas with ratio of specific heats <code>gamma</code> in two space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CompressibleEulerEquations3D" href="#Trixi.CompressibleEulerEquations3D"><code>Trixi.CompressibleEulerEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerEquations3D(gamma)</code></pre><p>The compressible Euler equations for an ideal gas with ratio of specific heats <code>gamma</code> in three space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CompressibleEulerMulticomponentEquations1D" href="#Trixi.CompressibleEulerMulticomponentEquations1D"><code>Trixi.CompressibleEulerMulticomponentEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerMulticomponentEquations1D(; gammas, gas_constants)</code></pre><p>Multicomponent version of the compressible Euler equations</p><p class="math-container">\[\partial t
\begin{pmatrix}
\rho v_1 \\ E \\ \rho_1 \\ \rho_2 \\ \vdots \\ \rho_{n}
\end{pmatrix}
+
\partial x
\begin{pmatrix}
\rho v_1 \\ \rho v_1^2 + p \\ (E+p) v_1 \\ \rho_1 v_1 \\ \rho_2 v_1 \\ \vdots \\ \rho_{n} v_1
\end{pmatrix}

=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}\]</p><p>for calorically perfect gas in one space dimension.</p><p>In case of more than one component, the specific heat ratios <code>gammas</code> and the gas constants <code>gas_constants</code> should be passed as tuples, e.g., <code>gammas=(1.4, 1.667)</code>.</p><p>The remaining variables like the specific heats at constant volume &#39;cv&#39; or the specific heats at constant pressure &#39;cp&#39; are then calculated considering a calorically perfect gas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L8-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.CompressibleEulerMulticomponentEquations2D" href="#Trixi.CompressibleEulerMulticomponentEquations2D"><code>Trixi.CompressibleEulerMulticomponentEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompressibleEulerMulticomponentEquations2D(; gammas, gas_constants)</code></pre><p>Multicomponent version of the compressible Euler equations</p><p class="math-container">\[\partial t
\begin{pmatrix}
\rho v_1 \\ \rho v_2 \\ E \\ \rho_1 \\ \rho_2 \\ \vdots \\ \rho_{n}
\end{pmatrix}
+
\partial x
\begin{pmatrix}
\rho v_1^2 + p \\ \rho v_1 v_2 \\ (E+p) v_1 \\ \rho_1 v_1 \\ \rho_2 v_1 \\ \vdots \\ \rho_{n} v_1
\end{pmatrix}
+
\partial y
\begin{pmatrix}
\rho v_1 v_2 \\ \rho v_2^2 + p \\ (E+p) v_2 \\ \rho_1 v_2 \\ \rho_2 v_2 \\ \vdots \\ \rho_{n} v_2
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}\]</p><p>for calorically perfect gas in two space dimensions.</p><p>In case of more than one component, the specific heat ratios <code>gammas</code> and the gas constants <code>gas_constants</code> in [kJ/(kg*K)] should be passed as tuples, e.g., <code>gammas=(1.4, 1.667)</code>.</p><p>The remaining variables like the specific heats at constant volume &#39;cv&#39; or the specific heats at constant pressure &#39;cp&#39; are then calculated considering a calorically perfect gas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ControllerThreeLevel" href="#Trixi.ControllerThreeLevel"><code>Trixi.ControllerThreeLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ControllerThreeLevel(semi, indicator; base_level=1,
                                      med_level=base_level, med_threshold=0.0,
                                      max_level=base_level, max_threshold=1.0)</code></pre><p>An AMR controller based on three levels (in decending order of precedence):</p><ul><li>set the target level to <code>max_level</code> if <code>indicator &gt; max_threshold</code></li><li>set the target level to <code>med_level</code> if <code>indicator &gt; med_threshold</code>; if <code>med_level &lt; 0</code>, set the target level to the current level</li><li>set the target level to <code>base_level</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/amr.jl#L462-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ControllerThreeLevelCombined" href="#Trixi.ControllerThreeLevelCombined"><code>Trixi.ControllerThreeLevelCombined</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ControllerThreeLevelCombined(semi, indicator_primary, indicator_secondary;
                             base_level=1,
                             med_level=base_level, med_threshold=0.0,
                             max_level=base_level, max_threshold=1.0,
                             max_threshold_secondary=1.0)</code></pre><p>An AMR controller based on three levels (in decending order of precedence):</p><ul><li>set the target level to <code>max_level</code> if <code>indicator_primary &gt; max_threshold</code></li><li>set the target level to <code>med_level</code> if <code>indicator_primary &gt; med_threshold</code>; if <code>med_level &lt; 0</code>, set the target level to the current level</li><li>set the target level to <code>base_level</code> otherwise</li></ul><p>If <code>indicator_secondary &gt;= max_threshold_secondary</code>, set the target level to <code>max_level</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/amr.jl#L626-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.DG" href="#Trixi.DG"><code>Trixi.DG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DG(; basis, mortar, surface_integral, volume_integral)</code></pre><p>Create a discontinuous Galerkin method. If <a href="#Trixi.LobattoLegendreBasis"><code>basis isa LobattoLegendreBasis</code></a>, this creates a <a href="#Trixi.DGSEM"><code>DGSEM</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.DGMulti-Tuple{}" href="#Trixi.DGMulti-Tuple{}"><code>Trixi.DGMulti</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DGMulti(; polydeg::Integer,
          element_type::AbstractElemShape,
          approximation_type=Polynomial(),
          surface_flux=flux_central,
          surface_integral=SurfaceIntegralWeakForm(surface_flux),
          volume_integral=VolumeIntegralWeakForm(),
          RefElemData_kwargs...)</code></pre><p>Create a discontinuous Galerkin method which uses</p><ul><li>approximations of polynomial degree <code>polydeg</code></li><li>element type <code>element_type</code> (<code>Tri()</code>, <code>Quad()</code>, <code>Tet()</code>, and <code>Hex()</code> currently supported)</li></ul><p>Optional:</p><ul><li><code>approximation_type</code> (default is <code>Polynomial()</code>; <code>SBP()</code> also supported for <code>Tri()</code>, <code>Quad()</code>, and <code>Hex()</code> element types).</li><li><code>RefElemData_kwargs</code> are additional keyword arguments for <code>RefElemData</code>, such as <code>quad_rule_vol</code>. For more info, see the <a href="https://jlchan.github.io/StartUpDG.jl/dev/">StartUpDG.jl docs</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgmulti/types.jl#L18-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.DGSEM" href="#Trixi.DGSEM"><code>Trixi.DGSEM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DGSEM(; RealT=Float64, polydeg::Integer,
        surface_flux=flux_central,
        surface_integral=SurfaceIntegralWeakForm(surface_flux),
        volume_integral=VolumeIntegralWeakForm(),
        mortar=MortarL2(basis))</code></pre><p>Create a discontinuous Galerkin spectral element method (DGSEM) using a <a href="#Trixi.LobattoLegendreBasis"><code>LobattoLegendreBasis</code></a> with polynomials of degree <code>polydeg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem/dgsem.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.DissipationGlobalLaxFriedrichs" href="#Trixi.DissipationGlobalLaxFriedrichs"><code>Trixi.DissipationGlobalLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DissipationGlobalLaxFriedrichs(λ)</code></pre><p>Create a global Lax-Friedrichs dissipation operator with dissipation coefficient <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.DissipationLocalLaxFriedrichs" href="#Trixi.DissipationLocalLaxFriedrichs"><code>Trixi.DissipationLocalLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DissipationLocalLaxFriedrichs(max_abs_speed=max_abs_speed_naive)</code></pre><p>Create a local Lax-Friedrichs dissipation operator where the maximum absolute wave speed is estimated as <code>max_abs_speed(u_ll, u_rr, orientation_or_normal_direction, equations)</code>, defaulting to <a href="#Trixi.max_abs_speed_naive"><code>max_abs_speed_naive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.FluxHLL" href="#Trixi.FluxHLL"><code>Trixi.FluxHLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxHLL(min_max_speed=min_max_speed_naive)</code></pre><p>Create an HLL (Harten, Lax, van Leer) numerical flux where the minimum and maximum wave speeds are estimated as <code>λ_min, λ_max = min_max_speed(u_ll, u_rr, orientation_or_normal_direction, equations)</code>, defaulting to <a href="#Trixi.min_max_speed_naive"><code>min_max_speed_naive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L190-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.FluxLaxFriedrichs" href="#Trixi.FluxLaxFriedrichs"><code>Trixi.FluxLaxFriedrichs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxLaxFriedrichs(max_abs_speed=max_abs_speed_naive)</code></pre><p>Local Lax-Friedrichs (Rusanov) flux with maximum wave speed estimate provided by <code>max_abs_speed</code>, cf. <a href="#Trixi.DissipationLocalLaxFriedrichs"><code>DissipationLocalLaxFriedrichs</code></a> and <a href="#Trixi.max_abs_speed_naive"><code>max_abs_speed_naive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.FluxPlusDissipation" href="#Trixi.FluxPlusDissipation"><code>Trixi.FluxPlusDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxPlusDissipation(numerical_flux, dissipation)</code></pre><p>Combine a <code>numerical_flux</code> with a <code>dissipation</code> operator to create a new numerical flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.FluxRotated" href="#Trixi.FluxRotated"><code>Trixi.FluxRotated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxRotated(numerical_flux)</code></pre><p>Compute a <code>numerical_flux</code> flux in direction of a normal vector by rotating the solution, computing the numerical flux in x-direction, and rotating the calculated flux back.</p><p>Requires a rotationally invariant equation with equation-specific functions <a href="#Trixi.rotate_to_x"><code>rotate_to_x</code></a> and <a href="#Trixi.rotate_from_x"><code>rotate_from_x</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This flux is experimental and is likely to change in a future release. Do not use it in production code.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.GlmSpeedCallback" href="#Trixi.GlmSpeedCallback"><code>Trixi.GlmSpeedCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GlmSpeedCallback(; glm_scale=0.5, cfl)</code></pre><p>Update the divergence cleaning wave speed <code>c_h</code> according to the time step computed in <a href="#Trixi.StepsizeCallback"><code>StepsizeCallback</code></a> for the ideal GLM-MHD equations. The <code>cfl</code> number should be set to the same value as for the time step size calculation. The <code>glm_scale</code> ensures that the GLM wave speed is lower than the fastest physical waves in the MHD solution and should thus be set to a value within the interval [0,1]. Note that <code>glm_scale = 0</code> deactivates the divergence cleaning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/glm_speed.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.HypDiffN3Erk3Sstar52" href="#Trixi.HypDiffN3Erk3Sstar52"><code>Trixi.HypDiffN3Erk3Sstar52</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HypDiffN3Erk3Sstar52()</code></pre><p>Five stage, second-order acurate explicit Runge-Kutta scheme with stability region optimized for the hyperbolic diffusion equation with LLF flux and polynomials of degree polydeg=3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/time_integration/methods_3Sstar.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations1D" href="#Trixi.HyperbolicDiffusionEquations1D"><code>Trixi.HyperbolicDiffusionEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations1D</code></pre><p>The linear hyperbolic diffusion equations in one space dimension. A description of this system can be found in Sec. 2.5 of the book</p><ul><li>Masatsuka (2013) I Do Like CFD, Too: Vol 1. Freely available at <a href="http://www.cfdbooks.com/">http://www.cfdbooks.com/</a></li></ul><p>Further analysis can be found in the paper</p><ul><li>Nishikawa (2007) A first-order system approach for diffusion equation. I: Second-order residual-distribution schemes <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations2D" href="#Trixi.HyperbolicDiffusionEquations2D"><code>Trixi.HyperbolicDiffusionEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations2D</code></pre><p>The linear hyperbolic diffusion equations in two space dimensions. A description of this system can be found in Sec. 2.5 of the book &quot;I Do Like CFD, Too: Vol 1&quot;. The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_2d.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.HyperbolicDiffusionEquations3D" href="#Trixi.HyperbolicDiffusionEquations3D"><code>Trixi.HyperbolicDiffusionEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperbolicDiffusionEquations3D</code></pre><p>The linear hyperbolic diffusion equations in three space dimensions. A description of this system can be found in Sec. 2.5 of the book &quot;I Do Like CFD, Too: Vol 1&quot;. The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa <a href="https://doi.org/10.1016/j.jcp.2007.07.029">DOI: 10.1016/j.jcp.2007.07.029</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_3d.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations1D" href="#Trixi.IdealGlmMhdEquations1D"><code>Trixi.IdealGlmMhdEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations1D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in one space dimension.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is no divergence cleaning variable <code>psi</code> because the divergence-free constraint is satisfied trivially in one spatial dimension.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations2D" href="#Trixi.IdealGlmMhdEquations2D"><code>Trixi.IdealGlmMhdEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations2D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in two space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IdealGlmMhdEquations3D" href="#Trixi.IdealGlmMhdEquations3D"><code>Trixi.IdealGlmMhdEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdEquations3D(gamma)</code></pre><p>The ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats <code>gamma</code> in three space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IdealGlmMhdMulticomponentEquations1D" href="#Trixi.IdealGlmMhdMulticomponentEquations1D"><code>Trixi.IdealGlmMhdMulticomponentEquations1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdMulticomponentEquations1D</code></pre><p>The ideal compressible multicomponent GLM-MHD equations in one space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IdealGlmMhdMulticomponentEquations2D" href="#Trixi.IdealGlmMhdMulticomponentEquations2D"><code>Trixi.IdealGlmMhdMulticomponentEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdealGlmMhdMulticomponentEquations2D</code></pre><p>The ideal compressible multicomponent GLM-MHD equations in two space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IndicatorHennemannGassner" href="#Trixi.IndicatorHennemannGassner"><code>Trixi.IndicatorHennemannGassner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorHennemannGassner</code></pre><p>Indicator used for shock-capturing or AMR used by</p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem_tree/indicators.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.IndicatorLöhner" href="#Trixi.IndicatorLöhner"><code>Trixi.IndicatorLöhner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndicatorLöhner (equivalent to IndicatorLoehner)</code></pre><p>AMR indicator adapted from a FEM indicator by Löhner (1987), also used in the FLASH code as standard AMR indicator. The indicator estimates a weighted second derivative of a specified variable locally.</p><ul><li>Löhner (1987) &quot;An adaptive finite element scheme for transient problems in CFD&quot; <a href="https://doi.org/10.1016/0045-7825(87)90098-3">doi: 10.1016/0045-7825(87)90098-3</a></li><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node59.html#SECTION05163100000000000000</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem_tree/indicators.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.InviscidBurgersEquation1D" href="#Trixi.InviscidBurgersEquation1D"><code>Trixi.InviscidBurgersEquation1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InviscidBurgersEquation1D</code></pre><p>The inviscid Burgers&#39; equation</p><p class="math-container">\[\partial_t u + \frac{1}{2} \partial_1 u^2 = 0\]</p><p>in one space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/inviscid_burgers_1d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LatticeBoltzmannEquations2D" href="#Trixi.LatticeBoltzmannEquations2D"><code>Trixi.LatticeBoltzmannEquations2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeBoltzmannEquations2D(; Ma, Re, collision_op=collision_bgk,
                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)</code></pre><p>The Lattice-Boltzmann equations</p><p class="math-container">\[\partial_t u_\alpha + v_{\alpha,1} \partial_1 u_\alpha + v_{\alpha,2} \partial_2 u_\alpha = 0\]</p><p>in two space dimensions for the D2Q9 scheme.</p><p>The characteristic Mach number and Reynolds numbers are specified as <code>Ma</code> and <code>Re</code>. By the default, the collision operator <code>collision_op</code> is set to the BGK model. <code>c</code>, <code>L</code>, and <code>rho0</code> specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity <code>u0</code> directly (<code>Ma</code> needs to be set to <code>nothing</code> in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity <code>nu</code> directly (in this case, <code>Re</code> needs to be set to <code>nothing</code>).</p><p>The nine discrete velocity directions of the D2Q9 scheme are sorted as follows [4]:</p><pre><code class="nohighlight hljs">  6     2     5       y
    ┌───┼───┐         │
    │       │         │
  3 ┼   9   ┼ 1        ──── x
    │       │        ╱
    └───┼───┘       ╱
  7     4     8    z</code></pre><p>Note that usually the velocities are numbered from <code>0</code> to <code>8</code>, where <code>0</code> corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from <code>1</code> to <code>9</code>, where <code>1</code> through <code>8</code> correspond to the velocity directions in [4] and <code>9</code> is the zero velocity.</p><p>The corresponding opposite directions are:</p><ul><li>1 ←→ 3</li><li>2 ←→ 4</li><li>3 ←→ 1</li><li>4 ←→ 2</li><li>5 ←→ 7</li><li>6 ←→ 8</li><li>7 ←→ 5</li><li>8 ←→ 6</li><li>9 ←→ 9</li></ul><p>The main sources for the base implementation were</p><ol><li>Misun Min, Taehun Lee, <strong>A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows</strong>, J Comput Phys 230(1), 2011 <a href="https://doi.org/10.1016/j.jcp.2010.09.024">doi:10.1016/j.jcp.2010.09.024</a></li><li>Karsten Golly, <strong>Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum</strong>, Master Thesis, University of Cologne, 2018.</li><li>Dieter Hänel, <strong>Molekulare Gasdynamik</strong>, Springer-Verlag Berlin Heidelberg, 2004 <a href="https://doi.org/10.1007/3-540-35047-0">doi:10.1007/3-540-35047-0</a></li><li>Dieter Krüger et al., <strong>The Lattice Boltzmann Method</strong>, Springer International Publishing, 2017 <a href="https://doi.org/10.1007/978-3-319-44649-3">doi:10.1007/978-3-319-44649-3</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L8-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LatticeBoltzmannEquations3D" href="#Trixi.LatticeBoltzmannEquations3D"><code>Trixi.LatticeBoltzmannEquations3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeBoltzmannEquations3D(; Ma, Re, collision_op=collision_bgk,
                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)</code></pre><p>The Lattice-Boltzmann equations</p><p class="math-container">\[\partial_t u_\alpha + v_{\alpha,1} \partial_1 u_\alpha + v_{\alpha,2} \partial_2 u_\alpha + v_{\alpha,3} \partial_3 u_\alpha = 0\]</p><p>in three space dimensions for the D3Q27 scheme.</p><p>The characteristic Mach number and Reynolds numbers are specified as <code>Ma</code> and <code>Re</code>. By the default, the collision operator <code>collision_op</code> is set to the BGK model. <code>c</code>, <code>L</code>, and <code>rho0</code> specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity <code>u0</code> directly (<code>Ma</code> needs to be set to <code>nothing</code> in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity <code>nu</code> directly (in this case, <code>Re</code> needs to be set to <code>nothing</code>).</p><p>The twenty-seven discrete velocity directions of the D3Q27 scheme are sorted as follows [4]:</p><ul><li>plane at <code>z = -1</code>:<pre><code class="nohighlight hljs">  24    17     21       y
     ┌───┼───┐          │
     │       │          │
  10 ┼   6   ┼ 15        ──── x
     │       │         ╱
     └───┼───┘        ╱
  20    12     26    z</code></pre></li><li>plane at <code>z = 0</code>:<pre><code class="nohighlight hljs">  14     3     7        y
     ┌───┼───┐          │
     │       │          │
   2 ┼  27   ┼ 1         ──── x
     │       │         ╱
     └───┼───┘        ╱
   8     4     13    z</code></pre></li><li>plane at <code>z = +1</code>:<pre><code class="nohighlight hljs">  25    11     19       y
     ┌───┼───┐          │
     │       │          │
  16 ┼   5   ┼ 9         ──── x
     │       │         ╱
     └───┼───┘        ╱
  22    18     23    z</code></pre></li></ul><p>Note that usually the velocities are numbered from <code>0</code> to <code>26</code>, where <code>0</code> corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from <code>1</code> to <code>27</code>, where <code>1</code> through <code>26</code> correspond to the velocity directions in [4] and <code>27</code> is the zero velocity.</p><p>The corresponding opposite directions are:</p><ul><li>1 ←→  2</li><li>2 ←→  1</li><li>3 ←→  4</li><li>4 ←→  3</li><li>5 ←→  6</li><li>6 ←→  5</li><li>7 ←→  8</li><li>8 ←→  7</li><li>9 ←→ 10</li><li>10 ←→  9</li><li>11 ←→ 12</li><li>12 ←→ 11</li><li>13 ←→ 14</li><li>14 ←→ 13</li><li>15 ←→ 16</li><li>16 ←→ 15</li><li>17 ←→ 18</li><li>18 ←→ 17</li><li>19 ←→ 20</li><li>20 ←→ 19</li><li>21 ←→ 22</li><li>22 ←→ 21</li><li>23 ←→ 24</li><li>24 ←→ 23</li><li>25 ←→ 26</li><li>26 ←→ 25</li><li>27 ←→ 27</li></ul><p>The main sources for the base implementation were</p><ol><li>Misun Min, Taehun Lee, <strong>A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows</strong>, J Comput Phys 230(1), 2011 <a href="https://doi.org/10.1016/j.jcp.2010.09.024">doi:10.1016/j.jcp.2010.09.024</a></li><li>Karsten Golly, <strong>Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum</strong>, Master Thesis, University of Cologne, 2018.</li><li>Dieter Hänel, <strong>Molekulare Gasdynamik</strong>, Springer-Verlag Berlin Heidelberg, 2004 <a href="https://doi.org/10.1007/3-540-35047-0">doi:10.1007/3-540-35047-0</a></li><li>Dieter Krüger et al., <strong>The Lattice Boltzmann Method</strong>, Springer International Publishing, 2017 <a href="https://doi.org/10.1007/978-3-319-44649-3">doi:10.1007/978-3-319-44649-3</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L8-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation1D" href="#Trixi.LinearScalarAdvectionEquation1D"><code>Trixi.LinearScalarAdvectionEquation1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation1D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a \partial_1 u  = 0\]</p><p>in one space dimension with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation2D" href="#Trixi.LinearScalarAdvectionEquation2D"><code>Trixi.LinearScalarAdvectionEquation2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation2D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a_1 \partial_1 u + a_2 \partial_2 u = 0\]</p><p>in two space dimensions with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LinearScalarAdvectionEquation3D" href="#Trixi.LinearScalarAdvectionEquation3D"><code>Trixi.LinearScalarAdvectionEquation3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearScalarAdvectionEquation3D</code></pre><p>The linear scalar advection equation</p><p class="math-container">\[\partial_t u + a_1 \partial_1 u + a_2 \partial_2 u + a_3 \partial_3 u = 0\]</p><p>in three space dimensions with constant velocity <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LobattoLegendreBasis" href="#Trixi.LobattoLegendreBasis"><code>Trixi.LobattoLegendreBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LobattoLegendreBasis([RealT=Float64,] polydeg::Integer)</code></pre><p>Create a nodal Lobatto-Legendre basis for polynomials of degree <code>polydeg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem/basis_lobatto_legendre.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.P4estMesh" href="#Trixi.P4estMesh"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">P4estMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>An unstructured curved mesh based on trees that uses the C library p4est to manage trees and mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/p4est_mesh.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.P4estMesh-Tuple{Any}" href="#Trixi.P4estMesh-Tuple{Any}"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMesh(trees_per_dimension; polydeg,
          mapping=nothing, faces=nothing, coordinates_min=nothing, coordinates_max=nothing,
          RealT=Float64, initial_refinement_level=0, periodicity=true, unsaved_changes=true)</code></pre><p>Create a structured curved <code>P4estMesh</code> of the specified size.</p><p>There are three ways to map the mesh to the physical domain.</p><ol><li>Define a <code>mapping</code> that maps the hypercube <code>[-1, 1]^n</code>.</li><li>Specify a <code>Tuple</code> <code>faces</code> of functions that parametrize each face.</li><li>Create a rectangular mesh by specifying <code>coordinates_min</code> and <code>coordinates_max</code>.</li></ol><p>Non-periodic boundaries will be called <code>:x_neg</code>, <code>:x_pos</code>, <code>:y_neg</code>, <code>:y_pos</code>, <code>:z_neg</code>, <code>:z_pos</code>.</p><p><strong>Arguments</strong></p><ul><li><code>trees_per_dimension::NTupleE{NDIMS, Int}</code>: the number of trees in each dimension.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the reference mesh (<code>[-1, 1]^n</code>) to the physical domain.            Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>faces::NTuple{2*NDIMS}</code>: a tuple of <code>2 * NDIMS</code> functions that describe the faces of the domain.                           Each function must take <code>NDIMS-1</code> arguments.                           <code>faces[1]</code> describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by <code>faces[2]</code>.                           <code>faces[3:4]</code> describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           <code>faces[5:6]</code> describe the faces in positive and negative z-direction respectively (in 3D).                           Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_min</code>: vector or tuple of the coordinates of the corner in the negative direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>coordinates_max</code>: vector or tuple of the coordinates of the corner in the positive direction of each dimension                    to create a rectangular mesh.                    Use only one of <code>mapping</code>, <code>faces</code> and <code>coordinates_min</code>/<code>coordinates_max</code>.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code>                deciding for each dimension if the boundaries in this dimension are periodic.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/p4est_mesh.jl#L81-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS" href="#Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS"><code>Trixi.P4estMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMesh{NDIMS}(meshfile::String;
                 mapping=nothing, polydeg=1, RealT=Float64,
                 initial_refinement_level=0, unsaved_changes=true)</code></pre><p>Import an uncurved, unstructured, conforming mesh from an Abaqus mesh file (<code>.inp</code>), map the mesh with the specified mapping, and create a <code>P4estMesh</code> from the curved mesh.</p><p>Cells in the mesh file will be imported as trees in the <code>P4estMesh</code>. The mesh will only have one boundary <code>:all</code>, as distinguishing different boundaries is non-trivial.</p><p><strong>Arguments</strong></p><ul><li><code>meshfile::String</code>: an uncurved Abaqus mesh file that can be imported by p4est.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping that transforms            the imported mesh to the physical domain. Use <code>nothing</code> for the identity map.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of <code>1</code> creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/p4est_mesh.jl#L245-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ParametersEulerGravity" href="#Trixi.ParametersEulerGravity"><code>Trixi.ParametersEulerGravity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametersEulerGravity(; background_density=0.0,
                         gravitational_constant=1.0,
                         cfl=1.0,
                         resid_tol=1.0e-4,
                         n_iterations_max=10^4,
                         timestep_gravity=timestep_gravity_erk52_3Sstar!)</code></pre><p>Set up parameters for the gravitational part of a <a href="#Trixi.SemidiscretizationEulerGravity"><code>SemidiscretizationEulerGravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization_euler_gravity.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ParsaniKetchesonDeconinck3Sstar32" href="#Trixi.ParsaniKetchesonDeconinck3Sstar32"><code>Trixi.ParsaniKetchesonDeconinck3Sstar32</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsaniKetchesonDeconinck3Sstar32()</code></pre><p>Parsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems <a href="https://doi.org/10.1137/120885899">DOI: 10.1137/120885899</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/time_integration/methods_3Sstar.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ParsaniKetchesonDeconinck3Sstar94" href="#Trixi.ParsaniKetchesonDeconinck3Sstar94"><code>Trixi.ParsaniKetchesonDeconinck3Sstar94</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParsaniKetchesonDeconinck3Sstar94()</code></pre><p>Parsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems <a href="https://doi.org/10.1137/120885899">DOI: 10.1137/120885899</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/time_integration/methods_3Sstar.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PerformanceCounter" href="#Trixi.PerformanceCounter"><code>Trixi.PerformanceCounter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PerformanceCounter</code></pre><p>A <code>PerformanceCounter</code> be used to track the runtime performance of some calls. Add a new runtime measurement via <code>put!(counter, runtime)</code> and get the averaged runtime of all measurements added so far via <code>take!(counter)</code>, resetting the <code>counter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PlotData1D" href="#Trixi.PlotData1D"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlotData1D</code></pre><p>Holds all relevant data for creating 1D plots of multiple solution variables and to visualize the mesh.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L437-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PlotData1D-Tuple{Any, Any}" href="#Trixi.PlotData1D-Tuple{Any, Any}"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData1D(u, semi [or mesh, equations, solver, cache];
           solution_variables=nothing, nvisnodes=nothing)</code></pre><p>Create a new <code>PlotData1D</code> object that can be used for visualizing 1D DGSEM solution data array <code>u</code> with <code>Plots.jl</code>. All relevant geometrical information is extracted from the semidiscretization <code>semi</code>. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to <code>solution_variables</code>.</p><p><code>nvisnodes</code> specifies the number of visualization nodes to be used. If it is <code>nothing</code>, twice the number of solution DG nodes are used for visualization, and if set to <code>0</code>, exactly the number of nodes in the DG elements are used.</p><p>When visualizing data from a two-dimensional simulation, a 1D slice is extracted for plotting. <code>slice</code> specifies the axis along which the slice is extracted and may be <code>:x</code>, or <code>:y</code>. The slice position is specified by a <code>point</code> that lies on it, which defaults to <code>(0.0, 0.0)</code>. Both of these values are ignored when visualizing 1D data. This applies analogously to three-dimensonal simulations, where <code>slice</code> may be <code>xy:</code>, <code>:xz</code>, or <code>:yz</code>.</p><p>Another way to visualize 2D/3D data is by creating a plot along a given curve. This is done with the keyword argument <code>curve</code>. It can be set to a list of 2D/3D points which define the curve. When using <code>curve</code> any other input from <code>slice</code> or <code>point</code> will be ignored.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L454-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PlotData1D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization, F_&lt;:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}" href="#Trixi.PlotData1D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization, F_&lt;:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}"><code>Trixi.PlotData1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData1D(sol; kwargs...)</code></pre><p>Create a <code>PlotData1D</code> object from a solution object created by either <code>OrdinaryDiffEq.solve!</code> (which returns a <code>DiffEqBase.ODESolution</code>) or Trixi&#39;s own <code>solve!</code> (which returns a <code>TimeIntegratorSolution</code>).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L519-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PlotData2D" href="#Trixi.PlotData2D"><code>Trixi.PlotData2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlotData2D</code></pre><p>Holds all relevant data for creating 2D plots of multiple solution variables and to visualize the mesh.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PlotData2D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization, F_&lt;:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}" href="#Trixi.PlotData2D-Tuple{Union{SciMLBase.ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} where {T, N, uType, uType2, DType, tType, rateType, P&lt;:(SciMLBase.ODEProblem{uType_, tType_, isinplace, P_, F_, K, PT} where {uType_, tType_, isinplace, P_&lt;:Trixi.AbstractSemidiscretization, F_&lt;:(SciMLBase.ODEFunction{true, typeof(Trixi.rhs!), TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV} where {TMM, Ta, Tt, TJ, JVP, VJP, JP, SP, TW, TWt, TPJ, S, S2, O, TCV}), K, PT}), A, IType, DE}, Trixi.TimeIntegratorSolution}}"><code>Trixi.PlotData2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlotData2D(sol; kwargs...)</code></pre><p>Create a <code>PlotData2D</code> object from a solution object created by either <code>OrdinaryDiffEq.solve!</code> (which returns a <code>DiffEqBase.ODESolution</code>) or Trixi&#39;s own <code>solve!</code> (which returns a <code>TimeIntegratorSolution</code>).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.PositivityPreservingLimiterZhangShu" href="#Trixi.PositivityPreservingLimiterZhangShu"><code>Trixi.PositivityPreservingLimiterZhangShu</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PositivityPreservingLimiterZhangShu(; threshold, variables)</code></pre><p>The fully-discrete positivity-preserving limiter of</p><ul><li>Zhang, Shu (2011) Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments <a href="https://doi.org/10.1098/rspa.2011.0153">doi: 10.1098/rspa.2011.0153</a></li></ul><p>The limiter is applied to all scalar <code>variables</code> in their given order using the associated <code>thresholds</code> to determine the minimal acceptable values. The order of the <code>variables</code> is important and might have a strong influence on the robustness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_stage/positivity_zhang_shu.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SaveRestartCallback" href="#Trixi.SaveRestartCallback"><code>Trixi.SaveRestartCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SaveRestartCallback(; interval=0,
                      save_final_restart=true,
                      output_directory=&quot;out&quot;)</code></pre><p>Save the current numerical solution in a restart file every <code>interval</code> time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/save_restart.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SaveSolutionCallback" href="#Trixi.SaveSolutionCallback"><code>Trixi.SaveSolutionCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SaveSolutionCallback(; interval=0,
                       save_initial_solution=true,
                       save_final_solution=true,
                       output_directory=&quot;out&quot;,
                       solution_variables=cons2prim)</code></pre><p>Save the current numerical solution every <code>interval</code> time steps. <code>solution_variables</code> can be any callable that converts the conservative variables at a single point to a set of solution variables. The first parameter passed to <code>solution_variables</code> will be the set of conservative variables and the second parameter is the equation struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/save_solution.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SemidiscretizationEulerGravity" href="#Trixi.SemidiscretizationEulerGravity"><code>Trixi.SemidiscretizationEulerGravity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationEulerGravity</code></pre><p>A struct containing everything needed to describe a spatial semidiscretization of a the compressible Euler equations with self-gravity, reformulating the Poisson equation for the gravitational potential as steady-state problem of the hyperblic diffusion equations.</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) &quot;A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics&quot; <a href="https://arXiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization_euler_gravity.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler&lt;:(SemidiscretizationHyperbolic{Mesh, var&quot;#s2573&quot;, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var&quot;#s2573&quot;&lt;:Trixi.AbstractCompressibleEulerEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache}), SemiGravity&lt;:(SemidiscretizationHyperbolic{Mesh, var&quot;#s2572&quot;, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var&quot;#s2572&quot;&lt;:Trixi.AbstractHyperbolicDiffusionEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache})}" href="#Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler&lt;:(SemidiscretizationHyperbolic{Mesh, var&quot;#s2573&quot;, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var&quot;#s2573&quot;&lt;:Trixi.AbstractCompressibleEulerEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache}), SemiGravity&lt;:(SemidiscretizationHyperbolic{Mesh, var&quot;#s2572&quot;, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache} where {var&quot;#s2572&quot;&lt;:Trixi.AbstractHyperbolicDiffusionEquations, InitialCondition, BoundaryConditions, SourceTerms, Solver, Cache})}"><code>Trixi.SemidiscretizationEulerGravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationEulerGravity(semi_euler::SemiEuler, semi_gravity::SemiGravity, parameters)</code></pre><p>Construct a semidiscretization of the compressible Euler equations with self-gravity. <code>parameters</code> should be given as <a href="#Trixi.ParametersEulerGravity"><code>ParametersEulerGravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization_euler_gravity.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolic" href="#Trixi.SemidiscretizationHyperbolic"><code>Trixi.SemidiscretizationHyperbolic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolic</code></pre><p>A struct containing everything needed to describe a spatial semidiscretization of a hyperbolic conservation law.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization_hyperbolic.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}" href="#Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}"><code>Trixi.SemidiscretizationHyperbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver;
                             source_terms=nothing,
                             boundary_conditions=boundary_condition_periodic,
                             RealT=real(solver),
                             uEltype=RealT,
                             initial_cache=NamedTuple())</code></pre><p>Construct a semidiscretization of a hyperbolic PDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization_hyperbolic.jl#L43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SteadyStateCallback" href="#Trixi.SteadyStateCallback"><code>Trixi.SteadyStateCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateCallback(; abstol=1.0e-8, reltol=1.0e-6)</code></pre><p>Terminates the integration when the <a href="#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}"><code>residual_steady_state(du, equations)</code></a> falls below the threshold specified by <code>abstol, reltol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/steady_state.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.StepsizeCallback" href="#Trixi.StepsizeCallback"><code>Trixi.StepsizeCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StepsizeCallback(; cfl=1.0)</code></pre><p>Set the time step size according to a CFL condition with CFL number <code>cfl</code> if the time integration method isn&#39;t adaptive itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/stepsize.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.StructuredMesh" href="#Trixi.StructuredMesh"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>A structured curved mesh.</p><p>Different numbers of cells per dimension are possible and arbitrary functions can be used as domain faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/structured_mesh.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Any, Any}" href="#Trixi.StructuredMesh-Tuple{Any, Any, Any}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, coordinates_min, coordinates_max)</code></pre><p>Create a StructuredMesh that represents a uncurved structured mesh with a rectangular domain.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTuple{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>coordinates_min::NTuple{NDIMS, RealT}</code>: coordinate of the corner in the negative direction of each dimension.</li><li><code>coordinates_max::NTuple{NDIMS, RealT}</code>: coordinate of the corner in the positive direction of each dimension.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code> deciding for                each dimension if the boundaries in this dimension are periodic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/structured_mesh.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Any}" href="#Trixi.StructuredMesh-Tuple{Any, Any}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, mapping, RealT; unsaved_changes=true, mapping_as_string=mapping2string(mapping, length(cells_per_dimension)))</code></pre><p>Create a StructuredMesh of the given size and shape that uses <code>RealT</code> as coordinate type.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTupleE{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>mapping</code>: a function of <code>NDIMS</code> variables to describe the mapping, which transforms            the reference mesh to the physical domain.            If no <code>mapping_as_string</code> is defined, this function must be defined with the name <code>mapping</code>            to allow for restarts.            This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code>                deciding for each dimension if the boundaries in this dimension are periodic.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li><li><code>mapping_as_string::String</code>: the code that defines the <code>mapping</code>.                              If <code>CodeTracking</code> can&#39;t find the function definition, it can be passed directly here.                              The code string must define the mapping function with the name <code>mapping</code>.                              This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/structured_mesh.jl#L26-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.StructuredMesh-Tuple{Any, Tuple}" href="#Trixi.StructuredMesh-Tuple{Any, Tuple}"><code>Trixi.StructuredMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StructuredMesh(cells_per_dimension, faces, RealT; unsaved_changes=true, faces_as_string=faces2string(faces))</code></pre><p>Create a StructuredMesh of the given size and shape that uses <code>RealT</code> as coordinate type.</p><p><strong>Arguments</strong></p><ul><li><code>cells_per_dimension::NTupleE{NDIMS, Int}</code>: the number of cells in each dimension.</li><li><code>faces::NTuple{2*NDIMS}</code>: a tuple of <code>2 * NDIMS</code> functions that describe the faces of the domain.                           Each function must take <code>NDIMS-1</code> arguments.                           <code>faces[1]</code> describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by <code>faces[2]</code>.                           <code>faces[3:4]</code> describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           <code>faces[5:6]</code> describe the faces in positive and negative z-direction respectively (in 3D).</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>periodicity</code>: either a <code>Bool</code> deciding if all of the boundaries are periodic or an <code>NTuple{NDIMS, Bool}</code> deciding for                each dimension if the boundaries in this dimension are periodic.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/structured_mesh.jl#L67-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SurfaceIntegralStrongForm" href="#Trixi.SurfaceIntegralStrongForm"><code>Trixi.SurfaceIntegralStrongForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceIntegralStrongForm(surface_flux=flux_central)</code></pre><p>The classical strong form surface integral type for FD/DG methods.</p><p>See also <a href="#Trixi.VolumeIntegralStrongForm"><code>VolumeIntegralStrongForm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SurfaceIntegralWeakForm" href="#Trixi.SurfaceIntegralWeakForm"><code>Trixi.SurfaceIntegralWeakForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurfaceIntegralWeakForm(surface_flux=flux_central)</code></pre><p>The classical weak form surface integral type for DG methods as explained in standard textbooks such as</p><ul><li>Kopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers <a href="https://doi.org/10.1007/978-90-481-2261-5">doi: 10.1007/978-90-481-2261-5</a></li></ul><p>See also <a href="#Trixi.VolumeIntegralWeakForm"><code>VolumeIntegralWeakForm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.TimeSeriesCallback" href="#Trixi.TimeSeriesCallback"><code>Trixi.TimeSeriesCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeSeriesCallback(semi, point_coordinates;
                   interval=1, solution_variables=cons2cons,
                   output_directory=&quot;out&quot;, filename=&quot;time_series.h5&quot;,
                   RealT=real(solver), uEltype=eltype(cache.elements))</code></pre><p>Create a callback that records point-wise data at points given in <code>point_coordinates</code> every <code>interval</code> time steps. The point coordinates are to be specified either as a vector of coordinate tuples or as a two-dimensional array where the first dimension is the point number and the second dimension is the coordinate dimension. By default, the conservative variables are recorded, but this can be controlled by passing a different conversion function to <code>solution_variables</code>.</p><p>After the last time step, the results are stored in an HDF5 file <code>filename</code> in directory <code>output_directory</code>.</p><p>The real data type <code>RealT</code> and data type for solution variables <code>uEltype</code> default to the respective types used in the solver and the cache.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/time_series.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.TreeMesh" href="#Trixi.TreeMesh"><code>Trixi.TreeMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeMesh{NDIMS} &lt;: AbstractMesh{NDIMS}</code></pre><p>A Cartesian mesh based on trees of hypercubes to support adaptive mesh refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/tree_mesh.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.UnstructuredMesh2D" href="#Trixi.UnstructuredMesh2D"><code>Trixi.UnstructuredMesh2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnstructuredMesh2D &lt;: AbstractMesh{2}</code></pre><p>An unstructured (possibly curved) quadrilateral mesh.</p><pre><code class="nohighlight hljs">UnstructuredMesh2D(filename; RealT=Float64, periodicity=false)</code></pre><p>All mesh information, neighbour coupling, and boundary curve information is read in from a mesh file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/unstructured_mesh.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.UnstructuredSortedBoundaryTypes" href="#Trixi.UnstructuredSortedBoundaryTypes"><code>Trixi.UnstructuredSortedBoundaryTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnstructuredSortedBoundaryTypes</code></pre><p>General container to sort the boundary conditions by type for some unstructured meshes/solvers. It stores a set of global indices for each boundary condition type to expedite computation during the call to <code>calc_boundary_flux!</code>. The original dictionary form of the boundary conditions set by the user in the elixir file is also stored for printing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem_unstructured/sort_boundary_conditions.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VertexMappedMesh" href="#Trixi.VertexMappedMesh"><code>Trixi.VertexMappedMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VertexMappedMesh{NDIMS, ElemType, Nboundaries, Tv, Ti} &lt;: AbstractMeshData{NDIMS, ElemType}</code></pre><p><code>VertexMappedMesh</code> describes a mesh which is constructed by an reference-to-physical mapping which can be constructed using only the vertex positions.</p><p>Wraps <code>MeshData</code> and <code>boundary_faces</code> in a dispatchable mesh type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/dgmulti_meshes.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VertexMappedMesh-Tuple{Any, Any, DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;} where {NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;&lt;:(StartUpDG.RefElemData{NDIMS, ElemType, ApproxType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {Nfaces, Tv, VQ, VF, MM, P, D, L})}}" href="#Trixi.VertexMappedMesh-Tuple{Any, Any, DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;} where {NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;&lt;:(StartUpDG.RefElemData{NDIMS, ElemType, ApproxType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {Nfaces, Tv, VQ, VF, MM, P, D, L})}}"><code>Trixi.VertexMappedMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VertexMappedMesh(vertex_coordinates, EToV, dg::DGMulti;
                 is_on_boundary = nothing,
                 is_periodic::NTuple{NDIMS, Bool} = ntuple(_-&gt;false, NDIMS)) where {NDIMS, Tv}</code></pre><p>Constructor which uses <code>dg::DGMulti</code> instead of <code>rd::RefElemData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgmulti/types.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VertexMappedMesh-Tuple{Any, DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;} where {NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;&lt;:(StartUpDG.RefElemData{NDIMS, ElemType, ApproxType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {Nfaces, Tv, VQ, VF, MM, P, D, L})}, Dict{Symbol, Int64}}" href="#Trixi.VertexMappedMesh-Tuple{Any, DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;} where {NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, var&quot;#s3022&quot;&lt;:(StartUpDG.RefElemData{NDIMS, ElemType, ApproxType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {Nfaces, Tv, VQ, VF, MM, P, D, L})}, Dict{Symbol, Int64}}"><code>Trixi.VertexMappedMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VertexMappedMesh(triangulateIO, dg::DGMulti, boundary_dict::Dict{Symbol, Int})</code></pre><p>Constructor which uses <code>dg::DGMulti</code> instead of <code>rd::RefElemData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgmulti/types.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VertexMappedMesh-Tuple{Any, StartUpDG.RefElemData{2, Tri, ApproximationType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {ApproximationType, Nfaces, Tv, VQ, VF, MM, P, D, L}, Dict{Symbol, Int64}}" href="#Trixi.VertexMappedMesh-Tuple{Any, StartUpDG.RefElemData{2, Tri, ApproximationType, Nfaces, Tv, VQ, VF, MM, P, D, L} where {ApproximationType, Nfaces, Tv, VQ, VF, MM, P, D, L}, Dict{Symbol, Int64}}"><code>Trixi.VertexMappedMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VertexMappedMesh(triangulateIO, rd::RefElemData{2, Tri}, boundary_dict::Dict{Symbol, Int})</code></pre><ul><li><code>triangulateIO</code> is a <code>TriangulateIO</code> mesh representation</li><li><code>rd</code> is a <code>RefElemData</code> from <code>StartUpDG.jl</code>, and contains information associated with to the</li></ul><p>reference element (e.g., quadrature, basis evaluation, differentiation, etc).</p><ul><li><code>boundary_dict</code> is a <code>Dict{Symbol, Int}</code> which associates each integer <code>TriangulateIO</code> boundary tag with a Symbol</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/dgmulti_meshes.jl#L67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VertexMappedMesh-Union{Tuple{Ti}, Tuple{Tv}, Tuple{NDIMS}, Tuple{Tuple{Vararg{Vector{Tv}, NDIMS}}, Matrix{Ti}, StartUpDG.RefElemData}} where {NDIMS, Tv, Ti}" href="#Trixi.VertexMappedMesh-Union{Tuple{Ti}, Tuple{Tv}, Tuple{NDIMS}, Tuple{Tuple{Vararg{Vector{Tv}, NDIMS}}, Matrix{Ti}, StartUpDG.RefElemData}} where {NDIMS, Tv, Ti}"><code>Trixi.VertexMappedMesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VertexMappedMesh(vertex_coordinates::NTuple{NDIMS, Vector{Tv}}, EToV, rd::RefElemData;
                 is_on_boundary = nothing,
                 is_periodic::NTuple{NDIMS, Bool} = ntuple(_-&gt;false, NDIMS)) where {NDIMS, Tv}</code></pre><ul><li><code>vertex_coordinates</code> is a tuple of vectors containing x,y,... components of the vertex coordinates</li><li><code>EToV</code> is a 2D array containing element-to-vertex connectivities for each element</li><li><code>rd</code> is a <code>RefElemData</code> from <code>StartUpDG.jl</code>, and contains information associated with to the reference element (e.g., quadrature, basis evaluation, differentiation, etc).</li><li><code>is_on_boundary</code> specifies boundary using a <code>Dict{Symbol, &lt;:Function}</code></li><li><code>is_periodic</code> is a tuple of booleans specifying periodicity = <code>true</code>/<code>false</code> in the (x,y,z) direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/dgmulti_meshes.jl#L45-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VisualizationCallback-Tuple{}" href="#Trixi.VisualizationCallback-Tuple{}"><code>Trixi.VisualizationCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VisualizationCallback(; interval=0,
                        solution_variables=cons2prim,
                        variable_names=[],
                        show_mesh=false,
                        plot_data_creator=PlotData2D,
                        plot_creator=show_plot,
                        plot_arguments...)</code></pre><p>Create a callback that visualizes results during a simulation, also known as <em>in-situ visualization</em>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in any future releases.</p></div></div><p>The <code>interval</code> specifies the number of time step iterations after which a new plot is generated. The available variables to plot are configured with the <code>solution_variables</code> parameter, which acts the same way as for the <a href="#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>. The variables to be actually plotted can be selected by providing a single string or a list of strings to <code>variable_names</code>, and if <code>show_mesh</code> is <code>true</code>, an additional plot with the mesh will be generated.</p><p>To customize the generated figure, <code>plot_data_creator</code> allows to use different plot data types. With <code>plot_creator</code> you can further specify an own function to visualize results, which must support the same interface as the default implementation <a href="#Trixi.show_plot-Tuple{Any, Any}"><code>show_plot</code></a>. All remaining keyword arguments are collected and passed as additional arguments to the plotting command.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/visualization.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VolumeIntegralFluxDifferencing" href="#Trixi.VolumeIntegralFluxDifferencing"><code>Trixi.VolumeIntegralFluxDifferencing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralFluxDifferencing</code></pre><p>Volume integral type for DG methods based on SBP operators and flux differencing using symmetric two-point volume fluxes. Based upon the theory developed by</p><ul><li>LeFloch, Mercier, Rohde (2002) Fully Discrete, Entropy Conservative Schemes of Arbitrary Order <a href="https://doi.org/10.1137/S003614290240069X">doi: 10.1137/S003614290240069X</a></li><li>Fisher, Carpenter (2013) High-order entropy stable finite difference schemes for nonlinear conservation laws: Finite domains <a href="https://doi.org/10.1016/j.jcp.2013.06.014">doi: 10.1016/j.jcp.2013.06.014</a></li><li>Hendrik Ranocha (2017) Comparison of Some Entropy Conservative Numerical Fluxes for the Euler Equations <a href="https://arxiv.org/abs/1701.02264">arXiv: 1701.02264</a> <a href="https://doi.org/10.1007/s10915-017-0618-1">doi: 10.1007/s10915-017-0618-1</a></li><li>Chen, Shu (2017) Entropy stable high order discontinuous Galerkin methods with suitable quadrature rules for hyperbolic conservation laws <a href="https://doi.org/10.1016/j.jcp.2017.05.025">doi: 10.1016/j.jcp.2017.05.025</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L37-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VolumeIntegralPureLGLFiniteVolume" href="#Trixi.VolumeIntegralPureLGLFiniteVolume"><code>Trixi.VolumeIntegralPureLGLFiniteVolume</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralPureLGLFiniteVolume</code></pre><p>A volume integral that only uses the subcell finite volume scheme from the paper</p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul><p>This gives a formally O(1)-accurate finite volume scheme on an LGL-type subcell mesh (LGL = Legendre-Gauss-Lobatto).</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VolumeIntegralShockCapturingHG" href="#Trixi.VolumeIntegralShockCapturingHG"><code>Trixi.VolumeIntegralShockCapturingHG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralShockCapturingHG</code></pre><p>Shock-capturing volume integral type for DG methods proposed by</p><ul><li>Hennemann, Gassner (2020) &quot;A provably entropy stable subcell shock capturing approach for high order split form DG&quot; <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VolumeIntegralStrongForm" href="#Trixi.VolumeIntegralStrongForm"><code>Trixi.VolumeIntegralStrongForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralStrongForm</code></pre><p>The classical strong form volume integral type for FD/DG methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.VolumeIntegralWeakForm" href="#Trixi.VolumeIntegralWeakForm"><code>Trixi.VolumeIntegralWeakForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VolumeIntegralWeakForm</code></pre><p>The classical weak form volume integral type for DG methods as explained in standard textbooks such as</p><ul><li>Kopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers <a href="https://doi.org/10.1007/978-90-481-2261-5">doi: 10.1007/978-90-481-2261-5</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dg.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{PlotData2D, Any}" href="#Base.getindex-Tuple{PlotData2D, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(pd::PlotData2D, variable_name)</code></pre><p>Extract a single variable <code>variable_name</code> from <code>pd</code> for plotting with <code>Plots.plot</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{Trixi.AbstractContainer, Any}" href="#Base.resize!-Tuple{Trixi.AbstractContainer, Any}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(c::AbstractContainer, new_length) -&gt; AbstractContainer</code></pre><p>Resize <code>c</code> to contain <code>new_length</code> elements. If <code>new_length</code> is smaller than the current container length, the first <code>new_length</code> elements will be retained. If <code>new_length</code> is larger, the new elements are invalidated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/containers.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}" href="#PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}"><code>PolynomialBases.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate(f, u, basis::LobattoLegendreBasis)</code></pre><p>Map the function <code>f</code> to the coefficients <code>u</code> and integrate with respect to the quadrature rule given by <code>basis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem/basis_lobatto_legendre.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func" href="#PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func"><code>PolynomialBases.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate([func=(u_node,equations)-&gt;u_node,] u_ode, semi::AbstractSemidiscretization; normalize=true)</code></pre><p>Call <code>func(u_node, equations)</code> for each vector of nodal variables <code>u_node</code> in <code>u_ode</code> and integrate the result using a quadrature associated with the semidiscretization <code>semi</code>.</p><p>If <code>normalize</code> is true, the result is divided by the total volume of the computational domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.LBMCollisionCallback-Tuple{}" href="#Trixi.LBMCollisionCallback-Tuple{}"><code>Trixi.LBMCollisionCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LBMCollisionCallback()</code></pre><p>Apply the Lattice-Boltzmann method (LBM) collision operator before each time step. See <a href="#Trixi.LatticeBoltzmannEquations2D"><code>LatticeBoltzmannEquations2D</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/lbm_collision.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.P4estMeshCubedSphere-NTuple{4, Any}" href="#Trixi.P4estMeshCubedSphere-NTuple{4, Any}"><code>Trixi.P4estMeshCubedSphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P4estMesh(trees_per_face_dimension, layers, inner_radius, thickness;
          polydeg, RealT=Float64,
          initial_refinement_level=0, unsaved_changes=true)</code></pre><p>Build a &quot;Cubed Sphere&quot; mesh as <code>P4estMesh</code> with <code>6 * trees_per_face_dimension^2 * layers</code> trees.</p><p>The mesh will have two boundaries, <code>:inside</code> and <code>:outside</code>.</p><p><strong>Arguments</strong></p><ul><li><code>trees_per_face_dimension::Integer</code>: the number of trees in the first two local dimensions of                                      each face.</li><li><code>layers::Integer</code>: the number of trees in the third local dimension of each face, i.e., the number                    of layers of the sphere.</li><li><code>inner_radius::Integer</code>: the inner radius of the sphere.</li><li><code>thickness::Integer</code>: the thickness of the sphere. The outer radius will be <code>inner_radius + thickness</code>.</li><li><code>polydeg::Integer</code>: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.</li><li><code>RealT::Type</code>: the type that should be used for coordinates.</li><li><code>initial_refinement_level::Integer</code>: refine the mesh uniformly to this level before the simulation starts.</li><li><code>unsaved_changes::Bool</code>: if set to <code>true</code>, the mesh will be saved to a mesh file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/p4est_mesh.jl#L303-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.SummaryCallback-Tuple{}" href="#Trixi.SummaryCallback-Tuple{}"><code>Trixi.SummaryCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SummaryCallback()</code></pre><p>Create and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/summary.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.TrivialCallback-Tuple{}" href="#Trixi.TrivialCallback-Tuple{}"><code>Trixi.TrivialCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TrivialCallback()</code></pre><p>A callback that does nothing. This can be useful to disable some callbacks easily via <a href="#Trixi.trixi_include-Tuple{Module, AbstractString}"><code>trixi_include</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/trivial.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}" href="#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}"><code>Trixi.adapt_to_mesh_level!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_to_mesh_level!(u_ode, semi, level)
adapt_to_mesh_level!(sol::Trixi.TrixiODESolution, level)</code></pre><p>Like <a href="#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}"><code>adapt_to_mesh_level</code></a>, but modifies the solution and parts of the semidiscretization (mesh and caches) in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/adapt.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}" href="#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}"><code>Trixi.adapt_to_mesh_level</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_to_mesh_level(u_ode, semi, level)
adapt_to_mesh_level(sol::Trixi.TrixiODESolution, level)</code></pre><p>Use the regular adaptive mesh refinement routines to adaptively refine/coarsen the solution <code>u_ode</code> with semidiscretization <code>semi</code> towards a uniformly refined grid with refinement level <code>level</code>. The solution and semidiscretization are copied such that the original objects remain <em>unaltered</em>.</p><p>A convenience method accepts an ODE solution object, from which solution and semidiscretization are extracted as needed.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>See also: <a href="#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}"><code>adapt_to_mesh_level!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/adapt.jl#L32-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_couette-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.boundary_condition_couette-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.boundary_condition_couette</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_couette(u_inner, orientation, direction, x, t,
                           surface_flux_function,
                           equations::LatticeBoltzmannEquations2D)</code></pre><p>Moving <em>upper</em> wall boundary condition for a Couette flow setup. To be used in combination with <a href="#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_wall_noslip</code></a> for the lower wall and <a href="#Trixi.boundary_condition_periodic"><code>boundary_condition_periodic</code></a> for the lateral boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L330-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_lid_driven_cavity-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.boundary_condition_lid_driven_cavity-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.boundary_condition_lid_driven_cavity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_lid_driven_cavity(u_inner, orientation, direction, x, t,
                                     surface_flux_function,
                                     equations::LatticeBoltzmannEquations2D)</code></pre><p>Boundary condition for a lid-driven cavity flow setup, where the top lid (+y boundary) is a moving no-slip wall. To be used in combination with <a href="#Trixi.initial_condition_lid_driven_cavity-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>initial_condition_lid_driven_cavity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L272-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.boundary_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation1D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>initial_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>initial_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_x_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_x_y(u_inner, orientation, direction, x, t,
                              surface_flux_function,
                              equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>initial_condition_linear_x_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.boundary_condition_linear_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_y(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation2D)</code></pre><p>Boundary conditions for <a href="#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>initial_condition_linear_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L190-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.boundary_condition_linear_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_linear_z(u_inner, orientation, direction, x, t,
                            surface_flux_function,
                            equation::LinearScalarAdvectionEquation1D)</code></pre><p>Boundary conditions for <a href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>boundary_condition_linear_z</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_monopole-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.boundary_condition_monopole-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.boundary_condition_monopole</code></a> — <span class="docstring-category">Method</span></header><section><div><p>boundary<em>condition</em>monopole(u<em>inner, orientation, direction, x, t, surface</em>flux_function,                               equations::AcousticPerturbationEquations2D)</p><p>Boundary condition for a monopole in a boundary layer at the -y boundary, i.e. <code>direction = 3</code>. This will return an error for any other direction. This boundary condition is used in combination with <a href="#Trixi.initial_condition_monopole-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_monopole</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L246-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.boundary_condition_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_poisson_nonperiodic(u_inner, orientation, direction, x, t,
                                    surface_flux_function,
                                    equations::HyperbolicDiffusionEquations1D)</code></pre><p>Boundary conditions used for convergence tests in combination with <a href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>initial_condition_poisson_nonperiodic</code></a> and <a href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_poisson_nonperiodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.boundary_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,
                                      surface_flux_function,
                                      equations::CompressibleEulerEquations2D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>initial_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L543-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.boundary_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,
                                      surface_flux_function,
                                      equations::CompressibleEulerEquations2D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>initial_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L393-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations2D}" href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations2D}"><code>Trixi.boundary_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,
                                      surface_flux_function,
                                      equations::HyperbolicDiffusionEquations2D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>initial_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_2d.jl#L194-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations3D}" href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations3D}"><code>Trixi.boundary_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_sedov_self_gravity(u_inner, orientation, direction, x, t,
                                      surface_flux_function,
                                      equations::HyperbolicDiffusionEquations3D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>initial_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_3d.jl#L191-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.boundary_condition_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,
                        equations::AcousticPerturbationEquations2D)</code></pre><p>Boundary conditions for a solid wall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.boundary_condition_wall_noslip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_wall_noslip(u_inner, orientation, direction, x, t,
                               surface_flux_function,
                               equations::LatticeBoltzmannEquations2D)</code></pre><p>No-slip wall boundary condition using the bounce-back approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_condition_zero-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.boundary_condition_zero-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.boundary_condition_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_condition_zero(u_inner, orientation, direction, x, t, surface_flux_function,
                        equations::AcousticPerturbationEquations2D)</code></pre><p>Boundary condition that uses a boundary state where the state variables are zero and the mean variables are the same as in <code>u_inner</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L281-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, AcousticPerturbationEquations2D}" href="#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, AcousticPerturbationEquations2D}"><code>Trixi.boundary_state_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_state_slip_wall(u_inner, normal_direction::AbstractVector,
                         equations::AcousticPertubationEquations2D)</code></pre><p>Idea behind this boundary condition is to use an orthogonal projection of the perturbed velocities to zero out the normal velocity while retaining the possibility of a tangential velocity in the boundary state. Further details are available in the paper:</p><ul><li>Marcus Bauer, Jürgen Dierke and Roland Ewert (2011) Application of a discontinuous Galerkin method to discretize acoustic perturbation equations <a href="https://doi.org/10.2514/1.J050333">DOI: 10.2514/1.J050333</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L384-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations2D}" href="#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations2D}"><code>Trixi.boundary_state_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_state_slip_wall(u_internal, normal_direction::AbstractVector,
                         equations::CompressibleEulerEquations2D)</code></pre><p>Determine the external solution value for a slip wall condition. Sets the normal velocity of the the exterior fictitious element to the negative of the internal value.</p><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This wall function can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L579-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations3D}" href="#Trixi.boundary_state_slip_wall-Tuple{Any, AbstractVector{T} where T, CompressibleEulerEquations3D}"><code>Trixi.boundary_state_slip_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_state_slip_wall(u_internal, normal_direction::AbstractVector,
                         equations::CompressibleEulerEquations3D)</code></pre><p>Determine the external solution value for a slip wall condition. Sets the normal velocity of the the exterior fictitious element to the negative of the internal value.</p><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This wall function can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L430-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}" href="#Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}"><code>Trixi.calc_error_norms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_error_norms([func=(u_node,equations)-&gt;u_node,] u_ode, t, analyzer, semi::AbstractSemidiscretization, cache_analysis)</code></pre><p>Calculate discrete L2 and L∞ error norms of <code>func</code> applied to each nodal variable <code>u_node</code> in <code>u_ode</code>. If no exact solution is available, &quot;errors&quot; are calculated using some reference state and can be useful for regression tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations1D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L532-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations2D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L1113-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.calc_fast_wavespeed_roe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)</code></pre><p>Compute the fast magnetoacoustic wave speed using Roe averages as given by</p><ul><li>Cargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws <a href="https://doi.org/10.1006/jcph.1997.5773">DOI: 10.1006/jcph.1997.5773</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L1098-L1106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.collision_bgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collision_bgk(u, dt, equations::LatticeBoltzmannEquations2D)</code></pre><p>Collision operator for the Bhatnagar, Gross, and Krook (BGK) model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L469-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.collision_bgk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collision_bgk(u, dt, equations::LatticeBoltzmannEquations3D)</code></pre><p>Collision operator for the Bhatnagar, Gross, and Krook (BGK) model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}" href="#Trixi.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}"><code>Trixi.compute_coefficients!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_coefficients!(u_ode, func, t, semi::AbstractSemidiscretization)</code></pre><p>Same as <a href="#Trixi.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}"><code>compute_coefficients</code></a> but stores the result in <code>u_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}" href="#Trixi.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}"><code>Trixi.compute_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_coefficients(func, t, semi::AbstractSemidiscretization)</code></pre><p>Compute the discrete coefficients of the continuous function <code>func</code> at time <code>t</code> associated with the semidiscretization <code>semi</code>. For example, the discrete coefficients of <code>func</code> for a discontinuous Galerkin spectral element method (<a href="#Trixi.DGSEM"><code>DGSEM</code></a>) are the values of <code>func</code> at the Lobatto-Legendre nodes. Similarly, a classical finite difference method will use the values of <code>func</code> at the nodes of the grid assoociated with the semidiscretization <code>semi</code>.</p><p>For semidiscretizations <code>semi</code> associated with an initial condition, <code>func</code> can be omitted to use the given initial condition at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}" href="#Trixi.cons2cons-Tuple{Any, Trixi.AbstractEquations}"><code>Trixi.cons2cons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cons2cons(u, equations)</code></pre><p>Return the conserved variables <code>u</code>. While this function is as trivial as <code>identity</code>, it is also as useful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.cons2entropy" href="#Trixi.cons2entropy"><code>Trixi.cons2entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cons2entropy(u, equations)</code></pre><p>Convert the conserved variables <code>u</code> to the entropy variables for a given set of <code>equations</code> with chosen standard <a href="#Trixi.entropy"><code>entropy</code></a>. The inverse conversion is performed by <a href="#Trixi.entropy2cons"><code>entropy2cons</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L234-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.cons2prim" href="#Trixi.cons2prim"><code>Trixi.cons2prim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cons2prim(u, equations)</code></pre><p>Convert the conserved variables <code>u</code> to the primitive variables for a given set of <code>equations</code>. The inverse conversion is performed by <a href="#Trixi.prim2cons"><code>prim2cons</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.convergence_test-Tuple{Module, AbstractString, Any}" href="#Trixi.convergence_test-Tuple{Module, AbstractString, Any}"><code>Trixi.convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convergence_test([mod::Module=Main,] elixir::AbstractString, iterations; kwargs...)</code></pre><p>Run <code>iterations</code> Trixi simulations using the setup given in <code>elixir</code> and compute the experimental order of convergence (EOC) in the <span>$L^2$</span> and <span>$L^\infty$</span> norm. In each iteration, the resolution of the respective mesh will be doubled. Additional keyword arguments <code>kwargs...</code> and the optional module <code>mod</code> are passed directly to <a href="#Trixi.trixi_include-Tuple{Module, AbstractString}"><code>trixi_include</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/special_elixirs.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.default_example-Tuple{}" href="#Trixi.default_example-Tuple{}"><code>Trixi.default_example</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_example()</code></pre><p>Return the path to an example elixir that can be used to quickly see Trixi in action on a [<code>TreeMesh</code>]@(ref). See also <a href="#Trixi.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#Trixi.get_examples-Tuple{}"><code>get_examples</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.default_example_unstructured-Tuple{}" href="#Trixi.default_example_unstructured-Tuple{}"><code>Trixi.default_example_unstructured</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_example_unstructured()</code></pre><p>Return the path to an example elixir that can be used to quickly see Trixi in action on an [<code>UnstructuredMesh2D</code>]@(ref). This simulation is run on the example curved, unstructured mesh given in the Trixi documentation regarding unstructured meshes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}" href="#Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}"><code>Trixi.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(p::Real, equations::LatticeBoltzmannEquations2D)
density(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic density from the pressure <code>p</code> or the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L377-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}" href="#Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}"><code>Trixi.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(p::Real, equations::LatticeBoltzmannEquations3D)
density(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic density from the pressure <code>p</code> or the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L264-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.entropy" href="#Trixi.entropy"><code>Trixi.entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy(u, equations)</code></pre><p>Return the chosen entropy of the conserved variables <code>u</code> for a given set of <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.entropy2cons" href="#Trixi.entropy2cons"><code>Trixi.entropy2cons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entropy2cons(w, equations)</code></pre><p>Convert the entropy variables <code>w</code> based on a standard <a href="#Trixi.entropy"><code>entropy</code></a> to the conserved variables for a given set of <code>equations</code> . The inverse conversion is performed by <a href="#Trixi.cons2entropy"><code>cons2entropy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equilibrium_distribution(alpha, rho, v1, v2, v3, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the local equilibrium distribution for the distribution function with index <code>alpha</code> and given the macroscopic state defined by <code>rho</code>, <code>v1</code>, <code>v2</code>, <code>v3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L319-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equilibrium_distribution(alpha, rho, v1, v2, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the local equilibrium distribution for the distribution function with index <code>alpha</code> and given the macroscopic state defined by <code>rho</code>, <code>v1</code>, <code>v2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L429-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.examples_dir-Tuple{}" href="#Trixi.examples_dir-Tuple{}"><code>Trixi.examples_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">examples_dir()</code></pre><p>Return the directory where the example files provided with Trixi.jl are located. If Trixi is installed as a regular package (with <code>]add Trixi</code>), these files are read-only and should <em>not</em> be modified. To find out which files are available, use, e.g., <code>readdir</code>:</p><p><strong>Examples</strong></p><pre><code class="language- hljs">readdir(examples_dir())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L55-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux" href="#Trixi.flux"><code>Trixi.flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux(u, orientation_or_normal, equations)</code></pre><p>Given the conservative variables <code>u</code>, calculate the (physical) flux in Cartesian direction <code>orientation::Integer</code> or in arbitrary direction <code>normal::AbstractVector</code> for the corresponding set of governing <code>equations</code>. <code>orientation</code> is <code>1</code>, <code>2</code>, and <code>3</code> for the x-, y-, and z-directions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_central-Tuple{Any, Any, Any, Trixi.AbstractEquations}" href="#Trixi.flux_central-Tuple{Any, Any, Any, Trixi.AbstractEquations}"><code>Trixi.flux_central</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_central(u_ll, u_rr, orientation_or_normal_direction, equations::AbstractEquations)</code></pre><p>The classical central numerical flux <code>f((u_ll) + f(u_rr)) / 2</code>. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L339-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L779-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Chandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations <a href="https://doi.org/10.4208/cicp.170712.010313a">DOI: 10.4208/cicp.170712.010313a</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L670-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Ayoub Gouasmi, Karthik Duraisamy (2020) &quot;Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations&quot;&quot; arXiv:1904.00972v3 [math.NA] 4 Feb 2020</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L249-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.flux_chandrashekar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving two-point flux by</p><ul><li>Ayoub Gouasmi, Karthik Duraisamy (2020) &quot;Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations&quot;&quot; arXiv:1904.00972v3 [math.NA] 4 Feb 2020</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L297-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L450-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations3D)</code></pre><p>Entropy conserving two-point flux by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving two-point flux adapted by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_derigs_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Entropy conserving two-point flux adapted by</p><ul><li>Derigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent <a href="https://doi.org/10.1016/j.jcp.2018.03.002">DOI: 10.1016/j.jcp.2018.03.002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L313-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations1D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L317-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations2D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L536-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdEquations3D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L535-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L280-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_hindenlang_gassner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,
                        equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending <a href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a> to the MHD equations.</p><p><strong>References</strong></p><ul><li>Florian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications</li><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L441-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L448-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L1006-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_hllc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)</code></pre><p>Computes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro <a href="http://www.prague-sum.com/download/2012/Toro_2-HLLC-RiemannSolver.pdf">Lecture slides</a> Signal speeds: <a href="https://doi.org/10.1137/S1064827593260140">DOI: 10.1137/S1064827593260140</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L911-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L308-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,
                    equations::CompressibleEulerEquations2D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L714-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_kennedy_gruber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,
                    equations::CompressibleEulerEquations3D)</code></pre><p>Kinetic energy preserving two-point flux by</p><ul><li>Kennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid <a href="https://doi.org/10.1016/j.jcp.2007.09.020">DOI: 10.1016/j.jcp.2007.09.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L586-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdEquations2D)
flux_nonconservative_powell(u_ll, u_rr,
                            normal_direction_ll     ::AbstractVector,
                            normal_direction_average::AbstractVector,
                            equations::IdealGlmMhdEquations2D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdEquations2D"><code>IdealGlmMhdEquations2D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L309-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdEquations3D)
flux_nonconservative_powell(u_ll, u_rr,
                            normal_direction_ll     ::AbstractVector,
                            normal_direction_average::AbstractVector,
                            equations::IdealGlmMhdEquations3D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdEquations3D"><code>IdealGlmMhdEquations3D</code></a>.</p><p>On curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L274-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.flux_nonconservative_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,
                            equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>Non-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the <a href="#Trixi.IdealGlmMhdMulticomponentEquations2D"><code>IdealGlmMhdMulticomponentEquations2D</code></a>.</p><p><strong>References</strong></p><ul><li>Marvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification <a href="https://doi.org/10.1016/j.jcp.2018.06.027">DOI: 10.1016/j.jcp.2018.06.027</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L254-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L376-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations2D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L824-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerEquations3D)</code></pre><p>Entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L725-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L312-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.flux_ranocha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,
             equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Adaption of the entropy conserving and kinetic energy preserving two-point flux by</p><ul><li>Hendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws <a href="https://cuvillier.de/en/shop/publications/7743">PhD thesis, TU Braunschweig</a></li></ul><p>See also</p><ul><li>Hendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators <a href="https://doi.org/10.1007/978-3-030-39647-3_42">Proceedings of ICOSAHOM 2018</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L371-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L271-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,
                equations::CompressibleEulerEquations2D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L642-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}" href="#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}"><code>Trixi.flux_shima_etal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,
                equations::CompressibleEulerEquations3D)</code></pre><p>This flux is is a modification of the original kinetic energy preserving two-point flux by</p><ul><li>Yuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms <a href="https://doi.org/10.1016/j.jcp.2018.08.058">DOI: 10.1016/j.jcp.2018.08.058</a></li></ul><p>The modification is in the energy flux to guarantee pressure equilibrium and was developed by</p><ul><li>Nao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows <a href="https://doi.org/10.1016/j.jcp.2020.110060">DOI: 10.1016/j.jcp.2020.110060</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L502-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.get_examples-Tuple{}" href="#Trixi.get_examples-Tuple{}"><code>Trixi.get_examples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_examples()</code></pre><p>Return a list of all example elixirs that are provided by Trixi. See also <a href="#Trixi.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#Trixi.default_example-Tuple{}"><code>default_example</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.get_name-Tuple{Any}" href="#Trixi.get_name-Tuple{Any}"><code>Trixi.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(x)</code></pre><p>Returns a name of <code>x</code> ready for pretty printing. By default, return <code>string(y)</code> if <code>x isa Val{y}</code> and return <code>string(x)</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Trixi.get_name(&quot;test&quot;)
&quot;test&quot;

julia&gt; Trixi.get_name(Val(:test))
&quot;test&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L124-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.get_name-Tuple{Trixi.AbstractEquations}" href="#Trixi.get_name-Tuple{Trixi.AbstractEquations}"><code>Trixi.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(equations::AbstractEquations)</code></pre><p>Returns the canonical, human-readable name for the given system of equations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Trixi.get_name(CompressibleEulerEquations1D(1.4))
&quot;CompressibleEulerEquations1D&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.getmesh-Tuple{PlotData2D}" href="#Trixi.getmesh-Tuple{PlotData2D}"><code>Trixi.getmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmesh(pd::PlotData2D)</code></pre><p>Extract grid lines from <code>pd</code> for plotting with <code>Plots.plot</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/visualization/plot_recipes.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}" href="#Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}"><code>Trixi.global_mean_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_mean_vars(equations::AcousticPerturbationEquations2D)</code></pre><p>Returns the global mean variables stored in <code>equations</code>. This makes it easier to define flexible initial conditions for problems with constant mean flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.init_mpi-Tuple{}" href="#Trixi.init_mpi-Tuple{}"><code>Trixi.init_mpi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_mpi()</code></pre><p>Initialize MPI by calling <code>MPI.Initialized()</code>. The function will check if MPI is already initialized and if yes, do nothing, thus it is safe to call it multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/mpi.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.init_p4est-Tuple{}" href="#Trixi.init_p4est-Tuple{}"><code>Trixi.init_p4est</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_p4est()</code></pre><p>Initialize p4est by calling <code>p4est_init</code> and setting the log level to <code>SC_LP_ERROR</code>. This function will check if p4est is already initialized and if yes, do nothing, thus it is safe to call it multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/p4est.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_blast_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A medium blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_blast_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A medium blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L257-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_blast_wave(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>An MHD blast wave taken from</p><ul><li>Dominik Derigs, Gregor J. Gassner, Stefanie Walch &amp; Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics <a href="https://doi.org/10.1365/s13291-018-0178-9">doi: 10.1365/s13291-018-0178-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_blob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_blob(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>The blob test case taken from</p><ul><li>Agertz et al. (2006) Fundamental differences between SPH and grid methods <a href="https://arxiv.org/abs/astro-ph/0610051">arXiv: astro-ph/0610051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L371-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_blob-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_blob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_blob(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>The blob test case taken from</p><ul><li>Agertz et al. (2006) Fundamental differences between SPH and grid methods <a href="https://arxiv.org/abs/astro-ph/0610051">arXiv: astro-ph/0610051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L188-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_briowu_shock_tube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_briowu_shock_tube(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>Compound shock tube test case for one dimensional ideal MHD equations. It is bascially an MHD extension of the Sod shock tube. Taken from Section V of the article</p><ul><li>Brio and Wu (1988) An Upwind Differencing Scheme for the Equations of Ideal Magnetohydrodynamics <a href="https://doi.org/10.1016/0021-9991(88)90120-9">DOI: 10.1016/0021-9991(88)90120-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.initial_condition_briowu_shock_tube-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.initial_condition_briowu_shock_tube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_briowu_shock_tube(x, t, equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>Compound shock tube test case for one dimensional ideal MHD equations. It is bascially an MHD extension of the Sod shock tube. Taken from Section V of the article</p><ul><li>Brio and Wu (1988) An Upwind Differencing Scheme for the Equations of Ideal Magnetohydrodynamics <a href="https://doi.org/10.1016/0021-9991(88)90120-9">DOI: 10.1016/0021-9991(88)90120-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L123-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A constant initial condition where the state variables are zero and the mean flow is constant. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><p>initial<em>condition</em>constant(x, t, equations::IdealGlmMhdEquations3D)</p><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::InviscidBurgersEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/inviscid_burgers_1d.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LatticeBoltzmannEquations2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LatticeBoltzmannEquations3D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A constant initial condition to test free-stream preservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a>. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>A smooth initial condition used for convergence tests in combination with <a href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>source_terms_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>An Alfvén wave as smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::InviscidBurgersEquation1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/inviscid_burgers_1d.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A smooth initial condition used for convergence tests (in combination with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A smooth initial condition used for convergence tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_couette_steady-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.initial_condition_couette_steady-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.initial_condition_couette_steady</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_couette_unsteady(x, t, equations::LatticeBoltzmannEquations2D)</code></pre><p>Initial state for a <em>steady</em> Couette flow setup. To be used in combination with <a href="#Trixi.boundary_condition_couette-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_couette</code></a> and <a href="#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_wall_noslip</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_couette_unsteady-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.initial_condition_couette_unsteady-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.initial_condition_couette_unsteady</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_couette_unsteady(x, t, equations::LatticeBoltzmannEquations2D)</code></pre><p>Initial state for an <em>unsteady</em> Couette flow setup, which is also the exact solution for the incompressible Navier-Stokes equations. To be used in combination with <a href="#Trixi.boundary_condition_couette-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_couette</code></a> and <a href="#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_wall_noslip</code></a>. In the limit, this setup will converge to the state set in <a href="#Trixi.initial_condition_couette_steady-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>initial_condition_couette_steady</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L288-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_density_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_density_pressure_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_pressure_pulse(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A Gaussian pulse in density and pressure with constant velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_density_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_density_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_density_pulse-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_density_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_pulse(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A Gaussian pulse in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_density_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper</p><ul><li>Gregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes <a href="https://arxiv.org/abs/2007.09026">arXiv: 2007.09026</a></li></ul><p>with the following parameters</p><ul><li>domain [-1, 1]</li><li>mesh = 4x4</li><li>polydeg = 5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L116-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_density_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_density_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper</p><ul><li>Gregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes <a href="https://arxiv.org/abs/2007.09026">arXiv: 2007.09026</a></li></ul><p>with the following parameters</p><ul><li>domain [-1, 1]</li><li>mesh = 4x4</li><li>polydeg = 5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>One dimensional variant of the setup used for convergence tests of the Euler equations with self-gravity from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is no additional source term necessary for the manufactured solution in one spatial dimension. Thus, <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> is not present there.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L227-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> or <a href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_euler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L415-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> or <a href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_euler</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L253-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_2d.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}" href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}"><code>Trixi.initial_condition_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_harmonic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_3d.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A Gaussian pulse in a constant mean flow. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A Gaussian pulse used together with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_gauss)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equation::LinearScalarAdvectionEquation2D)</code></pre><p>A Gaussian pulse used together with <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_gauss)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A Gaussian pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_gauss_wall-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_gauss_wall-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_gauss_wall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_gauss_wall(x, t, equations::AcousticPerturbationEquations2D)</code></pre><p>A Gaussian pulse, used in the <code>gauss_wall</code> example elixir in combination with <a href="#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>boundary_condition_wall</code></a>. Uses the global mean values from <code>equations</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_harmonic_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.initial_condition_harmonic_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.initial_condition_harmonic_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>A non-priodic harmonic function used in combination with <a href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_poisson_nonperiodic</code></a> and <a href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>boundary_condition_poisson_nonperiodic</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The only harmonic functions in 1D have the form phi(x) = A + Bx</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_isentropic_vortex-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_isentropic_vortex-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_isentropic_vortex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_isentropic_vortex(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>The classical isentropic vortex test case of</p><ul><li>Chi-Wang Shu (1997) Essentially Non-Oscillatory and Weighted Essentially Non-Oscillatory Schemes for Hyperbolic Conservation Laws <a href="https://ntrs.nasa.gov/citations/19980007543">NASA/CR-97-206253</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L188-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_khi-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_khi-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_khi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_khi(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A version of the classical Kelvin-Helmholtz instability based on</p><ul><li>Andrés M. Rueda-Ramírez, Gregor J. Gassner (2021) A Subcell Finite Volume Positivity-Preserving Limiter for DGSEM Discretizations of the Euler Equations <a href="https://arxiv.org/abs/2102.06017">arXiv: 2102.06017</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L348-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_lid_driven_cavity-Tuple{Any, Any, LatticeBoltzmannEquations2D}" href="#Trixi.initial_condition_lid_driven_cavity-Tuple{Any, Any, LatticeBoltzmannEquations2D}"><code>Trixi.initial_condition_lid_driven_cavity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_lid_driven_cavity(x, t, equations::LatticeBoltzmannEquations2D)</code></pre><p>Initial state for a lid-driven cavity flow setup. To be used in combination with <a href="#Trixi.boundary_condition_lid_driven_cavity-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_lid_driven_cavity</code></a> and <a href="#Trixi.boundary_condition_wall_noslip-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}"><code>boundary_condition_wall_noslip</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>boundary_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}"><code>boundary_condition_linear_x</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_x_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_x_y(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1] + x[2]</code> used together with <a href="#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>boundary_condition_linear_x_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_linear_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_y(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A linear function of <code>x[1]</code> used together with <a href="#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}"><code>boundary_condition_linear_y</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_linear_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_linear_z(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A linear function of <code>x[3]</code> used together with <a href="#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}"><code>boundary_condition_linear_z</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_medium_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_medium_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_medium_sedov_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_medium_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>The Sedov blast wave setup based on Flash</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash</em>ug_devel/node184.html#SECTION010114000000000000000</li></ul><p>with smaller strength of the initial discontinuity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L316-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_monopole-Tuple{Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.initial_condition_monopole-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.initial_condition_monopole</code></a> — <span class="docstring-category">Method</span></header><section><div><p>initial<em>condition</em>monopole(x, t, equations::AcousticPerturbationEquations2D)</p><p>Initial condition for the monopole in a boundary layer setup, used in combination with <a href="#Trixi.boundary_condition_monopole-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}"><code>boundary_condition_monopole</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_orszag_tang</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_orszag_tang(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>The classical Orszag-Tang vortex test case. Here, the setup is taken from</p><ul><li>Dominik Derigs, Gregor J. Gassner, Stefanie Walch &amp; Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics <a href="https://doi.org/10.1365/s13291-018-0178-9">doi: 10.1365/s13291-018-0178-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_orszag_tang-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_orszag_tang</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_orszag_tang(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>The classical Orszag-Tang vortex test case. Here, the setup is taken from</p><ul><li>Dominik Derigs, Gregor J. Gassner, Stefanie Walch &amp; Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics <a href="https://doi.org/10.1365/s13291-018-0178-9">doi: 10.1365/s13291-018-0178-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L122-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.initial_condition_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>A non-priodic smooth initial condition. Can be used for convergence tests in combination with <a href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>source_terms_poisson_nonperiodic</code></a> and <a href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>boundary_condition_poisson_nonperiodic</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The solution is periodic but the initial guess is not.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_pressure_pulse-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_pressure_pulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_pressure_pulse(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A Gaussian pulse in the pressure with constant velocity and density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_rotor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_rotor(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>The classical MHD rotor test case. Here, the setup is taken from</p><ul><li>Dominik Derigs, Gregor J. Gassner, Stefanie Walch &amp; Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics <a href="https://doi.org/10.1365/s13291-018-0178-9">doi: 10.1365/s13291-018-0178-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L133-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.initial_condition_rotor-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.initial_condition_rotor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_rotor(x, t, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>The classical MHD rotor test case adapted to twocomponent. Here, the setup is taken from</p><ul><li>Dominik Derigs, Gregor J. Gassner, Stefanie Walch &amp; Andrew R. Winters (2018) Entropy Stable Finite Volume Approximations for Ideal Magnetohydrodynamics <a href="https://doi.org/10.1365/s13291-018-0178-9">doi: 10.1365/s13291-018-0178-9</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L126-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_ryujones_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_ryujones_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_ryujones_shock_tube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_ryujones_shock_tube(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>Ryu and Jones shock tube test case for one dimensional ideal MHD equations. Contains fast shocks, slow shocks, and rational discontinuities that propagate on either side of the contact discontinuity. Exercises the scheme to capture all 7 types of waves present in the one dimensional MHD equations. It is the second test from Section 4 of</p><ul><li>Ryu and Jones (1995) Numerical Magnetohydrodynamics in Astrophysics: Algorithm and Tests for One-Dimensional Flow <a href="https://doi.org/10.1086/175437">DOI: 10.1086/175437</a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This paper has a typo in the initial conditions. Their variable <code>E</code> should be <code>p</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L145-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_sedov_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>The Sedov blast wave setup based on Flash</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash</em>ug_devel/node184.html#SECTION010114000000000000000</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_sedov_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>The Sedov blast wave setup based on Flash</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash</em>ug_devel/node184.html#SECTION010114000000000000000</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L285-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_sedov_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_sedov_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>The Sedov blast wave setup based on Flash</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash</em>ug_devel/node184.html#SECTION010114000000000000000</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_self_gravity(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>boundary_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L502-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_self_gravity(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>boundary_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L351-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}" href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}"><code>Trixi.initial_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_self_gravity(x, t, equations::HyperbolicDiffusionEquations2D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>boundary_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_2d.jl#L175-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}" href="#Trixi.initial_condition_sedov_self_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}"><code>Trixi.initial_condition_sedov_self_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sedov_self_gravity(x, t, equations::HyperbolicDiffusionEquations3D)</code></pre><p>Adaptation of the Sedov blast wave with self-gravity taken from</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>based on</p><ul><li>http://flash.uchicago.edu/site/flashcode/user<em>support/flash4</em>ug_4p62/node184.html#SECTION010114000000000000000</li></ul><p>Should be used together with <a href="#Trixi.boundary_condition_sedov_self_gravity-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}"><code>boundary_condition_sedov_self_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_3d.jl#L170-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_shock_bubble-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D{5, 2, RealT} where RealT&lt;:Real}" href="#Trixi.initial_condition_shock_bubble-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D{5, 2, RealT} where RealT&lt;:Real}"><code>Trixi.initial_condition_shock_bubble</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_shock_bubble(x, t, equations::CompressibleEulerMulticomponentEquations2D{5, 2})</code></pre><p>A shock-bubble testcase for multicomponent Euler equations</p><ul><li>Ayoub Gouasmi, Karthik Duraisamy, Scott Murman Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations <a href="https://arxiv.org/abs/1904.00972">arXiv: 1904.00972</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L167-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_shu_osher_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_shu_osher_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_shu_osher_shock_tube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_shu_osher_shock_tube(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>Extended version of the test of Shu and Osher for one dimensional ideal MHD equations. Taken from Section 4.1 of</p><ul><li>Derigs et al. (2016) A Novel High-Order, Entropy Stable, 3D AMR MHD Solver withGuaranteed Positive Pressure <a href="https://doi.org/10.1016/j.jcp.2016.04.048">DOI: 10.1016/j.jcp.2016.04.048</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L175-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_shu_osher_shock_tube_flipped-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_shu_osher_shock_tube_flipped-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_shu_osher_shock_tube_flipped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_shu_osher_shock_tube_flipped(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>Extended version of the test of Shu and Osher for one dimensional ideal MHD equations but shock propogates from right to left.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is useful to exercise some of the components of the HLL flux.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L201-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}" href="#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}"><code>Trixi.initial_condition_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_1d.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}" href="#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}"><code>Trixi.initial_condition_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_3d.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}" href="#Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}"><code>Trixi.initial_condition_sin_sin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_sin_sin(x, t, equations::LinearScalarAdvectionEquation2D)</code></pre><p>A sine wave in the conserved variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/linear_scalar_advection_2d.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_taylor_green_vortex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_taylor_green_vortex(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>The classical inviscid Taylor-Green vortex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, LatticeBoltzmannEquations3D}" href="#Trixi.initial_condition_taylor_green_vortex-Tuple{Any, Any, LatticeBoltzmannEquations3D}"><code>Trixi.initial_condition_taylor_green_vortex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_taylor_green_vortex(x, t, equations::LatticeBoltzmannEquations3D)</code></pre><p>Initialize the flow field to the Taylor-Green vortex setup</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_torrilhon_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_torrilhon_shock_tube-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_torrilhon_shock_tube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_torrilhon_shock_tube(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>Torrilhon&#39;s shock tube test case for one dimensional ideal MHD equations.</p><ul><li>Torrilhon (2003) Uniqueness conditions for Riemann problems of ideal magnetohydrodynamics <a href="https://doi.org/10.1017/S0022377803002186">DOI: 10.1017/S0022377803002186</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_two_interacting_blast_waves-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.initial_condition_two_interacting_blast_waves-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.initial_condition_two_interacting_blast_waves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_two_interacting_blast_waves(x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>A multicomponent two interacting blast wave test taken from</p><ul><li>T. Plewa &amp; E. Müller (1999) The consistent multi-fluid advection method <a href="https://arxiv.org/pdf/astro-ph/9807241.pdf">arXiv: 9807241</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L181-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations1D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations2D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L229-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations3D)</code></pre><p>A weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>A for multicomponent adapted weak blast wave adapted to multicomponent and taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>A for multicomponent adapted weak blast wave taken from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations1D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations2D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations3D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations1D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_1d.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}" href="#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}"><code>Trixi.initial_condition_weak_blast_wave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations2D)</code></pre><p>A weak blast wave adapted from</p><ul><li>Sebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG <a href="https://arxiv.org/abs/2008.12044">arXiv: 2008.12044</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_multicomponent_2d.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any, N} where N}} where Func" href="#Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any, N} where N}} where Func"><code>Trixi.integrate_via_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate_via_indices(func, u_ode, semi::AbstractSemidiscretization, args...; normalize=true)</code></pre><p>Call <code>func(u, i..., element, equations, solver, args...)</code> for all nodal indices <code>i..., element</code> and integrate the result using a quadrature associated with the semidiscretization <code>semi</code>.</p><p>If <code>normalize</code> is true, the result is divided by the total volume of the computational domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.inv_ln_mean-Tuple{Any, Any}" href="#Trixi.inv_ln_mean-Tuple{Any, Any}"><code>Trixi.inv_ln_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv_ln_mean(x, y)</code></pre><p>Compute the inverse <code>1 / ln_mean(x, y)</code> of the logarithmic mean <a href="#Trixi.ln_mean-Tuple{Any, Any}"><code>ln_mean</code></a>.</p><p>This function may be used to increase performance where the inverse of the logarithmic mean is needed, by replacing a (slow) division by a (fast) multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/math.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.jacobian_ad_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian_ad_forward(semi::AbstractSemidiscretization;
                    t0=zero(real(semi)),
                    u0_ode=compute_coefficients(t0, semi))</code></pre><p>Uses the right-hand side operator of the semidiscretization <code>semi</code> and forward mode automatic differentiation to compute the Jacobian <code>J</code> of the semidiscretization <code>semi</code> at state <code>u0_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L210-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.jacobian_fd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian_fd(semi::AbstractSemidiscretization;
            t0=zero(real(semi)),
            u0_ode=compute_coefficients(t0, semi))</code></pre><p>Uses the right-hand side operator of the semidiscretization <code>semi</code> and simple second order finite difference to compute the Jacobian <code>J</code> of the semidiscretization <code>semi</code> at state <code>u0_ode</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.linear_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_structure(semi::AbstractSemidiscretization;
                 t0=zero(real(semi)))</code></pre><p>Wraps the right-hand side operator of the semidiscretization <code>semi</code> at time <code>t0</code> as an affine-linear operator given by a linear operator <code>A</code> and a vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ln_mean-Tuple{Any, Any}" href="#Trixi.ln_mean-Tuple{Any, Any}"><code>Trixi.ln_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ln_mean(x, y)</code></pre><p>Compute the logarithmic mean</p><pre><code class="nohighlight hljs">ln_mean(x, y) = (y - x) / (log(y) - log(x)) = (y - x) / log(y / x)</code></pre><p>Problem: The formula above has a removable singularity at <code>x == y</code>. Thus, some care must be taken to implement it correctly without problems or loss of accuracy when <code>x ≈ y</code>. Here, we use the approach proposed by Ismail and Roe (2009). Set ξ = y / x. Then, we have</p><pre><code class="nohighlight hljs">(y - x) / log(y / x) = (x + y) / log(ξ) * (ξ - 1) / (ξ + 1)</code></pre><p>Set f = (ξ - 1) / (ξ + 1) = (y - x) / (x + y). Then, we use the expansion</p><pre><code class="nohighlight hljs">log(ξ) = 2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7) + O(ξ^9)</code></pre><p>Inserting the first few terms of this expansion yields</p><pre><code class="nohighlight hljs">(y - x) / log(ξ) ≈ (x + y) * f / (2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7))
                 = (x + y) / (2 + 2/3 * f^2 + 2/5 * f^4 + 2/7 * f^6)</code></pre><p>Since divisions are usually more expensive on modern hardware than multiplications (Agner Fog), we try to avoid computing two divisions. Thus, we use</p><pre><code class="nohighlight hljs">f^2 = (y - x)^2 / (x + y)^2
    = (x * (x - 2 * y) + y * y) / (x * (x + 2 * y) + y * y)</code></pre><p>Given ε = 1.0e-4, we use the following algorithm.</p><pre><code class="nohighlight hljs">if f^2 &lt; ε
  # use the expansion above
else
  # use the direct formula (y - x) / log(y / x)
end</code></pre><p><strong>References</strong></p><ul><li>Ismail, Roe (2009). Affordable, entropy-consistent Euler flux functions II: Entropy production at shocks. <a href="https://doi.org/10.1016/j.jcp.2009.04.021">DOI: 10.1016/j.jcp.2009.04.021</a></li><li>Agner Fog. Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD, and VIA CPUs. https://www.agner.org/optimize/instruction_tables.pdf</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/math.jl#L8-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.load_mesh-Tuple{AbstractString}" href="#Trixi.load_mesh-Tuple{AbstractString}"><code>Trixi.load_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_mesh(restart_file::AbstractString; n_cells_max)</code></pre><p>Load the mesh from the <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/mesh_io.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.load_time-Tuple{AbstractString}" href="#Trixi.load_time-Tuple{AbstractString}"><code>Trixi.load_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_time(restart_file::AbstractString)</code></pre><p>Load the time saved in a <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/save_restart.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.max-Tuple" href="#Trixi.max-Tuple"><code>Trixi.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max(x, y, ...)</code></pre><p>Return the maximum of the arguments. See also the <code>maximum</code> function to take the maximum element from a collection.</p><p>This version in Trixi.jl is semantically equivalent to <code>Base.max</code> but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of <code>NaN</code>s (or signed zeros).</p><p><strong>Examples</strong></p><p>julia&gt; max(2, 5, 1) 5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/math.jl#L159-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.max_abs_speed_naive" href="#Trixi.max_abs_speed_naive"><code>Trixi.max_abs_speed_naive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_abs_speed_naive(u_ll, u_rr, orientation::Integer,   equations)
max_abs_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>Simple and fast estimate of the maximal wave speed of the Riemann problem with left and right states <code>u_ll, u_rr</code>, based only on the local wave speeds associated to <code>u_ll</code> and <code>u_rr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.min-Tuple" href="#Trixi.min-Tuple"><code>Trixi.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min(x, y, ...)</code></pre><p>Return the minimum of the arguments. See also the <code>minimum</code> function to take the minimum element from a collection.</p><p>This version in Trixi.jl is semantically equivalent to <code>Base.min</code> but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of <code>NaN</code>s (or signed zeros).</p><p><strong>Examples</strong></p><p>julia&gt; min(2, 5, 1) 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/math.jl#L176-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.min_max_speed_naive" href="#Trixi.min_max_speed_naive"><code>Trixi.min_max_speed_naive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_naive(u_ll, u_rr, orientation::Integer,   equations)
min_max_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)</code></pre><p>Simple and fast estimate of the minimal and maximal wave speed of the Riemann problem with left and right states <code>u_ll, u_rr</code>, usually based only on the local wave speeds associated to <code>u_ll</code> and <code>u_rr</code>.</p><ul><li>Amiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws <a href="https://doi.org/10.1137/1025002">DOI: 10.1137/1025002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/numerical_fluxes.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}" href="#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}"><code>Trixi.min_max_speed_naive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_1d.jl#L403-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}" href="#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}"><code>Trixi.min_max_speed_naive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_2d.jl#L728-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}" href="#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}"><code>Trixi.min_max_speed_naive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_max_speed_naive(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)</code></pre><p>Calculate minimum and maximum wave speeds for HLL-type fluxes as in</p><ul><li>Li (2005) An HLLC Riemann solver for magneto-hydrodynamics <a href="https://doi.org/10.1016/j.jcp.2004.08.020">DOI: 10.1016/j.jcp.2004.08.020</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/ideal_glm_mhd_3d.jl#L748-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.multiply_dimensionwise-Tuple{AbstractMatrix{T} where T, AbstractMatrix{var&quot;#s177&quot;} where var&quot;#s177&quot;}" href="#Trixi.multiply_dimensionwise-Tuple{AbstractMatrix{T} where T, AbstractMatrix{var&quot;#s177&quot;} where var&quot;#s177&quot;}"><code>Trixi.multiply_dimensionwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiply_dimensionwise(matrix::AbstractMatrix, data_in::AbstractArray{&lt;:Any, NDIMS+1})</code></pre><p>Multiply the array <code>data_in</code> by <code>matrix</code> in each coordinate direction, where <code>data_in</code> is assumed to have the first coordinate for the number of variables and the remaining coordinates are multiplied by <code>matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/solvers/dgsem/interpolation.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}" href="#Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}"><code>Trixi.ndofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndofs(semi::AbstractSemidiscretization)</code></pre><p>Return the number of degrees of freedom associated with each scalar variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.partition!-Tuple{TreeMesh{NDIMS, var&quot;#s176&quot;} where {NDIMS, var&quot;#s176&quot;&lt;:Trixi.ParallelTree{NDIMS}}}" href="#Trixi.partition!-Tuple{TreeMesh{NDIMS, var&quot;#s176&quot;} where {NDIMS, var&quot;#s176&quot;&lt;:Trixi.ParallelTree{NDIMS}}}"><code>Trixi.partition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition!(mesh::ParallelTreeMesh, allow_coarsening=true)</code></pre><p>Partition <code>mesh</code> using a static domain decomposition algorithm based on leaf cell count and tree structure. If <code>allow_coarsening</code> is <code>true</code>, the algorithm will keep leaf cells together on one rank when needed for local coarsening (i.e. when all children of a cell are leaves).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/meshes/parallel_tree_mesh.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}" href="#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}"><code>Trixi.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure(rho::Real, equations::LatticeBoltzmannEquations2D)
pressure(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic pressure from the density <code>rho</code> or the  particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L418-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}" href="#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}"><code>Trixi.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pressure(rho::Real, equations::LatticeBoltzmannEquations3D)
pressure(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic pressure from the density <code>rho</code> or the  particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L308-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.prim2cons" href="#Trixi.prim2cons"><code>Trixi.prim2cons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prim2cons(u, equations)</code></pre><p>Convert the conserved variables <code>u</code> to the primitive variables for a given set of <code>equations</code>. The inverse conversion is performed by <a href="#Trixi.cons2prim"><code>cons2prim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}" href="#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}"><code>Trixi.residual_steady_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_steady_state(du, ::AbstractHyperbolicDiffusionEquations)</code></pre><p>Used to determine the termination criterion of a <a href="#Trixi.SteadyStateCallback"><code>SteadyStateCallback</code></a>. For hyperbolic diffusion, this checks convergence of the potential <span>$\phi$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_3d.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.rotate_from_x" href="#Trixi.rotate_from_x"><code>Trixi.rotate_from_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_from_x(u, normal, equations)</code></pre><p>Apply the rotation that maps the x-axis onto <code>normal</code> to the convservative variables <code>u</code>. This is used by <a href="#Trixi.FluxRotated"><code>FluxRotated</code></a> to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.</p><p>See also: <a href="#Trixi.rotate_to_x"><code>rotate_to_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.rotate_to_x" href="#Trixi.rotate_to_x"><code>Trixi.rotate_to_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_to_x(u, normal, equations)</code></pre><p>Apply the rotation that maps <code>normal</code> onto the x-axis to the convservative variables <code>u</code>. This is used by <a href="#Trixi.FluxRotated"><code>FluxRotated</code></a> to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.</p><p>See also: <a href="#Trixi.rotate_from_x"><code>rotate_from_x</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/equations.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.save_plot-Tuple{Any, Any}" href="#Trixi.save_plot-Tuple{Any, Any}"><code>Trixi.save_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_plot(plot_data, variable_names;
          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),
          time=nothing, timestep=nothing)</code></pre><p>Visualize the plot data object provided in <code>plot_data</code> and save result as a PNG file in the <code>out</code> directory, plotting only the variables in <code>variable_names</code> and, optionally, the mesh (if <code>show_mesh</code> is <code>true</code>).  Additionally, <code>plot_arguments</code> will be unpacked and passed as keyword arguments to the <code>Plots.plot</code> command.</p><p>The <code>timestep</code> is used in the filename. <code>time</code> is currently unused by this function.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>See also: <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>, <a href="#Trixi.show_plot-Tuple{Any, Any}"><code>show_plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/visualization.jl#L203-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}" href="#Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}"><code>Trixi.semidiscretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semidiscretize(semi::AbstractSemidiscretization, tspan, restart_file::AbstractString)</code></pre><p>Wrap the semidiscretization <code>semi</code> as an ODE problem in the time interval <code>tspan</code> that can be passed to <code>solve</code> from the <a href="https://diffeq.sciml.ai/latest/">SciML ecosystem</a>. The initial condition etc. is taken from the <code>restart_file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}" href="#Trixi.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}"><code>Trixi.semidiscretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semidiscretize(semi::AbstractSemidiscretization, tspan)</code></pre><p>Wrap the semidiscretization <code>semi</code> as an ODE problem in the time interval <code>tspan</code> that can be passed to <code>solve</code> from the <a href="https://diffeq.sciml.ai/latest/">SciML ecosystem</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/semidiscretization/semidiscretization.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.show_plot-Tuple{Any, Any}" href="#Trixi.show_plot-Tuple{Any, Any}"><code>Trixi.show_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_plot(plot_data, variable_names;
          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),
          time=nothing, timestep=nothing)</code></pre><p>Visualize the plot data object provided in <code>plot_data</code> and display result, plotting only the variables in <code>variable_names</code> and, optionally, the mesh (if <code>show_mesh</code> is <code>true</code>).  Additionally, <code>plot_arguments</code> will be unpacked and passed as keyword arguments to the <code>Plots.plot</code> command.</p><p>This function is the default <code>plot_creator</code> argument for the <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>. <code>time</code> and <code>timestep</code> are currently unused by this function.</p><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>See also: <a href="#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>, <a href="#Trixi.save_plot-Tuple{Any, Any}"><code>save_plot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/visualization.jl#L164-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><p>source<em>terms</em>convergence_test(u, x, t, equations::AcousticPerturbationEquations2D)</p><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/acoustic_perturbation_2d.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_1d.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a> (and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_convergence_test)</code></a> in non-periodic domains).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}" href="#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}"><code>Trixi.source_terms_convergence_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_convergence_test(u, x, t, equations::InviscidBurgersEquation1D)</code></pre><p>Source terms used for convergence tests in combination with <a href="#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}"><code>initial_condition_convergence_test</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/inviscid_burgers_1d.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L443-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_eoc_test_coupled_euler_gravity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L282-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}" href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>Trixi.source_terms_eoc_test_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations2D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_2d.jl#L472-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}" href="#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}"><code>Trixi.source_terms_eoc_test_euler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations3D)</code></pre><p>Setup used for convergence tests of the Euler equations with self-gravity used in</p><ul><li>Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics <a href="https://arxiv.org/abs/2008.10593">arXiv: 2008.10593</a></li></ul><p>in combination with <a href="#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}"><code>initial_condition_eoc_test_coupled_euler_gravity</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method is to be used for testing pure Euler simulations with analytic self-gravity. If you intend to do coupled Euler-gravity simulations, you need to use <a href="#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}"><code>source_terms_eoc_test_coupled_euler_gravity</code></a> instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_3d.jl#L314-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.source_terms_harmonic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations1D)</code></pre><p>Source term that only includes the forcing from the hyperbolic diffusion system used with <a href="#Trixi.initial_condition_harmonic_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>initial_condition_harmonic_nonperiodic</code></a> and <a href="#Trixi.BoundaryConditionDirichlet"><code>BoundaryConditionDirichlet(initial_condition_harmonic_nonperiodic)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}" href="#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>Trixi.source_terms_poisson_nonperiodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">source_terms_poisson_nonperiodic(u, x, t,
                                 equations::HyperbolicDiffusionEquations1D)</code></pre><p>Source terms that include the forcing function <code>f(x)</code> and right hand side for the hyperbolic diffusion system that is used with <a href="#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}"><code>initial_condition_poisson_nonperiodic</code></a> and <a href="#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}"><code>boundary_condition_poisson_nonperiodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/hyperbolic_diffusion_1d.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}" href="#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}"><code>Trixi.totalgamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totalgamma(u, equations::CompressibleEulerMulticomponentEquations1D)</code></pre><p>Function that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_1d.jl#L493-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}" href="#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}"><code>Trixi.totalgamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totalgamma(u, equations::CompressibleEulerMulticomponentEquations2D)</code></pre><p>Function that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/compressible_euler_multicomponent_2d.jl#L571-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.trixi_include-Tuple{Module, AbstractString}" href="#Trixi.trixi_include-Tuple{Module, AbstractString}"><code>Trixi.trixi_include</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)</code></pre><p><code>include</code> the file <code>elixir</code> and evaluate its content in the global scope of module <code>mod</code>. You can override specific assignments in <code>elixir</code> by supplying keyword arguments. It&#39;s basic purpose is to make it easier to modify some parameters while running Trixi from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; redirect_stdout(devnull) do
         trixi_include(@__MODULE__, joinpath(examples_dir(), &quot;tree_1d_dgsem&quot;, &quot;elixir_advection_extended.jl&quot;),
                       tspan=(0.0, 0.1))
         sol.t[end]
       end
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/special_elixirs.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.uses_amr-Tuple{Any}" href="#Trixi.uses_amr-Tuple{Any}"><code>Trixi.uses_amr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uses_amr(callback)</code></pre><p>Checks whether the provided callback or <code>CallbackSet</code> is an <a href="#Trixi.AMRCallback"><code>AMRCallback</code></a> or contains one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/callbacks_step/amr.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}" href="#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, orientation, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic velocity for the given <code>orientation</code> (1 -&gt; x, 2 -&gt; y) from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L387-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}" href="#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, orientation, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic velocity for the given <code>orientation</code> (1 -&gt; x, 2 -&gt; y, 3 -&gt; z) from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}" href="#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, equations::LatticeBoltzmannEquations2D)</code></pre><p>Calculate the macroscopic velocity vector from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_2d.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}" href="#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}"><code>Trixi.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(u, equations::LatticeBoltzmannEquations3D)</code></pre><p>Calculate the macroscopic velocity vector from the particle distribution functions <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/equations/lattice_boltzmann_3d.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Trixi.@threaded-Tuple{Any}" href="#Trixi.@threaded-Tuple{Any}"><code>Trixi.@threaded</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@threaded for ... end</code></pre><p>Semantically the same as <code>Threads.@threads</code> when iterating over a <code>AbstractUnitRange</code> but without guarantee that the underlying implementation uses <code>Threads.@threads</code> or works for more general <code>for</code> loops. In particular, there may be an additional check whether only one thread is used to reduce the overhead of serial execution or the underlying threading capabilities might be provided by other packages such as <a href="https://github.com/JuliaSIMD/Polyester.jl">Polyester.jl</a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>This macro does not necessarily work for general <code>for</code> loops. For example, it does not necessarily support general iterables such as <code>eachline(filename)</code>.</p></div></div><p>Some discussion can be found at https://discourse.julialang.org/t/overhead-of-threads-threads/53964 and https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/Trixi.jl/blob/5645fe6c60ef9c981692f90fa4af3cfa5c2f94c3/src/auxiliary/auxiliary.jl#L145-L161">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../troubleshooting/">« Troubleshooting and FAQ</a><a class="docs-footer-nextpage" href="../reference-trixi2vtk/">Trixi2Vtk.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 17 August 2021 06:31">Tuesday 17 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
